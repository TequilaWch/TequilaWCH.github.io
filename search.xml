<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>刀马WCH的一方净土</title>
    <url>/2020/07/29/%E5%88%80%E9%A9%ACWCH%E7%9A%84%E4%B8%80%E6%96%B9%E5%87%80%E5%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是刀马WCH的个人blog，用来写一些乱七八糟的东西</p>
<p>平时写的论文，学习时的笔记，无聊时的思考都会往上面挂</p>
<blockquote>
<p>通过点击 封面右上角的标签 你可以访问我的GitHub主页 </p>
<p>在 主页 你可以看见所有文章的预览</p>
<p>在 归档 你可以看到所有文章的发布时间</p>
<p>在 标签 你可以看到文章的分类，点击进去可以看到这个目录下的所有文章</p>
<p>在 音乐 会定期更新为我近期最喜欢的歌，希望你也喜欢</p>
<p>通过左下角的放大镜 你可以启用查找功能</p>
</blockquote>
<p>希望你能喜欢这一片属于我的净土</p>
<p>下面这个歌单送给你，Have a nice day！</p>

    <div id="aplayer-IYPbWPpo" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="5314288012" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="60px" data-preload="none" data-theme="#228B22"
    ></div>

<p>找资源请点击阅读全文</p>
<a id="more"></a>

<p>想要我的宝藏吗，去找吧，我把它放在一个只有熊知道的地方了(搜索与熊论道)：</p>
<blockquote>
<p>熊曰：呋食物噔嗅萌噤咯意告類意森咬溫爾蜜拙我爾住拙森爾歡性告哈麼達哈咬笨盜發吃常更拙達捕嘶象圖咬洞果呱住嗚更沒嗷有沒嚄蜂拙誘堅物囑蜜肉嘿哞食嘿類沒果現訴咬溫蜜出蜜很襲萌山嗅誘告冬爾萌住唬哈嗡嗅麼洞盜註</p>
</blockquote>
]]></content>
      <tags>
        <tag>恶魔的轻语闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x11</title>
    <url>/2020/11/29/Compiler%E5%AD%A6%E4%B9%A0-0x11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="编译系统原理预习作业11-刀马WCH"><a href="#编译系统原理预习作业11-刀马WCH" class="headerlink" title="编译系统原理预习作业11@刀马WCH"></a>编译系统原理预习作业11@刀马WCH</h1><a id="more"></a>

<h2 id="1：消除左递归时改写翻译模式"><a href="#1：消除左递归时改写翻译模式" class="headerlink" title="1：消除左递归时改写翻译模式"></a>1：消除左递归时改写翻译模式</h2><p>对一下文法消除左递归，并相应的修改其翻译模式</p>
<blockquote>
<p>E -&gt; E1 + T  {E.<em>nptr</em> = mknode(“+”, E1.<em>nptr</em> , T.<em>nptr</em> )}</p>
<p>E -&gt; E1 - T  {E.<em>nptr</em> = mknode(“-”, E1.<em>nptr</em> , T.<em>nptr</em> )}</p>
<p>E -&gt; T  {E.<em>nptr</em> = T.<em>nptr</em> }</p>
<p>T -&gt; (E)  {T.<em>nptr</em> = E.<em>nptr</em>}</p>
<p>T -&gt; <strong>id</strong>  {T.<em>nptr</em> = mkleaf(<strong>id</strong>, <strong>id</strong>.<em>entry</em>)}</p>
<p>T -&gt; <strong>num</strong> {T.<em>nptr</em> = mkleaf(<strong>num</strong>, <strong>num</strong>.<em>entry</em>)}</p>
</blockquote>
<p>将文法改写并修改其翻译模式如下</p>
<blockquote>
<p>E -&gt; T {R.i = T.nptr;} R {E.nptr = R.s;}</p>
<p>R -&gt; + T {R1.i = mknode(“+”,R.i,T.nptr);} R1 {R.s = R1.s}</p>
<p>R -&gt; - T {R1.i = mknode(“-“,R.i,T.nptr);} R1 {R.s = R1.s}</p>
<p>R -&gt; ε {R.s = R.i;}</p>
<p>T -&gt; (E) {T.nptr = E.nodeval;}</p>
<p>T -&gt; <strong>id</strong>  {T.<em>nptr</em> = mkleaf(<strong>id</strong>, <strong>id</strong>.<em>entry</em>)}</p>
<p>T -&gt; <strong>num</strong>  {T.<em>nptr</em> = mkleaf(<strong>num</strong>, <strong>num</strong>.<em>entry</em>)}</p>
</blockquote>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x10</title>
    <url>/2020/11/29/Compiler%E5%AD%A6%E4%B9%A0-0x10/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="编译系统原理预习作业-刀马WCH"><a href="#编译系统原理预习作业-刀马WCH" class="headerlink" title="编译系统原理预习作业@刀马WCH"></a>编译系统原理预习作业@刀马WCH</h1><a id="more"></a>

<h2 id="1：规范LR分析"><a href="#1：规范LR分析" class="headerlink" title="1：规范LR分析"></a>1：规范LR分析</h2><blockquote>
<p>S’ -&gt; S</p>
<p>S -&gt; CC</p>
<p>C -&gt; cC | d</p>
</blockquote>
<p>根据以上文法，对ccd分别进行SLR分析和规范LR分析</p>
<p>划分项目如下</p>
<blockquote>
<p>I<del>0</del>：{S’-&gt;S,S-&gt;.CC,C-&gt;.cC,C-&gt;.d}</p>
<p>I<del>1</del>：{S’-&gt;S.}</p>
<p>I<del>2</del>：{S-&gt;C.C,C-&gt;.cC,C-&gt;.d}</p>
<p>I<del>3</del>：{C-&gt;c.C,CC-&gt;.cC,C-&gt;.d}</p>
<p>I<del>4</del>：{C-&gt;d.}</p>
<p>I<del>5</del>：{C-&gt;cC.}</p>
<p>I<del>6</del>：{S-&gt;CC.}</p>
</blockquote>
<p>做出项目集规范族如下</p>
<p><img src="https://i.loli.net/2020/11/22/erWycYI3XzSFKgV.png" alt="IMG_0074.PNG"></p>
<p>计算FOLLOW集如下</p>
<blockquote>
<p>FOLLOW(S’) = FOLLOW(S) = {$}</p>
<p>FOLLOW(C) = {$,c,d}</p>
</blockquote>
<p>其SLR分析表如下</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>输入c</th>
<th>输入d</th>
<th>输入$</th>
<th>gotoS</th>
<th>gotoC</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>s3</td>
<td>s4</td>
<td></td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td>accept</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>s3</td>
<td>s4</td>
<td></td>
<td></td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>s3</td>
<td>s4</td>
<td></td>
<td></td>
<td>5</td>
</tr>
<tr>
<td>4</td>
<td>r3</td>
<td>r3</td>
<td>r3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>r2</td>
<td>r2</td>
<td>r2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td>r1</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>对ccd进行SLR分析如下</p>
<table>
<thead>
<tr>
<th>STACK</th>
<th>INPUT</th>
<th>REMARK</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ccd$</td>
<td>移进</td>
</tr>
<tr>
<td>0c3</td>
<td>cd$</td>
<td>移进</td>
</tr>
<tr>
<td>0c3c3</td>
<td>d$</td>
<td>移进</td>
</tr>
<tr>
<td>0c3c3d4</td>
<td>$</td>
<td>归约C-&gt;d</td>
</tr>
<tr>
<td>0c3c3C5</td>
<td>$</td>
<td>归约C-&gt;cC</td>
</tr>
<tr>
<td>0c3C5</td>
<td>$</td>
<td>归约C-&gt;cC</td>
</tr>
<tr>
<td>0C2</td>
<td>$</td>
<td>error</td>
</tr>
</tbody></table>
<p>其LR分析表如PPT所示</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>输入c</th>
<th>输入d</th>
<th>输入$</th>
<th>gotoS</th>
<th>gotoC</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>s3</td>
<td>s4</td>
<td></td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td>acc</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>s6</td>
<td>s7</td>
<td></td>
<td></td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>s3</td>
<td>s4</td>
<td></td>
<td></td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>r3</td>
<td>r3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td>r1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>s6</td>
<td>s7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td>r3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>r2</td>
<td>r2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td></td>
<td></td>
<td>r2</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>对其进行LR分析如下</p>
<table>
<thead>
<tr>
<th>STACK</th>
<th>INPUT</th>
<th>REMARK</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ccd$</td>
<td>移进</td>
</tr>
<tr>
<td>0c3</td>
<td>cd$</td>
<td>移进</td>
</tr>
<tr>
<td>0c3c3</td>
<td>d$</td>
<td>移进</td>
</tr>
<tr>
<td>0c3c3d4</td>
<td>$</td>
<td>error</td>
</tr>
</tbody></table>
<h2 id="2：LALR分析"><a href="#2：LALR分析" class="headerlink" title="2：LALR分析"></a>2：LALR分析</h2><p>LR分析过程如上，不做重复</p>
<p>LALR分析过程如下</p>
<p>对上面的LR分析表进行合并，得到如下结果</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>输入c</th>
<th>输入d</th>
<th>输入$</th>
<th>gotoS</th>
<th>gotoC</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>s36</td>
<td>s47</td>
<td></td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td>acc</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>s36</td>
<td>s47</td>
<td></td>
<td></td>
<td>5</td>
</tr>
<tr>
<td>36</td>
<td>s36</td>
<td>s47</td>
<td></td>
<td></td>
<td>89</td>
</tr>
<tr>
<td>47</td>
<td>r3</td>
<td>r3</td>
<td>r3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td>r1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>89</td>
<td>r2</td>
<td>r2</td>
<td>r2</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>分析如下</p>
<table>
<thead>
<tr>
<th>STACK</th>
<th>INPUT</th>
<th>REMARK</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ccd$</td>
<td>移进</td>
</tr>
<tr>
<td>0c36</td>
<td>cd$</td>
<td>移进</td>
</tr>
<tr>
<td>0c36c36</td>
<td>d$</td>
<td>移进</td>
</tr>
<tr>
<td>0c36c36d47</td>
<td>$</td>
<td>归约C-&gt;d</td>
</tr>
<tr>
<td>0c36c36C89</td>
<td>$</td>
<td>归约C-&gt;cC</td>
</tr>
<tr>
<td>0c36C89</td>
<td>$</td>
<td>归约C-&gt;cC</td>
</tr>
<tr>
<td>0C89</td>
<td>$</td>
<td>error</td>
</tr>
</tbody></table>
<h2 id="3：语法制导定义"><a href="#3：语法制导定义" class="headerlink" title="3：语法制导定义"></a>3：语法制导定义</h2><blockquote>
<p>尝试对上述语法仅使用综合属性语法制导定义来实现相同的翻译</p>
</blockquote>
<p>一条咸鱼放弃了思考，感觉有点复杂而精力不足了</p>
<h2 id="4：构造DAG"><a href="#4：构造DAG" class="headerlink" title="4：构造DAG"></a>4：构造DAG</h2><p><img src="https://i.loli.net/2020/11/22/MvBjUNq5KTXw3Pi.png" alt="IMG_0075.PNG"></p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Ucore-lab2</title>
    <url>/2020/11/13/Ucore-lab2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>本文记录了清华大学操作系统使用的Ucore实验的lab2的报告</p>
<p>由我，YYF同学及LZQ同学共同完成，感谢二位大佬的指教和帮助</p>
<p>仅供学习交流使用，未经许可不得转载，抄袭。</p>
</blockquote>
<a id="more"></a>

<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>实验一过后大家做出来了一个可以启动的系统，实验二主要涉及操作系统的物理内存管理。 操作系统为了使用内存，还需高效地管理内存资源。在实验二中大家会了解并且自己动手完 成一个简单的物理内存管理系统。</p>
<p>实验目的如下</p>
<ul>
<li>理解基于段页式内存地址的转换机制</li>
<li>理解页表的建立和使用方法</li>
<li>理解物理内存的管理方法</li>
</ul>
<p>在开始实验前，别忘了将lab1中已经完成的代码填入本实验中代码有LAB1的注释的相应部分。可以采用diff和patch工具进行半自动的合并(merge)，也可以用一些图形化的比较/merge工具来合并，比如meld，eclipse中的diff/merge工具，understand中的diff/merge工具</p>
<h2 id="练习0：合并Lab0和Lab1代码"><a href="#练习0：合并Lab0和Lab1代码" class="headerlink" title="练习0：合并Lab0和Lab1代码"></a>练习0：合并Lab0和Lab1代码</h2><p><img src="https://i.loli.net/2020/11/05/wrHk5b68dyYtceK.png" alt="image-20201102235653991.png"></p>
<p>使用meld工具打开文件进行比较，因为lab1只修改了trap.c，init.c和kdegub.c这三个文件，所以一一比较合并即可。</p>
<h2 id="练习1：实现first-fit连续物理内存分配算法-需要编程"><a href="#练习1：实现first-fit连续物理内存分配算法-需要编程" class="headerlink" title="练习1：实现first-fit连续物理内存分配算法(需要编程)"></a>练习1：实现first-fit连续物理内存分配算法(需要编程)</h2><blockquote>
<p>在实现first fit 内存分配算法的回收函数时，要考虑地址连续的空闲块之间的合并操作。提示: 在建立空闲页块链表时，需要按照空闲页块起始地址来排序，形成一个有序的链表。可能会 修改default_pmm.c中的default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数。请仔细查看和理解default_pmm.c中的注释。</p>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p>
<ul>
<li>你的first fit算法是否有进一步的改进空间</li>
</ul>
</blockquote>
<p>ucore中采用面向对象编程的思想，将物理内存管理的内容抽象成若干个特定的函数，并以结构体pmm_manager作为物理内存管理器封装各个内存管理函数的指针，这样在管理物理内存时只需调用结构体内封装的函数，从而可将内存管理功能的具体实现与系统中其他部分隔离开。pmm_manager中保存的函数及其功能如下所述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                                 <span class="comment">/*某种物理内存管理器的名称（可根据算法等具体实现的不同自定义新的内存管理器，这样也更加符合面向对象的思想）*/</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(<span class="keyword">void</span>);                               <span class="comment">/*物理内存管理器初始化，包括生成内部描述和数据结构（空闲块链表和空闲页总数）*/</span> </span><br><span class="line">    <span class="keyword">void</span> (*init_memmap)(struct Page *base, <span class="keyword">size_t</span> n); <span class="comment">/*初始化空闲页，根据初始时的空闲物理内存区域将页映射到物理内存上*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *(*<span class="title">alloc_pages</span>)(<span class="title">size_t</span> <span class="title">n</span>);</span>            <span class="comment">//申请分配指定数量的物理页</span></span><br><span class="line">    <span class="keyword">void</span> (*free_pages)(struct Page *base, <span class="keyword">size_t</span> n);  <span class="comment">//申请释放若干指定物理页</span></span><br><span class="line">    <span class="keyword">size_t</span> (*nr_free_pages)(<span class="keyword">void</span>);                    <span class="comment">//查询当前空闲页总数</span></span><br><span class="line">    <span class="keyword">void</span> (*check)(<span class="keyword">void</span>);                              <span class="comment">//检查物理内存管理器的正确性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上图为pmm.h当中定义的结构体pmm_manager</p>
</blockquote>
<p>涉及的结构体和宏定义：</p>
<p>memlayout.h中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                        <span class="comment">// page frame's reference counter</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">//描述物理页帧状态的标志位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;          <span class="comment">//只在空闲块内第一页中用于记录该块中页数，其他页都是0</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;         <span class="comment">//空闲物理内存块双向链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Flags describing the status of a page frame */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_reserved                 0       <span class="comment">// if this bit=1: the Page is reserved for kernel, cannot be used in alloc/free_pages; otherwise, this bit=0 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_property                 1       <span class="comment">// if this bit=1: the Page is the head page of a free memory block(contains some continuous_addrress pages), and can be used in alloc_pages; if this bit=0: if the Page is the the head page of a free memory block, then this Page and the memory block is alloced. Or this Page isn't the head page.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SetPageReserved(page)       set_bit(PG_reserved, &amp;((page)-&gt;flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ClearPageReserved(page)     clear_bit(PG_reserved, &amp;((page)-&gt;flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PageReserved(page)          test_bit(PG_reserved, &amp;((page)-&gt;flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SetPageProperty(page)       set_bit(PG_property, &amp;((page)-&gt;flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ClearPageProperty(page)     clear_bit(PG_property, &amp;((page)-&gt;flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PageProperty(page)          test_bit(PG_property, &amp;((page)-&gt;flags))</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* free_area_t - maintains a doubly linked list to record free (unused) pages */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> free_list;         <span class="comment">// the list header(@ with a forward ptr &amp; a backward ptr)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_free;           <span class="comment">// # of free pages in this free list</span></span><br><span class="line">&#125; <span class="keyword">free_area_t</span>;</span><br></pre></td></tr></table></figure>

<p>list.h：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*list_entry_t是双链表结点的两个指针构成的集合，这个空闲块链表实际上是将各个块首页的指针集合（由prev和next构成）的指针（或者说指针集合所在地址）相连*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> <span class="title">list_entry_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>练习一共需实现四个函数：</p>
<ul>
<li>default_init：初始化物理内存管理器；</li>
<li>default_init_memmap：初始化空闲页；</li>
<li>default_alloc_pages：申请分配指定数量的物理页；</li>
<li>default_free_pages: 申请释放若干指定物理页；</li>
</ul>
<p>直接修改default_pmm.c中的内存管理函数来实现。</p>
<p><strong>default_init：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">free_area_t</span> free_area; <span class="comment">/*allocate blank memory for the doublely linked list*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free_list (free_area.free_list)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nr_free (free_area.nr_free)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">default_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    list_init(&amp;free_list);</span><br><span class="line">    nr_free = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化双向链表，将空闲页总数nr_free初始化为0。</p>
<p><strong>default_init_memmap：</strong></p>
<p>初始化一整个空闲物理内存块，将块内每一页对应的Page结构初始化，参数为基址和页数（因为相邻编号的页对应的Page结构在内存上是相邻的，所以可将第一个空闲物理页对应的Page结构地址作为基址，以基址+偏移量的方式访问所有空闲物理页的Page结构，<strong>根据指导书，这个空闲块链表正是将各个块首页的指针集合（由prev和next构成）的指针（或者说指针集合所在地址）相连，并以基址区分不同的连续内存物理块</strong>）。</p>
<p>根据注释，<strong>具体流程为</strong>：遍历块内所有空闲物理页的Page结构，将各个flags置为0以标记物理页帧有效，将property成员置零，使用 SetPageProperty宏置PG_Property标志位来标记各个页有效（具体而言，如果一页的该位为1，则对应页应是一个空闲块的块首页；若为0，则对应页要么是一个已分配块的块首页，要么不是块中首页；另一个标志位PG_Reserved在pmm_init函数里已被置位，这里用于确认对应页不是被OS内核占用的保留页，因而可用于用户程序的分配和回收），清空各物理页的引用计数ref；最后再将首页Page结构的property置为块内总页数，将全局总页数nr_free加上块内总页数，并用page_link这个双链表结点指针集合将块首页连接到空闲块链表里。</p>
<p>写出代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">default_init_memmap(struct Page *base, <span class="keyword">size_t</span> n) &#123;   </span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">base</span>;</span><span class="comment">//块基址</span></span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(PageReserved(p));<span class="comment">//确认本页不是给OS的保留页</span></span><br><span class="line">        p-&gt;flags = p-&gt;property = <span class="number">0</span>;</span><br><span class="line">        SetPageProperty(p);<span class="comment">//设置标志位</span></span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);<span class="comment">//清空引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    nr_free += n;<span class="comment">//增加全局总页数</span></span><br><span class="line">    base-&gt;property=n;<span class="comment">//本块首页的property设为n</span></span><br><span class="line">    list_add_before(&amp;free_list, &amp;(base-&gt;page_link));<span class="comment">//首页的指针集合插入空闲页链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>default_alloc_pages(size_t n)：</strong></p>
<p>该函数分配指定页数的连续空闲物理内存空间，返回分配的空间中第一页的Page结构的指针。</p>
<p>流程：从起始位置开始顺序搜索空闲块链表，找到第一个页数不小于所申请页数n的块（只需检查每个Page的property成员，在其值&gt;=n的第一个页停下），如果这个块的页数正好等于申请的页数，则可直接分配；如果块页数比申请的页数多，要将块分成两半，将起始地址较低的一半分配出去，将起始地址较高的一半作为链表内新的块，分配完成后重新计算块内空闲页数和全局空闲页数；若遍历整个空闲链表仍找不到足够大的块，则返回NULL表示分配失败。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *</span></span><br><span class="line"><span class="class"><span class="title">default_alloc_pages</span>(<span class="title">size_t</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">    assert(n&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;nr_free) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//如果所有空闲页的总数都不够，直接返回NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">	<span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list) &#123;</span><br><span class="line">   		<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">page_link</span>);</span><span class="comment">//链表内地址转换为Page结构指针</span></span><br><span class="line">    	<span class="keyword">if</span> (p-&gt;property &gt;= n) &#123;<span class="comment">//遇到第一个页数不小于n的块</span></span><br><span class="line">        	page = p;<span class="comment">//可得块首页</span></span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123; <span class="comment">//如果找到了满足条件的空闲内存块</span></span><br><span class="line">    	<span class="keyword">for</span> (struct Page *p = page; p != (page + n); ++p)</span><br><span class="line">        	ClearPageProperty(p); <span class="comment">//将分配出去的内存页标记为非空闲</span></span><br><span class="line">    	<span class="keyword">if</span> (page-&gt;property &gt; n) &#123; <span class="comment">/*如果原先找到的空闲块大小大于需要的分配内存大小，进行分裂*/</span>		  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">page</span> + <span class="title">n</span>;</span> <span class="comment">//分裂出来的新的小空闲块首页</span></span><br><span class="line">        	p-&gt;property = page-&gt;property - n; <span class="comment">//更新新的空闲块的大小信息</span></span><br><span class="line">        	list_add(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link)); <span class="comment">/*将新空闲块插入空闲块列表中*/</span>	&#125;</span><br><span class="line">    list_del(&amp;(page-&gt;page_link)); <span class="comment">//从链表里删除分配出去的空闲块</span></span><br><span class="line">    nr_free -= n; <span class="comment">//更新全局空闲页数</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>default_free_pages(struct Page *base, size_t n)：</strong></p>
<p>释放从指定的某一物理页开始的若干个被占用的连续物理页，将这些页连回空闲块链表，重置其中的标志信息，最后进行一些碎片整理性质的块合并操作。</p>
<p>首先根据参数提供的块基址，遍历链表找到待插入位置，插入这些页。然后将引用计数ref、flags标志位置位，最后<strong>调用merge_blocks函数迭代地进行块合并，以获取尽可能大的连续内存块</strong>。规则是从新插入的块开始，首先正序遍历链表，不断将链表内基址与新插入块物理地址较大一端相邻的空闲块合并到新插入块里（也是对应着分配内存块时将物理基址较大的块留在链表里）；然后反序遍历链表，不断将链表内的基址与新插入块物理地址较小一端相邻的空闲块合并到新插入块里。</p>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">default_free_pages(struct Page *base, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(!PageReserved(p) &amp;&amp; !PageProperty(p));<span class="comment">/*确认各个页状态是被OS占用的或是已分配的，如果释放了空闲的内存则产生异常*/</span></span><br><span class="line">        p-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        SetPageProperty(p);<span class="comment">//PG_Property重置为空闲状态</span></span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="comment">//先对块内各页进行标志信息重置</span></span><br><span class="line">    <span class="comment">//块首页的成员property重新赋值为n</span></span><br><span class="line">    base-&gt;property = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;free_list);<span class="comment">//以链表头部的下一个为起始结点，开始顺序搜索</span></span><br><span class="line">    <span class="keyword">while</span> (le != &amp;free_list &amp;&amp; le &lt; &amp;base-&gt;page_link) &#123;</span><br><span class="line">        le = list_next(le);</span><br><span class="line">    &#125;</span><br><span class="line">    list_add_before(&amp;free_list, &amp;(base-&gt;page_link));</span><br><span class="line">    nr_free += n;</span><br><span class="line">    <span class="keyword">while</span> (merge_block(base)); <span class="comment">/*块合并*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">list_entry_t</span> *i = list_prev(&amp;(base-&gt;page_link)); i!= &amp;free_list; i = list_prev(i)) &#123; <span class="comment">//再将新插入的空闲块和其物理地址小的一段的所有相邻的物理空闲块进行合并</span></span><br><span class="line">    <span class="keyword">if</span> (!merge_block(le2page(i, page_link))) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">merge_block(struct Page *base)&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(base-&gt;page_link)); <span class="comment">//获取链表中下一空闲块的地址</span></span><br><span class="line">    <span class="keyword">if</span> (le == &amp;free_list) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/*如果当前空闲块是物理地址最大的空闲块，则无法进行向后合并，返回合并失败*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">page_link</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (PageProperty(p) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//异常情况</span></span><br><span class="line">    <span class="keyword">if</span> (base + base-&gt;property != p) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果两空闲块不相邻，合并终止</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并操作</span></span><br><span class="line">    base-&gt;property += p-&gt;property;</span><br><span class="line">    p-&gt;property = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将合并前的物理地址较大的空闲块从链表中删去</span></span><br><span class="line">    list_del(le); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//返回合并成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="练习2：实现寻找虚拟地址对应的页表项-需要编程"><a href="#练习2：实现寻找虚拟地址对应的页表项-需要编程" class="headerlink" title="练习2：实现寻找虚拟地址对应的页表项(需要编程)"></a>练习2：实现寻找虚拟地址对应的页表项(需要编程)</h2><blockquote>
<p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。其中的 get_pte函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项 的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。本练习需要补全get_pte函数 in kern/mm/pmm.c，实现其功能。</p>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题： </p>
<ul>
<li>请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含 义和以及对ucore而言的潜在用处。</li>
<li>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</li>
</ul>
</blockquote>
<p>首先需要知道PDT(页目录表),PDE(页目录项),PTT(页表),PTE(页表项)之间的关系:页表保存页表项，页表项被映射到物理内存地址；页目录表保存页目录项，页目录项映射到页表。</p>
<h6 id="PDE和PTE的各部分含义及用途"><a href="#PDE和PTE的各部分含义及用途" class="headerlink" title="PDE和PTE的各部分含义及用途"></a>PDE和PTE的各部分含义及用途</h6><p>PDE和PTE都是4B大小的一个元素，其高20bit被用于保存索引，低12bit用于保存属性，但是由于用处不同，内部具有细小差异，如图所示：</p>
<p><img src="https://i.loli.net/2020/11/04/7DvHaPVIACfyjbN.png" alt="pde.png"></p>
<p><img src="https://i.loli.net/2020/11/04/Yqdz7hTnWtEBsSc.png" alt="pte.png"></p>
<table>
<thead>
<tr>
<th>bit</th>
<th>PDE</th>
<th>PTE</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Present位，0不存在，1存在下级页表</td>
<td>同</td>
</tr>
<tr>
<td>1</td>
<td>Read/Write位，0只读，1可写</td>
<td>同</td>
</tr>
<tr>
<td>2</td>
<td>User/Supervisor位，0则其下页表/物理页用户无法访问，1可以访问</td>
<td>同</td>
</tr>
<tr>
<td>3</td>
<td>Page level Write Through，1则开启页层次的写回机制，0不开启</td>
<td>同</td>
</tr>
<tr>
<td>4</td>
<td>Page level Cache Disable， 1则禁止页层次缓存，0不禁止</td>
<td>同</td>
</tr>
<tr>
<td>5</td>
<td>Accessed位，1代表在地址翻译过程中曾被访问，0没有</td>
<td>同</td>
</tr>
<tr>
<td>6</td>
<td>忽略</td>
<td>脏位，判断是否有写入</td>
</tr>
<tr>
<td>7</td>
<td>PS，当且仅当PS=1且CR4.PSE=1，页大小为4M，否则为4K</td>
<td>如果支持 PAT 分页，间接决定这项访问的页的内存类型，否则为0</td>
</tr>
<tr>
<td>8</td>
<td>忽略</td>
<td>Global 位。当 CR4.PGE 位为 1 时,该位为1则全局翻译</td>
</tr>
<tr>
<td>9</td>
<td>忽略</td>
<td>忽略</td>
</tr>
<tr>
<td>10</td>
<td>忽略</td>
<td>忽略</td>
</tr>
<tr>
<td>11</td>
<td>忽略</td>
<td>忽略</td>
</tr>
</tbody></table>
<h6 id="出现页访问异常时，硬件执行的工作"><a href="#出现页访问异常时，硬件执行的工作" class="headerlink" title="出现页访问异常时，硬件执行的工作"></a>出现页访问异常时，硬件执行的工作</h6><ul>
<li>首先需要将发生错误的线性地址la保存在CR2寄存器中<ul>
<li>这里说一下控制寄存器CR0-4的作用</li>
<li>CR0的0位是PE位，如果为1则启动保护模式，其余位也有自己的作用</li>
<li>CR1是未定义控制寄存器，留着以后用</li>
<li>CR2是<strong>页故障线性地址寄存器</strong>，保存最后一次出现页故障的全32位线性地址</li>
<li>CR3是<strong>页目录基址寄存器</strong>，保存PDT的物理地址</li>
<li>CR4在Pentium系列处理器中才实现，它处理的事务包括诸如何时启用虚拟8086模式等</li>
</ul>
</li>
<li>之后需要往中断时的栈中压入EFLAGS,CS,EIP,ERROR CODE，如果这页访问异常很不巧发生在用户态，还需要先压入SS,ESP并切换到内核态</li>
<li>最后根据IDT表查询到对应的也访问异常的ISR，跳转过去并将剩下的部分交给软件处理。</li>
</ul>
<h6 id="代码的实现"><a href="#代码的实现" class="headerlink" title="代码的实现"></a>代码的实现</h6><p>为了获取PTE，很自然需要先获取PDE，通过PDX(la)可以获得对应的PDE的索引，之后在pkdir中根据索引找到对应的PDE指针，写成代码即为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pde_t *pdep &#x3D; &amp;pgdir[PDX(la)];</span><br></pre></td></tr></table></figure>

<p>之后判断其Present位是否为1(若不为1则需要为其创建新的PTT)，在创建时如果失败(创建标志为0或者分配物理内存页失败)需要立即返回，对应代码为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(*pdep &amp; PTE_P))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">temPage</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!create || (temPage = alloc_page()) == <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配物理内存页之后，把这个物理页的引用的计数通过set_page_ref更新。</p>
<p>获取这个temPage的物理地址，然后把这个物理页全部初始化为0(需要用KADDR转换为内核虚拟地址)。到此完成了pte的设置，还需要更新pde中的几个标识位。对应代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_page_ref(temPage,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">uintptr_t</span> pa = page2pa(temPage);</span><br><span class="line"><span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE);</span><br><span class="line"><span class="comment">// pa的地址，用户级，可写，存在</span></span><br><span class="line">*pdep = pa | PTE_U | PTE_W | PTE_P;</span><br></pre></td></tr></table></figure>

<p>最后需要返回这个对应的PTE，而目前我们有的是一个pdep，存放着PTT的物理地址，根据PDE的结构，可以得出这样一个流程</p>
<ol>
<li>抹去低12位，只保留对应的PTT的起始基地址</li>
<li>用PTX(la)获得PTT对应的PTE的索引</li>
<li>用数组和对应的索引得到PTE并返回</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;((<span class="keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">get_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create) &#123;</span><br><span class="line">    <span class="comment">/* LAB2 EXERCISE 2: YOUR CODE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you need to visit a physical address, please use KADDR()</span></span><br><span class="line"><span class="comment">     * please read pmm.h for useful macros</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Maybe you want help comment, BELOW comments can help you finish the code</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   PDX(la) = the index of page directory entry of VIRTUAL ADDRESS la.</span></span><br><span class="line"><span class="comment">     *   KADDR(pa) : takes a physical address and returns the corresponding kernel virtual address.</span></span><br><span class="line"><span class="comment">     *   set_page_ref(page,1) : means the page be referenced by one time</span></span><br><span class="line"><span class="comment">     *   page2pa(page): get the physical address of memory which this (struct Page *) page  manages</span></span><br><span class="line"><span class="comment">     *   struct Page * alloc_page() : allocation a page</span></span><br><span class="line"><span class="comment">     *   memset(void *s, char c, size_t n) : sets the first n bytes of the memory area pointed by s</span></span><br><span class="line"><span class="comment">     *                                       to the specified value c.</span></span><br><span class="line"><span class="comment">     * DEFINEs:</span></span><br><span class="line"><span class="comment">     *   PTE_P           0x001                   // page table/directory entry flags bit : Present</span></span><br><span class="line"><span class="comment">     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable</span></span><br><span class="line"><span class="comment">     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = <span class="literal">NULL</span>;   <span class="comment">// (1) find page directory entry</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;              <span class="comment">// (2) check if entry is not present</span></span><br><span class="line">                          <span class="comment">// (3) check if creating is needed, then alloc page for page table</span></span><br><span class="line">                          <span class="comment">// CAUTION: this page is used for page table, not for common data page</span></span><br><span class="line">                          <span class="comment">// (4) set page reference</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = <span class="number">0</span>; <span class="comment">// (5) get linear address of page</span></span><br><span class="line">                          <span class="comment">// (6) clear page content using memset</span></span><br><span class="line">                          <span class="comment">// (7) set page directory entry's permission</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;          <span class="comment">// (8) return page table entry</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">pde_t</span> *pdep = &amp;pgdir[PDX(la)];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!(*pdep &amp; PTE_P))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">temPage</span>;</span></span><br><span class="line">		<span class="keyword">if</span>(!create || (temPage = alloc_page()) == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		set_page_ref(temPage,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">uintptr_t</span> pa = page2pa(temPage);</span><br><span class="line">		<span class="built_in">memset</span>(KADDR(pa),<span class="number">0</span>,PGSIZE);</span><br><span class="line">		*pdep = pa | PTE_U | PTE_W | PTE_P;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;((<span class="keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>la,PDX,PTX,PTE_ADDR,PDE_ADDR的定义可以在mmu.h下看到，具体内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A linear address 'la' has a three-part structure as follows:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +--------10------+-------10-------+---------12----------+</span></span><br><span class="line"><span class="comment">// | Page Directory |   Page Table   | Offset within Page  |</span></span><br><span class="line"><span class="comment">// |      Index     |     Index      |                     |</span></span><br><span class="line"><span class="comment">// +----------------+----------------+---------------------+</span></span><br><span class="line"><span class="comment">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span></span><br><span class="line"><span class="comment">//  \----------- PPN(la) -----------/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The PDX, PTX, PGOFF, and PPN macros decompose linear addresses as shown.</span></span><br><span class="line"><span class="comment">// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),</span></span><br><span class="line"><span class="comment">// use PGADDR(PDX(la), PTX(la), PGOFF(la)).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page directory index</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDX(la) ((((uintptr_t)(la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page table index</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTX(la) ((((uintptr_t)(la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// offset in page</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGOFF(la) (((uintptr_t)(la)) &amp; 0xFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// address in page table or page directory entry</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_ADDR(pte)   ((uintptr_t)(pte) &amp; ~0xFFF)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDE_ADDR(pde)   PTE_ADDR(pde)</span></span><br></pre></td></tr></table></figure>

<p>其高10位用作PDT的索引，中10位用作PTT的索引，末12位用作物理页偏移量</p>
<p>KADDR，page2pa可以在pmm.h中看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * KADDR - takes a physical address and returns the corresponding kernel virtual</span></span><br><span class="line"><span class="comment"> * address. It panics if you pass an invalid physical address.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KADDR(pa) (&#123;                                                    \</span></span><br><span class="line">            <span class="keyword">uintptr_t</span> __m_pa = (pa);                                    \</span><br><span class="line">            <span class="keyword">size_t</span> __m_ppn = PPN(__m_pa);                               \</span><br><span class="line">            <span class="keyword">if</span> (__m_ppn &gt;= npage) &#123;                                     \</span><br><span class="line">                panic(<span class="string">"KADDR called with invalid pa %08lx"</span>, __m_pa);    \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">            (<span class="keyword">void</span> *) (__m_pa + KERNBASE);                               \</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">ppn_t</span></span><br><span class="line">page2ppn(struct Page *page) &#123;</span><br><span class="line">    <span class="keyword">return</span> page - pages;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PGSHIFT = log2(PGSIZE) = 12</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span></span><br><span class="line">page2pa(struct Page *page) &#123;</span><br><span class="line">    <span class="keyword">return</span> page2ppn(page) &lt;&lt; PGSHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h5><p>PDE,PDT,PTT,PTE真的很容易让人弄混，而且他们的发音真的很像，一不留神就弄混了。搞清楚关系和结构看一下注释就能很快地搞定。</p>
<h2 id="练习3：释放某虚地址所在的页并取消对应二级页表项的映射-需要编程"><a href="#练习3：释放某虚地址所在的页并取消对应二级页表项的映射-需要编程" class="headerlink" title="练习3：释放某虚地址所在的页并取消对应二级页表项的映射(需要编程)"></a>练习3：释放某虚地址所在的页并取消对应二级页表项的映射(需要编程)</h2><blockquote>
<p>当释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构Page做相关的清除处理，使得此物理内存页成为空闲；另外还需把表示虚地址与物理地址对应关系的二级页表项清除。请仔细查看和理解page_remove_pte函数中的注释。为此，需要补全在 kern/mm/pmm.c中的page_remove_pte函数。</p>
<p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p>
<ul>
<li>数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</li>
<li>如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题</li>
</ul>
</blockquote>
<h5 id="关于代码："><a href="#关于代码：" class="headerlink" title="关于代码："></a>关于代码：</h5><p>练习3可以看成是练习2的简单的逆过程，在理解了练习2的基础上，释放虚地址所在的页和取消对应二级页表项的映射可以大概分为如下步骤：</p>
<ol>
<li>通过PTE_P判断该ptep是否存在；</li>
<li>判断Page的ref的值是否为0，若为0，则说明此时没有任何逻辑地址被映射到此物理地址，换句话说当前物理页已没人使用，因此调用free_page函数回收此物理页，使得该物理页空闲；若不为0，则说明此时仍有至少一个逻辑地址被映射到此物理地址，因此不需回收此物理页；</li>
<li>把表示虚地址与物理地址对应关系的二级页表项清除；</li>
<li>更新TLB；</li>
</ol>
<p>根据Lab2中的代码提示，我们将MACROs 和 DEFINES拿出进行理解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *</span></span><br><span class="line"><span class="class"><span class="title">pte2page</span>(<span class="title">pte_t</span> <span class="title">pte</span>) &#123;</span><span class="comment">//从ptep值中获取相应的页面</span></span><br><span class="line">    <span class="keyword">if</span> (!(pte &amp; PTE_P)) &#123;</span><br><span class="line">        panic(<span class="string">"pte2page called with invalid pte"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pa2page(PTE_ADDR(pte));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减少该页的引用次数，返回剩下的引用次数。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span>  </span><br><span class="line">page_ref_dec(struct Page *page) &#123;</span><br><span class="line">    page-&gt;ref -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> page-&gt;ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当修改的页表目前正在被进程使用时，使之无效。</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">tlb_invalidate(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rcr3() == PADDR(pgdir)) &#123;</span><br><span class="line">        invlpg((<span class="keyword">void</span> *)la);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_P           0x001                   <span class="comment">// Present，即最低位为1；</span></span></span><br></pre></td></tr></table></figure>

<p>在此基础之上，我们给出完整的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">page_remove_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// 如果对应的二级页表项存在，如果*ptep存在，则其与PTE_P相与，得到的是1；</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">pte2page</span>(*<span class="title">ptep</span>);</span>  <span class="comment">// 获得*ptep对应的Page结构</span></span><br><span class="line">        <span class="comment">// 关联的page引用数自减1，page_ref_dec的返回值是现在的page-&gt;ref</span></span><br><span class="line">       <span class="keyword">if</span>(page_ref_dec(page) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果自减1后，引用数为0，需要free释放掉该物理页</span></span><br><span class="line">            free_page(page);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把表示虚地址与物理地址对应关系的二级页表项清除(通过把整体设置为0)</span></span><br><span class="line">        *ptep = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 由于页表项发生了改变，需要使TLB快表无效</span></span><br><span class="line">        tlb_invalidate(pgdir, la);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关于问题："><a href="#关于问题：" class="headerlink" title="关于问题："></a>关于问题：</h5><p>Q1：数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</p>
<p>A：所有的物理页都有一个描述它的Page结构，所有的页表都是通过alloc_page()分配的，每个页表项都存放在一个Page结构描述的物理页中；如果 PTE 指向某物理页，同时也有一个Page结构描述这个物理页。所以有两种对应关系：</p>
<p>(1)可以通过 PTE 的地址计算其所在的页表的Page结构：</p>
<p> 将虚拟地址向下对齐到页大小，换算成物理地址(减 KERNBASE), 再将其右移 PGSHIFT(12)位获得在pages数组中的索引PPN，&amp;pages[PPN]就是所求的Page结构地址。</p>
<p>(2)可以通过 PTE 指向的物理地址计算出该物理页对应的Page结构：</p>
<p>PTE 按位与 0xFFF获得其指向页的物理地址，再右移 PGSHIFT(12)位获得在pages数组中的索引PPN，&amp;pages[PPN]就 PTE 指向的地址对应的Page结构。</p>
<p>Q2：如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题。</p>
<p>A：此时虚拟地址和物理地址的映射关系是：phy addr + KERNBASE = virtual addr</p>
<p>所以如果想让虚拟地址=物理地址，则只要让KERNBASE = 0，因此去修改memlayout.h的宏定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNBASE            0xC0000000</span></span><br></pre></td></tr></table></figure>




<h2 id="Challenge1：buddy-system-伙伴系统-分配算法-需要编程"><a href="#Challenge1：buddy-system-伙伴系统-分配算法-需要编程" class="headerlink" title="Challenge1：buddy system(伙伴系统)分配算法(需要编程)"></a>Challenge1：buddy system(伙伴系统)分配算法(需要编程)</h2><blockquote>
<p>Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的 大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128… </p>
<ul>
<li>参考伙伴分配器的一个极简实现， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。</li>
</ul>
</blockquote>
<p>   Buddy system是一种连续物理内存的分配算法，主要应用二叉树来完成内存的分配；可以用来替换exe1中的first-fit算法。</p>
<p>网上对buddy system的算法定义如下：</p>
<p><strong>分配内存：</strong></p>
<p>1.寻找大小合适的内存块（大于等于所需大小并且最接近2的幂，比如需要27，实际分配32）</p>
<p>​    1.1 如果找到了，分配给应用程序。<br>​    1.2 如果没找到，分出合适的内存块。</p>
<p>​       1.2.1 对半分离出高于所需大小的空闲内存块<br>​       1.2.2 如果分到最低限度，分配这个大小。<br>​       1.2.3 回溯到步骤1（寻找合适大小的块）<br>​       1.2.4 重复该步骤直到一个合适的块</p>
<p><strong>释放内存：</strong></p>
<p>1.释放该内存块</p>
<p>   1.1 寻找相邻的块，看其是否释放了。<br>   1.2 如果相邻块也释放了，合并这两个块，重复上述步骤直到遇上未释放的相邻块，或者达到最高上限（即所有内存都释放了）。</p>
<p>​        在此定义之下，我们使用数组分配器来模拟构建这样完全二叉树结构而不是真的用指针建立树结构——树结构中向上或向下的指针索引都通过数组分配器里面的下标偏移来实现。在这个“完全二叉树”结构中，二叉树的节点用于标记相应内存块的使用状态，高层节点对应大的块，低层节点对应小的块，在分配和释放中我们就通过这些节点的标记属性来进行块的分离合并。</p>
<p>​        在分配阶段，首先要搜索大小适配的块——这个块所表示的内存大小刚好大于等于最接近所需内存的2次幂；通过对树深度遍历，从左右子树里面找到最合适的，将内存分配。</p>
<p>​        在释放阶段，我们将之前分配出去的内存占有情况还原，并考察能否和同一父节点下的另一节点合并，而后递归合并，直至不能合并为止。</p>
<p><img src="https://i.loli.net/2020/11/11/rVJYyaZokCqDPT1.png" alt="image-20201110000901267.png"></p>
<p>​       基于上面的理论准备，我们可以开始写代码了。因为buddy system替代的是之前的first fit算法，所以可以仿照default_pmm的格式来写。</p>
<p>​       首先，编写buddy.h（仿照default_pmm.h），唯一修改的地方是引入的pmm_manager不一样，要改成buddy system所使用的buddy_pmm_manager</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __KERN_MM_BUDDY_PMM_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  __KERN_MM_BUDDY_PMM_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pmm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> <span class="title">buddy_pmm_manager</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ! __KERN_MM_DEFAULT_PMM_H__ */</span></span></span><br></pre></td></tr></table></figure>

<p>​        而后，进入buddy.c文件</p>
<ol>
<li><p>因为这里使用数组来表示二叉树结构，所以需要建立正确的索引机制：每level的第一左子树的下标为2^level-1，所以如果我们得到[index]节点的所在level，那么offset的计算可以归结为(index-2^level+1) * node_size = (index+1)<em>node_size – node_size</em>2^level。其中size的计算为2^(max_depth-level)，所以node_size * 2^level = 2^max_depth = size。综上所述，可得公式offset=(index+1)*node_size – size。<br>PS：式中索引的下标均从0开始，size为内存总大小，node_size为内存块对应大小。</p>
<p>由上，完成宏定义。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT_LEAF(index) ((index) * 2 + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT_LEAF(index) ((index) * 2 + 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARENT(index) ( ((index) + 1) / 2 - 1)</span></span><br></pre></td></tr></table></figure>

<pre><code>2.  因为buddy system的块大小都是2的倍数，所以我们对于输入的所需的块大小，要先计算出最接近于它的2的倍数的值以匹配buddy system的最合适块的查找。</code></pre><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="title">fixsize</span><span class="params">(<span class="keyword">unsigned</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">size</span> |= <span class="built_in">size</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">size</span> |= <span class="built_in">size</span> &gt;&gt; <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">size</span> |= <span class="built_in">size</span> &gt;&gt; <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">size</span> |= <span class="built_in">size</span> &gt;&gt; <span class="number">8</span>;</span><br><span class="line">  <span class="built_in">size</span> |= <span class="built_in">size</span> &gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">size</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>构造buddy system最基本的数据结构，并初始化一个用来存放二叉树的数组。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buddy</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="built_in">size</span>;<span class="comment">//表明管理内存</span></span><br><span class="line">  <span class="keyword">unsigned</span> longest; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buddy</span> <span class="title">root</span>[10000];</span><span class="comment">//存放二叉树的数组，用于内存分配</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>buddy system是需要和实际指向空闲块双链表配合使用的，所以需要先各自初始化数组和指向空闲块的双链表。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先初始化双链表</span></span><br><span class="line"><span class="keyword">free_area_t</span> free_area;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free_list (free_area.free_list)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nr_free (free_area.nr_free)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buddy_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list_init(&amp;free_list);</span><br><span class="line">    nr_free=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再初始化buddy system的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buddy_new</span><span class="params">( <span class="keyword">int</span> <span class="built_in">size</span> )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> node_size;    <span class="comment">//传入的size是这个buddy system表示的总空闲空间；node_size是对应节点所表示的空闲空间的块数</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  nr_block=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">1</span> || !IS_POWER_OF_2(<span class="built_in">size</span>))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  root[<span class="number">0</span>].<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">  node_size = <span class="built_in">size</span> * <span class="number">2</span>;   <span class="comment">//认为总结点数是size*2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span> * <span class="built_in">size</span> - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (IS_POWER_OF_2(i+<span class="number">1</span>))    <span class="comment">//如果i+1是2的倍数，那么该节点所表示的二叉树就要到下一层了</span></span><br><span class="line">      node_size /= <span class="number">2</span>;</span><br><span class="line">    root[i].longest = node_size;   <span class="comment">//longest是该节点所表示的初始空闲空间块数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>根据pmm.h里面对于pmm_manager的统一结构化定义，我们需要对buddy system完成如下函数：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> <span class="title">buddy_pmm_manager</span> = &#123;</span></span><br><span class="line">    .name = <span class="string">"buddy_pmm_manager"</span>,      <span class="comment">// 管理器的名称</span></span><br><span class="line">    .init = buddy_init,               <span class="comment">// 初始化管理器</span></span><br><span class="line">    .init_memmap = buddy_init_memmap, <span class="comment">// 设置可管理的内存,初始化可分配的物理内存空间</span></span><br><span class="line">    .alloc_pages = buddy_alloc_pages, <span class="comment">// 分配&gt;=N个连续物理页,返回分配块首地址指针 </span></span><br><span class="line">    .free_pages = buddy_free_pages,   <span class="comment">// 释放包括自Base基址在内的，起始的&gt;=N个连续物理内存页</span></span><br><span class="line">    .nr_free_pages = buddy_nr_free_pages, <span class="comment">// 返回全局的空闲物理页数量</span></span><br><span class="line">    .check = buddy_check,             <span class="comment">//举例检测这个pmm_manager的正确性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    5.1 初始化管理器（这个已在上面完成）</p>
<p>​    5.2 初始化可管理的物理内存空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">buddy_init_memmap(struct Page *base, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    assert(n&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">p</span>=<span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(;p!=base + n;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(PageReserved(p));</span><br><span class="line">        p-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        p-&gt;property = <span class="number">1</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);    <span class="comment">//表明空闲可用</span></span><br><span class="line">        SetPageProperty(p);</span><br><span class="line">        list_add_before(&amp;free_list,&amp;(p-&gt;page_link));     <span class="comment">//向双链表中加入页的管理部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    nr_free += n;     <span class="comment">//表示总共可用的空闲页数</span></span><br><span class="line">    <span class="keyword">int</span> allocpages=UINT32_ROUND_DOWN(n);</span><br><span class="line">    buddy2_new(allocpages);    <span class="comment">//传入所需要表示的总内存页大小，让buddy system的数组得以初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    5.3 分配所需的物理页，返回分配块首地址指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配的逻辑是：首先在buddy的“二叉树”结构中找到应该分配的物理页在整个实际双向链表中的位置，而后把相应的page进行标识表明该物理页已经分出去了。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>*</span></span><br><span class="line"><span class="class"><span class="title">buddy_alloc_pages</span>(<span class="title">size_t</span> <span class="title">n</span>)&#123;</span></span><br><span class="line">  assert(n&gt;<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(n&gt;nr_free)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span>=<span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">list_entry_t</span> *le=&amp;free_list,*len;</span><br><span class="line">  rec[nr_block].offset=buddy2_alloc(root,n);<span class="comment">//记录偏移量</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;rec[nr_block].offset+<span class="number">1</span>;i++)</span><br><span class="line">    le=list_next(le);</span><br><span class="line">  page=le2page(le,page_link);</span><br><span class="line">  <span class="keyword">int</span> allocpages;</span><br><span class="line">  <span class="keyword">if</span>(!IS_POWER_OF_2(n))</span><br><span class="line">   allocpages=fixsize(n);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">     allocpages=n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据需求n得到块大小</span></span><br><span class="line">  rec[nr_block].base=page;<span class="comment">//记录分配块首页</span></span><br><span class="line">  rec[nr_block].nr=allocpages;<span class="comment">//记录分配的页数</span></span><br><span class="line">  nr_block++;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;allocpages;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    len=list_next(le);</span><br><span class="line">    p=le2page(le,page_link);</span><br><span class="line">    ClearPageProperty(p);</span><br><span class="line">    le=len;</span><br><span class="line">  &#125;<span class="comment">//修改每一页的状态</span></span><br><span class="line">  nr_free-=allocpages;<span class="comment">//减去已被分配的页数</span></span><br><span class="line">  page-&gt;property=n;</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是在上面的分配物理内存函数中用到的结构和辅助函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">allocRecord</span>//记录分配块的信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">base</span>;</span></span><br><span class="line">  <span class="keyword">int</span> offset;</span><br><span class="line">  <span class="keyword">size_t</span> nr;<span class="comment">//块大小，即包含了多少页</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">allocRecord</span> <span class="title">rec</span>[80000];</span><span class="comment">//存放偏移量的数组</span></span><br><span class="line"><span class="keyword">int</span> nr_block;<span class="comment">//已分配的块数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buddy2_alloc</span><span class="params">(struct buddy2* self, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123; <span class="comment">//size就是这次要分配的物理页大小</span></span><br><span class="line">  <span class="keyword">unsigned</span> index = <span class="number">0</span>;  <span class="comment">//节点的标号</span></span><br><span class="line">  <span class="keyword">unsigned</span> node_size;  <span class="comment">//用于后续循环寻找合适的节点</span></span><br><span class="line">  <span class="keyword">unsigned</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self==<span class="literal">NULL</span>)<span class="comment">//无法分配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= <span class="number">0</span>)<span class="comment">//分配不合理</span></span><br><span class="line">    <span class="built_in">size</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!IS_POWER_OF_2(<span class="built_in">size</span>))<span class="comment">//不为2的幂时，取比size更大的2的n次幂</span></span><br><span class="line">    <span class="built_in">size</span> = fixsize(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self[index].longest &lt; <span class="built_in">size</span>)<span class="comment">//根据根节点的longest，发现可分配内存不足，也返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从根节点开始，向下寻找左右子树里面找到最合适的节点</span></span><br><span class="line">  <span class="keyword">for</span>(node_size = self-&gt;<span class="built_in">size</span>; node_size != <span class="built_in">size</span>; node_size /= <span class="number">2</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self[LEFT_LEAF(index)].longest &gt;= <span class="built_in">size</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(self[RIGHT_LEAF(index)].longest&gt;=<span class="built_in">size</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           index=self[LEFT_LEAF(index)].longest &lt;= self[RIGHT_LEAF(index)].longest? LEFT_LEAF(index):RIGHT_LEAF(index);</span><br><span class="line">         <span class="comment">//找到两个相符合的节点中内存较小的结点</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         index=LEFT_LEAF(index);</span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      index = RIGHT_LEAF(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self[index].longest = <span class="number">0</span>;<span class="comment">//标记节点为已使用</span></span><br><span class="line">  offset = (index + <span class="number">1</span>) * node_size - self-&gt;<span class="built_in">size</span>;  <span class="comment">//offset得到的是该物理页在双向链表中距离“根节点”的偏移</span></span><br><span class="line">  <span class="comment">//这个节点被标记使用后，要层层向上回溯，改变父节点的longest值</span></span><br><span class="line">  <span class="keyword">while</span> (index) &#123;</span><br><span class="line">    index = PARENT(index);</span><br><span class="line">    self[index].longest = </span><br><span class="line">      MAX(self[LEFT_LEAF(index)].longest, self[RIGHT_LEAF(index)].longest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   5.4 释放指定的内存页大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buddy_free_pages</span><span class="params">(struct Page* base, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> node_size, index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> left_longest, right_longest;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buddy2</span>* <span class="title">self</span>=<span class="title">root</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">list_entry_t</span> *le=list_next(&amp;free_list);</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nr_block;i++)  <span class="comment">//nr_block是已分配的块数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(rec[i].base==base)  </span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> offset=rec[i].offset;</span><br><span class="line">  <span class="keyword">int</span> pos=i;<span class="comment">//暂存i</span></span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;offset)</span><br><span class="line">  &#123;</span><br><span class="line">    le=list_next(le);</span><br><span class="line">    i++;     <span class="comment">//根据该分配块的记录信息，可以找到双链表中对应的page</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> allocpages;</span><br><span class="line">  <span class="keyword">if</span>(!IS_POWER_OF_2(n))</span><br><span class="line">   allocpages=fixsize(n);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">     allocpages=n;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(self &amp;&amp; offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; self-&gt;<span class="built_in">size</span>);<span class="comment">//是否合法</span></span><br><span class="line">  nr_free+=allocpages;<span class="comment">//更新空闲页的数量</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;allocpages;i++)<span class="comment">//回收已分配的页</span></span><br><span class="line">  &#123;</span><br><span class="line">     p=le2page(le,page_link);</span><br><span class="line">     p-&gt;flags=<span class="number">0</span>;</span><br><span class="line">     p-&gt;property=<span class="number">1</span>;</span><br><span class="line">     SetPageProperty(p);</span><br><span class="line">     le=list_next(le);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//实际的双链表信息复原后，还要对“二叉树”里面的节点信息进行更新</span></span><br><span class="line">  node_size = <span class="number">1</span>;</span><br><span class="line">  index = offset + self-&gt;<span class="built_in">size</span> - <span class="number">1</span>;   <span class="comment">//从原始的分配节点的最底节点开始改变longest</span></span><br><span class="line">  self[index].longest = node_size;   <span class="comment">//这里应该是node_size，也就是从1那层开始改变</span></span><br><span class="line">  <span class="keyword">while</span> (index) &#123;<span class="comment">//向上合并，修改父节点的记录值</span></span><br><span class="line">    index = PARENT(index);</span><br><span class="line">    node_size *= <span class="number">2</span>;</span><br><span class="line">    left_longest = self[LEFT_LEAF(index)].longest;</span><br><span class="line">    right_longest = self[RIGHT_LEAF(index)].longest;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left_longest + right_longest == node_size) </span><br><span class="line">      self[index].longest = node_size;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      self[index].longest = MAX(left_longest, right_longest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i=pos;i&lt;nr_block<span class="number">-1</span>;i++)<span class="comment">//清除此次的分配记录，即从分配数组里面把后面的数据往前挪</span></span><br><span class="line">  &#123;</span><br><span class="line">    rec[i]=rec[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  nr_block--;<span class="comment">//更新分配块数的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   5.5 返回全局的空闲物理页数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">buddy_nr_free_pages(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nr_free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    5.6 检查这个pmm_manager是否正确</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是一个测试函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">buddy_check(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>  *<span class="title">A</span>, *<span class="title">B</span>;</span></span><br><span class="line">    A = B  =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    assert((A = alloc_page()) != <span class="literal">NULL</span>);</span><br><span class="line">    assert((B = alloc_page()) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    assert( A != B);</span><br><span class="line">    assert(page_ref(A) == <span class="number">0</span> &amp;&amp; page_ref(B) == <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//free page就是free pages(p0,1)</span></span><br><span class="line">    free_page(A);</span><br><span class="line">    free_page(B);</span><br><span class="line">    </span><br><span class="line">    A=alloc_pages(<span class="number">500</span>);     <span class="comment">//alloc_pages返回的是开始分配的那一页的地址</span></span><br><span class="line">    B=alloc_pages(<span class="number">500</span>);</span><br><span class="line">    cprintf(<span class="string">"A %p\n"</span>,A);</span><br><span class="line">    cprintf(<span class="string">"B %p\n"</span>,B);</span><br><span class="line">    free_pages(A,<span class="number">250</span>);     <span class="comment">//free_pages没有返回值</span></span><br><span class="line">    free_pages(B,<span class="number">500</span>);</span><br><span class="line">    free_pages(A+<span class="number">250</span>,<span class="number">250</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Challenge2：任意大小的内存单元slub分配算法-需要编程"><a href="#Challenge2：任意大小的内存单元slub分配算法-需要编程" class="headerlink" title="Challenge2：任意大小的内存单元slub分配算法(需要编程)"></a>Challenge2：任意大小的内存单元slub分配算法(需要编程)</h2><blockquote>
<p>slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在 第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。 </p>
<ul>
<li>参考linux的slub分配算法/，在ucore中实现slub分配算法。要求有比较充分的测试用例说 明实现的正确性，需要有设计文档。</li>
</ul>
</blockquote>
<p>上一个challenge中的buddy system像是一个批发商，按页批发大量的内存。但是很多时候你买东西并不需要去批发，而是去零售。零售商就是我们的slub分配算法。slub运行在buddy system之上，为内核（客户）提供小内存的管理功能。</p>
<p>slub算法将内存分组管理，每个组分别为2^3^,2^4^,2^5^,…,2^11^B和两个特殊组96B和192B。为什么这么分，因为我们的页大小默认为4KB=2^12^B，也就是说如果我们需要大于等于2^12^B的内存，就用buddy system批发，而需要小内存的时候就用slub来分配就行。</p>
<p>我们可以用一个kmem_cache数组 kmalloc_caches[12]来存放上面的12个组，可以把kmem_cache想象为12个零售商，每个零售商只卖一种东西。零售商有自己的仓库和自己的店面，店面里只有一个slab，如果slab卖完了再从仓库中换出其他的slab。</p>
<p>在slub的使用过程中有如下几种情况</p>
<ol>
<li><p>刚刚创建slub系统，第一次申请空间</p>
<p>此时slub刚刚建立起来，不管是仓库还是店面都没有slab，这个时候首先需要从buddy system中申请空闲的内存页，然后把这些内存页slub划分为很多的零售品object，选择一个摆在商店中，剩下的放在仓库里。然后把商品中分一个给顾客</p>
</li>
<li><p>商店里有可用的object</p>
<p>这个时候就直接给呗，还能不给的咯</p>
</li>
<li><p>商店没东西，仓库有</p>
<p>从仓库里换出一个新的空的slub，并分一个空闲object给顾客</p>
</li>
<li><p>商店和仓库都没有了</p>
<p>这个时候只能重新批发新的slub回来，重复1</p>
</li>
</ol>
<p>至于其他的嘛…</p>
<p><img src="https://i.loli.net/2020/11/13/pYGHkwqbLjKsQWr.jpg" alt="1.jpg"></p>
<p>我是真的不会了，写了400多行bug的挫败感确实有点大，等过段时间把手上的活忙完了再写。</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Ucore-lab1</title>
    <url>/2020/11/13/Ucore-lab1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Ucore-lab1学习记录"><a href="#Ucore-lab1学习记录" class="headerlink" title="Ucore-lab1学习记录"></a>Ucore-lab1学习记录</h1><blockquote>
<p>本文记录了清华大学操作系统使用的Ucore实验的lab1的报告</p>
<p>由我，YYF同学及LZQ同学共同完成，感谢二位大佬的指教和帮助</p>
<p>仅供学习交流使用，未经许可不得转载，抄袭。</p>
</blockquote>
<a id="more"></a>

<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>在解压后的ucroe源码包中使用make命令即可以生成所需的目标文件,例如在本次实验中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user@system:~..&#x2F;lab1$ make</span><br></pre></td></tr></table></figure>

<p>之后就会生成一系列的目标文件：</p>
<ul>
<li>user.img : 被qemu访问的虚拟硬盘文件</li>
<li>kernel : ELF格式的toy ucore kernel执行文，嵌入到了ucore.img中</li>
<li>bootblock : 虚拟的硬盘主引导扇区(512字节)，包含了bootloader执行代码，同样嵌入了</li>
<li>sign : 外部执行程序，用来生成虚拟的硬盘主引导扇区</li>
</ul>
<p>还有其他文件，不一一列举。</p>
<p>如果要对修改后的ucore代码和ucore 源码进行比较，可以使用diff命令。</p>
<p><img src="https://i.loli.net/2020/10/03/XrvLV18xysfHM3e.png" alt="01.1.png"></p>
<h2 id="练习1：理解通过make生成执行文件的过程"><a href="#练习1：理解通过make生成执行文件的过程" class="headerlink" title="练习1：理解通过make生成执行文件的过程"></a>练习1：理解通过make生成执行文件的过程</h2><p>列出本实验各练习中对应的OS原理的知识点，并说明本实验中的实现部分如何对应和体现了原理中的基本概念和关键知识点</p>
<p>在此练习中，大家需要通过静态分析代码来了解：</p>
<ol>
<li>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</li>
<li>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么。</li>
</ol>
<h6 id="操作系统镜像文件ucore-img是如何一步一步生成的？"><a href="#操作系统镜像文件ucore-img是如何一步一步生成的？" class="headerlink" title="操作系统镜像文件ucore.img是如何一步一步生成的？"></a>操作系统镜像文件ucore.img是如何一步一步生成的？</h6><p>通过使用以下命令，可以得到Makefile中具体执行的所有命令，之后就可以对每一条命令进行分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make &quot;V&#x3D;&quot;</span><br></pre></td></tr></table></figure>

<p>通过这个命令会弹出来一长串信息，这个我们先不看，还是先从makefile文件入手。打开makefile文件，一下子看到一堆代码也是挺烦人的，不过可以发现里面写了注释。既然有注释，就好办多了，我们知道通过这个命令可以生成一个ucore.img文件，那我们就从ucore.img倒推回去，阅读注释，可以看到以下代码。</p>
<p><img src="https://i.loli.net/2020/10/03/Wv6GrdoKfsNgXUi.png" alt="01.3.png"></p>
<p>即使我们不懂makefile的语法规则，我们也很容易知道要生成这个ucore.img需要kernel和bootblock两个文件，那就再分别从这两个文件往上追溯。</p>
<p>我们先从bootblock来看，bootblock需要生成bootasm.o,bootmain.o以及sign等文件</p>
<p><img src="https://i.loli.net/2020/10/03/vYUrM3f8yLHeDTP.png" alt="01.4.png"></p>
<p>其中bootasm.o由bootasm.S生成，bootmain.o由bootmain.c生成，生成代码为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -Iboot&#x2F; -march&#x3D;i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs&#x2F; -Os -nostdinc -c boot&#x2F;bootasm.S -o obj&#x2F;boot&#x2F;bootasm.o</span><br><span class="line"></span><br><span class="line">gcc -Iboot&#x2F; -march&#x3D;i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs&#x2F; -Os -nostdinc -c boot&#x2F;bootmain.c -o obj&#x2F;boot&#x2F;bootmain.o</span><br></pre></td></tr></table></figure>

<p>解释一下其中出现的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-fno-builtin	# 不承认不以__builtin_开头的函数为内建函数</span><br><span class="line">-fno-PIC	# 产生与位置无关代码，即没有绝对地址，使代码可以被任意加载</span><br><span class="line">-Wall	# 在编译后显示所有警告</span><br><span class="line">-ggdb	# 生成专门用于gdb的调试信息</span><br><span class="line">-m32	# 生成32位机器的汇编代码</span><br><span class="line">-gstabs	# 以stabs格式生成调试信息</span><br><span class="line">-nostdinc	# 不在标准系统文件夹中寻找头文件，只在-I中指定的文件夹搜索头文件</span><br><span class="line">-I	# 添加搜索头文件的路径并且会被优先查找	</span><br><span class="line">-Os	# 优化代码，减小大小</span><br><span class="line">-c	# 把程序做成obj文件，就是.o</span><br><span class="line">-o	# 制定目标名称</span><br><span class="line">-fno-stack-protector	# 不生成用于检测缓冲区溢出的代码</span><br></pre></td></tr></table></figure>

<p>生成sign的代码如下，编写在makefile文件中</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create 'sign' tools</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_host,tools/sign.c,sign,sign)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target_host,sign,sign)</span></span><br></pre></td></tr></table></figure>

<p>对应的命令是，因为没有新的参数，就不进行详细解释。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -Itools&#x2F; -g -Wall -O2 -c tools&#x2F;sign.c -o obj&#x2F;sign&#x2F;tools&#x2F;sign.o</span><br><span class="line">gcc -g -Wall -O2 obj&#x2F;sign&#x2F;tools&#x2F;sign.o -o bin&#x2F;sign</span><br></pre></td></tr></table></figure>

<p>整个的bootblock的生成过程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成bootblock.o</span><br><span class="line"># 新参数 -m:模拟为i386上的链接器，-N:设置代码段和数据段可读可写，-e:指定入口，-Ttext:设置代码开始位置</span><br><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj&#x2F;boot&#x2F;bootasm.o obj&#x2F;boot&#x2F;bootmain.o -o obj&#x2F;bootblock.o</span><br><span class="line"></span><br><span class="line"># 将bootblock.o拷贝到bootblock.out</span><br><span class="line"># 新参数 -S:移除所有符号和重定位信息，-O:指定输出格式</span><br><span class="line">objcopy -S -O binary obj&#x2F;bootblock.o obj&#x2F;bootblock.out</span><br><span class="line"></span><br><span class="line"># 使用sign处理bootblock.out生成bootblock</span><br><span class="line">bin&#x2F;sign obj&#x2F;bootblock bin&#x2F;bootblock</span><br></pre></td></tr></table></figure>

<p>再看kernel的相关代码如下：</p>
<p><img src="https://i.loli.net/2020/10/03/n2aSNwoIEqie5jA.png" alt="01.5.png"></p>
<p>注意到KSRCDIR这一部分的内容实际上是用给定目录的方式进行对.c文件的添加，在被执行的时候就会在这些目录中选择没使用过的.c文件来编译成.o文件。之后kernel对这些所有的.o文件进行一个链接。</p>
<p>生成完kernel和bootblock之后，就该生成ucore.img了。由上面的生成代码即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成一个有10000块的ucore.img文件，每个块默认大小为512字节</span><br><span class="line">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;bin&#x2F;ucore.img count&#x3D;10000</span><br><span class="line"># 把bootblock添加到ucore.img的第一个块之中</span><br><span class="line">dd if&#x3D;bin&#x2F;bootblock of&#x3D;bin&#x2F;ucore.img conv&#x3D;notrunc</span><br><span class="line"># 把kernel写到ucore.img的其它块中</span><br><span class="line">dd if&#x3D;bin&#x2F;kernel of&#x3D;bin&#x2F;ucore.img seek&#x3D;1 conv&#x3D;notrunc</span><br><span class="line"># 其中几个关键参数的意义</span><br><span class="line">if:输入文件，不指定从stdin中读取</span><br><span class="line">of:输出文件，不指定从stdout中读取</span><br><span class="line">&#x2F;dev&#x2F;zero:不断返回的0值</span><br><span class="line">count:块数</span><br><span class="line">conv &#x3D; notrunc:输出不截断</span><br><span class="line">seek &#x3D; num:从输出文件开头跳过num个块</span><br></pre></td></tr></table></figure>

<p>这样我们就知道了整个ucore.img是如何从无到有的。</p>
<h6 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h6><p>主引导扇区就是我们的bootblock被加载到的区域，而和生成bootblock有关的代码就是sign.c。查看这个文件得到如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: &lt;input filename&gt; &lt;output filename&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error opening file '%s': %s\n"</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"'%s' size: %lld bytes\n"</span>, argv[<span class="number">1</span>], (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%lld &gt;&gt; 510!!\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    FILE *ifp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = fread(buf, <span class="number">1</span>, st.st_size, ifp);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != st.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read '%s' error, size is %d.\n"</span>, argv[<span class="number">1</span>], <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    buf[<span class="number">510</span>] = <span class="number">0x55</span>;</span><br><span class="line">    buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br><span class="line">    FILE *ofp = fopen(argv[<span class="number">2</span>], <span class="string">"wb+"</span>);</span><br><span class="line">    <span class="built_in">size</span> = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"write '%s' error, size is %d.\n"</span>, argv[<span class="number">2</span>], <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"build 512 bytes boot sector: '%s' success!\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析上面这段代码，我们可以得到一个合格的主引导扇区应该符合如下两个规则：</p>
<ul>
<li>输入字节在510字节内</li>
<li>最后两个字节是0x55AA</li>
</ul>
<h2 id="练习2：使用qemu执行并调试lab1中的软件-简要写出练习过程"><a href="#练习2：使用qemu执行并调试lab1中的软件-简要写出练习过程" class="headerlink" title="练习2：使用qemu执行并调试lab1中的软件(简要写出练习过程)"></a>练习2：使用qemu执行并调试lab1中的软件(简要写出练习过程)</h2><p>为了熟悉使用qemu和gdb进行的调试工作，我们进行如下的小练习：</p>
<ol>
<li>从CPU加电后执行的第一条命令开始，单步跟踪BIOS的执行</li>
<li>在初始化位置0x7c00设置实地址断点，测试断点正常</li>
<li>从0x7c00开始跟踪代码运行，将单步跟踪反汇编得到的代码与bootasm.S和bootblock.asm进行比较</li>
<li>自己找一个booloader或内核中的代码位置，设置断点并进行测试。</li>
</ol>
<h3 id="解题过程如下："><a href="#解题过程如下：" class="headerlink" title="解题过程如下："></a>解题过程如下：</h3><ol>
<li><p><strong>启动gdb，连接到qemu进行远程调试</strong></p>
<h4 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h4><p>摘录部分常用命令和参数如下：</p>
<ul>
<li>list &lt;linenum&gt; ，显示程序第linenum行周围的源程序；list &lt;function&gt; ，显示函数名为function的函数的源程序；list，显示当前行后面的源程序；list - ，显示当前行前面的源程序</li>
<li>path &lt;dir&gt;，设定程序运行路径；how paths查看路径</li>
<li>cd &lt;dir&gt;，相当于shell的cd命令；pwd显示当前所在目录</li>
<li>break [filename:]&lt;function&gt;或[filename:]&lt;linenum&gt;，在源文件（可选参数）的某个函数或某行停住；break +offset或-offset，在当前行号的前面或后面的offset行停住，offset为自然数；break *address，在程序运行的内存地址停住；break，无参数时表示在下一条指令处停住；break … if &lt;condition&gt;，以上命令均可与if语句配合使用，使得满足一定条件时在指定位置停住程序</li>
<li>info break[n]或breakpoints[n]，查看第n个断点；info break，列出当前所设置的所有观察点</li>
<li>单步调试：next，相当于VC++当中的step over；step，相当于step into</li>
<li>continue或c或fg：继续执行程序直到程序结束或到达下一个断点</li>
<li>x /nfu [addr]，显示指定地址addr及其附近的内容，其中n表示机器指令（汇编码）个数，f表示格式（包括十六进制x、字符串s、指令i等），u表示单元大小（b：1B，h：2B，w：4B，g：8B），如果不显式指定addr，则地址默认为上一次x命令显示之后的地址。</li>
<li>layout，打开可视化窗口；layout asm，打开反汇编窗口；ctrl+x a，退出当前可视化窗口回到终端</li>
</ul>
<h4 id="所用gdb命令，结合makefile使用（下列代码执行时只需在命令行输入make-lab1-mon）："><a href="#所用gdb命令，结合makefile使用（下列代码执行时只需在命令行输入make-lab1-mon）：" class="headerlink" title="所用gdb命令，结合makefile使用（下列代码执行时只需在命令行输入make lab1-mon）："></a>所用gdb命令，结合makefile使用（下列代码执行时只需在命令行输入make lab1-mon）：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file bin/kernel #指定调试目标文件，让gdb获得符号信息</span><br><span class="line">target remote :1234 #设置远程连接端口为qemu的运行端口1234，连接到qemu</span><br><span class="line">set architecture i8086 #指定qemu要模拟的硬件架构</span><br><span class="line">b *0x7c00 #在bootloader开始地址0x7c00处下断点</span><br><span class="line">continue #开始调试，执行到刚才指定的断点</span><br><span class="line">x /2i $pc #以十六进制格式打印当前机器指令及其下方一条机器指令的地址，并显示汇编</span><br><span class="line"></span><br><span class="line">layout asm #显示汇编可视化窗口</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><strong>BIOS启动：gdb查看启动后第一条执行的指令并查看BIOS代码</strong></p>
<p>修改gdbinit中指令为：</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set architecture i8086</span><br><span class="line">target remote:1234</span><br></pre></td></tr></table></figure>

<p>在lab1目录下执行make debug命令启动qemu，程序在启动后第一条指令停住。</p>
<p><img src="https://i.loli.net/2020/10/24/dcJICgLnW5ExB3M.png" alt="bios.png"></p>
</li>
</ol>
<p>   <strong>查看后续BIOS代码</strong>：</p>
<p>   执行类似x /10i addr的命令即可</p>
<ol start="3">
<li><p><strong>跳转到bootloader：在0x7c00处设置断点、测试正常可用</strong></p>
<p>如图。执行make lab1-mon命令后可在0x7c00处停住，并能按照指定规则打印出相应的汇编码。</p>
<p>这个地址在lab1init文件中显式给出。</p>
<p><img src="https://i.loli.net/2020/10/19/i1xRvgVa3KWkG8f.png" alt="gdb_break.png"></p>
</li>
<li><p><strong>单步调试+反汇编，跟踪代码运行，将调试时得到的反汇编代码与bootasm.S和bootblock.asm进行比较。</strong></p>
<p><strong>bootasm.s中包括的定义</strong>：内核代码段选择子、内核数据段选择子、保护模式使能标志、全局描述符表</p>
<p><strong>bootasm.s中包括的功能代码或代码块</strong>：禁止中断，设置寻址方向为朝向高地址，初始化（清空）DS, ES, SS段寄存器，A20使能，保护模式下初始化（设为保护模式的数据段选择子）数据段寄存器DS, ES, FS, GS, SS，初始化一个栈的指针并调用bootmain.c中的bootmain函数执行bootloader（这个函数不应该返回，如果意外返回则在下方汇编代码里进入死循环）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x7c4f  jmp	0x7c4f #一个死循环</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/19/QuhMgexjoWnyRcz.png" alt="layout_asm.png"></p>
<p>可视化窗口的反汇编代码风格是x86的，而bootasm.s文件是AT&amp;T风格，二者功能相同。</p>
</li>
</ol>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x7c4a	call 0x7cfe #bootmain函数的起始地址应该在此处，但这个地址上的汇编是pop %bp？？</span><br></pre></td></tr></table></figure>

<p>   编译lab1中的代码，在其中obj文件夹下找到<strong>bootblock.asm</strong>，即bootloader的汇编代码源文件，看到各指令下方均标明了所在地址和对应的十六进制机器码，和反汇编代码能够相互对应。</p>
<ol start="5">
<li><p><strong>自己找一个bootloader或内核中的代码位置设置断点并进行测试</strong></p>
<p><img src="https://i.loli.net/2020/10/19/Xw4HKBuPE26qz8V.png" alt="break2.png"></p>
<p>仿照之前的断点命令格式，在lab1init文件中添加一个断点，地址是0x7c02，测试可用。</p>
</li>
</ol>
<h2 id="练习3：分析bootloader进入保护模式的过程-写出分析"><a href="#练习3：分析bootloader进入保护模式的过程-写出分析" class="headerlink" title="练习3：分析bootloader进入保护模式的过程(写出分析)"></a>练习3：分析bootloader进入保护模式的过程(写出分析)</h2><p>BIOS将通过读取硬盘主引导扇区到内存，并跳转到对应内存中的执行位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。</p>
<p>既然题目中都给了提示要看bootasm.S的代码，那我们就先从这个源码入手，代码内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;asm.h&gt;</span><br><span class="line"></span><br><span class="line"># Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line"># memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line"># with %cs&#x3D;0 %ip&#x3D;7c00.</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector</span><br><span class="line">.set CR0_PE_ON,             0x1                     # protected mode enable flag</span><br><span class="line"></span><br><span class="line"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">.code16                                             # Assemble for 16-bit mode</span><br><span class="line">    cli                                             # Disable interrupts</span><br><span class="line">    cld                                             # String operations increment</span><br><span class="line"></span><br><span class="line">    # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">    #  Enable A20:</span><br><span class="line">    #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    #  address line 20 is tied low, so that addresses higher than</span><br><span class="line">    #  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60                                 # 0xdf &#x3D; 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</span><br><span class="line"></span><br><span class="line">    # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">    # and segment translation that makes virtual addresses</span><br><span class="line">    # identical to physical addresses, so that the</span><br><span class="line">    # effective memory map does not change during the switch.</span><br><span class="line">    lgdt gdtdesc</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    # Switches processor into 32-bit mode.</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line">.code32                                             # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">    # Set up the protected-mode data segment registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br><span class="line"></span><br><span class="line">    # If bootmain returns (it shouldn&#39;t), loop.</span><br><span class="line">spin:</span><br><span class="line">    jmp spin</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                          # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     # null seg</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word 0x17                                      # sizeof(gdt) - 1</span><br><span class="line">    .long gdt                                       # address gdt</span><br></pre></td></tr></table></figure>

<p>这段代码是bootmain执行之前bootloader所做的工作。不过在正式读代码之前，先读注释。从注释之中我们可以看到我们的代码分别完成了以下几个部分的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第一部分:屏蔽中断，设置串地址增长方向，设置一些重要的数据段寄存器(DS,ES,SS)</span><br><span class="line"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">.code16                                             # 使用16位模式编译</span><br><span class="line">    cli                                             # 屏蔽中断</span><br><span class="line">    cld                                             # 设置串地址增长方向</span><br><span class="line"></span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br></pre></td></tr></table></figure>

<p>在第一部分中处于实模式下，可用的内存大小不多于1M，因此需要告诉编译器使用16位模式编译。cli是禁用中断。cld将DF位置零，从而决定内存地址是增大(对应的std是将DF置一，内存地址减小)。之后使用xorw异或指令让ax寄存器值变成0，再把ax的值赋给ds，es和ss寄存器。准备工作到此结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> # 第二部分:启动A20</span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                 </span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line">    movb $0xd1, %al                                 </span><br><span class="line">    outb %al, $0x64                                </span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  </span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line">    movb $0xdf, %al                                </span><br><span class="line">    outb %al, $0x60</span><br></pre></td></tr></table></figure>

<p>首先要说一下A20是一个什么东西：</p>
<ul>
<li>最早的8086结构中的内存空间很小，一开始8086的地址线有20位，也就是说具有0-1M的寻址范围，不过当时的寄存器只有16位，无法满足寻址需求，所以采用了另外一种寻址方式：一个16位寄存器表示基址*16+另外一个16位寄存器表示偏移地址，这样寻址空间就超过了1M。但到了后来，地址线增加到了32位，为了让以前的机器也能使用这种方式(即向下兼容)，就在A20(第20根地址线)上做了一个开关，当A20被使能时，是一根正常的地址线，但是当不被使能时永远为零。在保护模式下，要访问高端的内存必须要打开这个开关，否则第21位一定是0.</li>
<li>8086体系结构的地址空间实际上是被“挖洞”了的。最早的1M内存被分为了640KB的低端常规内存和384KB的留给ROM和系统设备的高端内存，然后这个不具有前瞻性的设计就导致在之后的内存容量增大非常麻烦:被划分成了0-640KB,1M-最大内存的两个部分。为了解决这个问题，采用了这样的解决办法:加电之后先让ROM有效，取出ROM之后再让RAM有效，把这部分内容保存到RAM这部分地址空间中。</li>
<li>实际上A20是由一个8042键盘控制器来控制的A20 Gate，8042芯片有三个端口，其中之一是Output Port，而A20Gate就是Output Port端口的 bit1，所以控制A20的方式就是通过读写端口数据，使bit1为1。</li>
</ul>
<p>再讲讲这个8042芯片。</p>
<ul>
<li>这个芯片有两个外部端口0x60h和0x64h，相当于读写操作的地址。</li>
<li>在读Output Port时，需要先向0x64h发送0d0h命令，然后从0x60h读取Output Port的内容；</li>
<li>在写Output Port时，需要先向0x64h发送0d1h命令，然后往0x60h写入Output Port的内容。</li>
<li>在读写的同时还需要检查缓冲区是否有数据，有的话就暂停等待。</li>
</ul>
<p>有了上面的内容我们看这部分代码就比较简单了，每一步的作用写在注释中了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第二部分:启动A20</span><br><span class="line">seta20.1:	</span><br><span class="line">    inb $0x64, %al			#读取当前状态到al寄存器</span><br><span class="line">    testb $0x2, %al			#检查当前状态寄存器的第二位是否为1(缓冲区是否为空)</span><br><span class="line">    jnz seta20.1			#若缓冲区不为0，跳转到开始处</span><br><span class="line">    movb $0xd1, %al         #将0xd1h写入al寄存器</span><br><span class="line">    outb %al, $0x64         #向0x64h发送0xd1h命令，表示要写                      </span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al          #同1</span><br><span class="line">    testb $0x2, %al			#同1</span><br><span class="line">    jnz seta20.2			#同1</span><br><span class="line">    movb $0xdf, %al         #将0xdfh写入al寄存器                       </span><br><span class="line">    outb %al, $0x60         #向0x60h写入0xdfh，打开A20</span><br></pre></td></tr></table></figure>

<p>之后就是第三部分，初始化GDT表，通过lgdt gdtdesc指令就可以实现。</p>
<p>接下来第四部分就是进入保护模式，进入保护模式的原理就是让cr0寄存器中的PE值为1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第四部分</span><br><span class="line">movl %cr0, %eax</span><br><span class="line">orl  $CR0_PE_ON, %eax</span><br><span class="line">movl %eax, %cr0</span><br></pre></td></tr></table></figure>

<p>之后的第五部分通过一个长跳转来更新CS寄存器的基地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ljmp $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>

<p>我们可以注意到代码段最前面定义了PROT_MODE_CSGE和PROT_MODE_DSEG，分别被定义为0x8h和0x10h，这两个分别是代码段和数据段的选择子。</p>
<p>第六部分是设置段寄存器并建立堆栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第六部分:初始化各个段寄存器并建立堆栈	</span><br><span class="line">	movw $PROT_MODE_DSEG, %ax                       </span><br><span class="line">	movw %ax, %ds                                   </span><br><span class="line">	movw %ax, %es                                   </span><br><span class="line">	movw %ax, %fs                                  </span><br><span class="line">	movw %ax, %gs                                   </span><br><span class="line">	movw %ax, %ss                                 </span><br><span class="line"></span><br><span class="line">	movl $0x0, %ebp</span><br><span class="line">	movl $start, %esp</span><br><span class="line"># 第七部分:调用bootmain    </span><br><span class="line">	call bootmain</span><br><span class="line">spin:</span><br><span class="line">	jmp spin</span><br></pre></td></tr></table></figure>

<p>这个就是将各个段寄存器设置为0x10h，ebp指向0x0h，esp指向start也就是0x7c00处，最后使用call函数将返回地址入栈，控制权交给bootmain。</p>
<p>最后一个spin是如果当bootmain异常返回，在这里循环。</p>
<h2 id="练习4：分析bootloader加载ELF格式的OS过程-写出分析"><a href="#练习4：分析bootloader加载ELF格式的OS过程-写出分析" class="headerlink" title="练习4：分析bootloader加载ELF格式的OS过程(写出分析)"></a>练习4：分析bootloader加载ELF格式的OS过程(写出分析)</h2><p>通过阅读bootmain.c,了解bootloader如何加载ELF文件，通过分析源代码和通过qemu来运行并调试bootloader&amp;OS</p>
<ul>
<li>bootloader是如何读取硬盘扇区？</li>
<li>bootloader是如何加载ELF格式的OS？</li>
</ul>
<p>理论部分</p>
<p>kernel是一个elf文件，因此需要理解bootloader是如何从磁盘扇区读取kernel并在读取后进行分析的。</p>
<p>/* readsect - read a single sector at @secno into @dst */<br>static void<br>readsect(void *dst, uint32_t secno) {<br>    // wait for disk to be ready 等磁盘准备好<br>    waitdisk();       </p>
<pre><code>//把参数设置好，明确读取磁盘的命令
outb(0x1F2, 1);                         // count = 1
outb(0x1F3, secno &amp; 0xFF);
outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);
outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);
outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);
outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors

// wait for disk to be ready
waitdisk();

// read a sector 如果0x1F7不忙的话就从0x1F0把磁盘扇区数据读取到相应的内存上去
insl(0x1F0, dst, SECTSIZE / 4);</code></pre><p>}</p>
<p>bootloader通过readsec函数来读取磁盘扇区，用到了内联汇编的in和out系列函数。所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成，其中访问第一个硬盘的扇区是通过设置IO地址寄存器0x1f0-0x1f7实现的，每个通道的主从盘的选择通过第6 个IO偏移地址寄存器来设置，地址的第6位如果是1，那就是LBA模式，为0就是CHS模式；而readsec函数中用到的in和out函数的参数表也如下所示。</p>
<p>/* insl:从I/O端口port读取count个数据(单位双字)到以内存地址addr为开始的内存空间 */ void insl(unsigned port, void *addr, unsigned long count);</p>
<p>/* outb:写字节端口(8位宽)。 */ void outb(unsigned char byte, unsigned port);</p>
<p>//readseg函数实现了从offset地址处读取count个字节的数据到虚拟地址va处的功能<br>static void<br>readseg(uintptr_t va, uint32_t count, uint32_t offset) {<br>    uintptr_t end_va = va + count;</p>
<pre><code>// round down to sector boundary
va -= offset % SECTSIZE;

// translate from bytes to sectors; kernel starts at sector 1
//因为sector1从1开始，所以+1不能忘
uint32_t secno = (offset / SECTSIZE) + 1;

// If this is too slow, we could read lots of sectors at a time.
// We&apos;d write more to memory than asked, but it doesn&apos;t matter --
// we load in increasing order.
for (; va &lt; end_va; va += SECTSIZE, secno ++) {
    readsect((void *)va, secno);
}</code></pre><p>}<br>readseg读入好多个字节，并转化成扇区可以读的大小，把值传给readsect代码。最终的读取扇区工作由readsect实现。</p>
<p>/* bootmain - the entry of bootloader */<br>void<br>bootmain(void) {<br>    // read the 1st page off disk<br>    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);</p>
<pre><code>// is this a valid ELF?
if (ELFHDR-&gt;e_magic != ELF_MAGIC) {
    //判断e_magic是不是ELF_MAGIC类型，如果不是的话说明文件无效
    goto bad;
}

struct proghdr *ph, *eph;

// load each program segment (ignores ph flags)
ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff); 
//e_phoff是program header表的偏移位置，所以现在ph找到了program header表的实际位置
eph = ph + ELFHDR-&gt;e_phnum;  //e_phnum是表中的入口数目
for (; ph &lt; eph; ph ++) {
    //p_va是段的第一个字节将被放到内存中的虚拟地址；
    //p_memsz是段在内存映像中占用的字节数；
    //p_offset是段相对文件头的偏移值；
    //readseg(uintptr_t va, uint32_t count, uint32_t offset)对照段的读取函数进行参数输入
    readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);
}

// call the entry point from the ELF header
// note: does not return
//运行程序入口的虚拟地址
((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</code></pre><p>bad:<br>    outw(0x8A00, 0x8A00);<br>    outw(0x8A00, 0x8E00);</p>
<pre><code>/* do nothing */
while (1);</code></pre><p>}<br>由上述代码可以得出bootloader加载ELF格式文件的步骤：</p>
<p>先判断是不是有效的ELF文件；<br>通过elf的文件头找到program header表；<br>根据program header表中的每个段的内存映像地址、大小等，并读取段数据（如数据段、代码段等）<br>必要的数据读取完成后跳转到程序入口的虚拟地址准备运行。</p>
<p>从ELF文件格式可以更清晰地看到bootloader在判断完elf文件类型后，跳转到相应的段进行后需磁盘访问。</p>
<p>我们还可以利用understand可以查看regsect的函数调用</p>
<h2 id="练习5：实现函数调用堆栈跟踪函数-需要编程"><a href="#练习5：实现函数调用堆栈跟踪函数-需要编程" class="headerlink" title="练习5：实现函数调用堆栈跟踪函数(需要编程)"></a>练习5：实现函数调用堆栈跟踪函数(需要编程)</h2><p>我们需要在lab1中完成kdebug.c中函数print_stackframe的实现，可以通过函数print_stackframe了跟踪函数调用堆栈中记录的返回地址。</p>
<p>在lab1/kern/debug目录下找到kdebug.c,打开以后发现源文件中已经有一个print_stackframe函数了(虽然里面啥也没有)，要做的就是往里面添加代码，让这个函数能实现我们需要的功能。以下是初始状态的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf("\n");</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton's ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现函数调用堆栈跟踪函数，需要先了解函数调用栈的原理。</p>
<p>函数调用时，自栈顶(低地址)到栈底(高地址)的情况如下图所示</p>
<p><img src="https://i.loli.net/2020/10/04/VJfMkbU4q6ClsKe.png" alt="05.1.png"></p>
<p>esp和ebp两个指针是其中最关键的部分，只要掌握了ebp和esp的位置，就能很容易理解函数调用过程了。根据这个图，我们可以有这样几个信息</p>
<ul>
<li>ss[ebp]指向上一层的ebp</li>
<li>ss[ebp-4]指向局部变量</li>
<li>ss[ebp+4]指向返回地址</li>
<li>ss[ebp+4+4n]指向第n个参数</li>
</ul>
<p>之后我们就可以着手实现堆栈跟踪函数了。首先我们知道在bootasm.S中将esp设置为0x7c00，ebp设置为0，就调用了bootmain函数。call指令会依次执行以下命令:push返回地址，push这一层的ebp，然后把现在的esp赋值给ebp。在执行完call之后，这个ebp指向了0x7bf8(0x7c00-4-4)。</p>
<p>实现之前我们看一下源代码中的注释，突然惊讶的发现注释已经非常贴心的教你怎么写了，那就按着这个注释一步一步来，写出如下的结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">print_stackframe(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf("\n");</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton's ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> ebp = read_ebp(), eip = read_eip();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i++)&#123;</span><br><span class="line">		cprintf(<span class="string">"ebp=: 0x%08x | eip=: 0x%08x | args=: "</span>, ebp, eip);</span><br><span class="line">		<span class="keyword">uint32_t</span> *args = (<span class="keyword">uint32_t</span> *)ebp + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">			cprintf(<span class="string">"0x%08x "</span>, args[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		cprintf(<span class="string">"\n"</span>);</span><br><span class="line">		print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">		eip = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">1</span>];</span><br><span class="line">		ebp = ((<span class="keyword">uint32_t</span> *)ebp)[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在lab1目录下执行命令 $ make qemu，得到如下的输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">Kernel executable memory footprint: 64KB</span><br><span class="line">ebp&#x3D;: 0x00007b28 | eip&#x3D;: 0x00100a63 | args&#x3D;: 0x00010094 0x00010094 0x00007b58 0x00100092 </span><br><span class="line">    kern&#x2F;debug&#x2F;kdebug.c:307: print_stackframe+21</span><br><span class="line">ebp&#x3D;: 0x00007b38 | eip&#x3D;: 0x00100d4d | args&#x3D;: 0x00000000 0x00000000 0x00000000 0x00007ba8 </span><br><span class="line">    kern&#x2F;debug&#x2F;kmonitor.c:125: mon_backtrace+10</span><br><span class="line">ebp&#x3D;: 0x00007b58 | eip&#x3D;: 0x00100092 | args&#x3D;: 0x00000000 0x00007b80 0xffff0000 0x00007b84 </span><br><span class="line">    kern&#x2F;init&#x2F;init.c:48: grade_backtrace2+33</span><br><span class="line">ebp&#x3D;: 0x00007b78 | eip&#x3D;: 0x001000bc | args&#x3D;: 0x00000000 0xffff0000 0x00007ba4 0x00000029 </span><br><span class="line">    kern&#x2F;init&#x2F;init.c:53: grade_backtrace1+38</span><br><span class="line">ebp&#x3D;: 0x00007b98 | eip&#x3D;: 0x001000db | args&#x3D;: 0x00000000 0x00100000 0xffff0000 0x0000001d </span><br><span class="line">    kern&#x2F;init&#x2F;init.c:58: grade_backtrace0+23</span><br><span class="line">ebp&#x3D;: 0x00007bb8 | eip&#x3D;: 0x00100101 | args&#x3D;: 0x001032dc 0x001032c0 0x0000130a 0x00000000 </span><br><span class="line">    kern&#x2F;init&#x2F;init.c:63: grade_backtrace+34</span><br><span class="line">ebp&#x3D;: 0x00007be8 | eip&#x3D;: 0x00100055 | args&#x3D;: 0x00000000 0x00000000 0x00000000 0x00007c4f </span><br><span class="line">    kern&#x2F;init&#x2F;init.c:28: kern_init+84</span><br><span class="line">ebp&#x3D;: 0x00007bf8 | eip&#x3D;: 0x00007d72 | args&#x3D;: 0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8 </span><br><span class="line">    &lt;unknow&gt;: -- 0x00007d71 --</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>最后一行中给出了ebp，eip和args三个参数，其具体意义为</p>
<ul>
<li><strong>ebp=: 0x00007bf8</strong> 是跳转到bootmain</li>
<li><strong>eip=: 0x00007d72</strong> 是从bootasm.s跳转到bootmain前的地址，也就是bootmain的返回地址。</li>
<li><strong>args=: 0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8</strong> 通常状态下，args存放的四个dword是对应4个输入参数的值。但是再最底层处，即7c00往后增加的地址处，那里是bootloader的代码段，所以最后的args其实是bootloader指令的前十六个字节，下面这个例子就能很好的说明情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bootloader前三条指令对应的机器码</span><br><span class="line">7c00:	cli 			fa                   	</span><br><span class="line">7c01:	cld 			fc   </span><br><span class="line">7c02:	xor    %eax,%eax	31 c0</span><br><span class="line"># 由于是小端字节序，所以存储为 c0 31 fc fa</span><br></pre></td></tr></table></figure>

<h2 id="练习6：完善中断初始化和处理-需要编程"><a href="#练习6：完善中断初始化和处理-需要编程" class="headerlink" title="练习6：完善中断初始化和处理(需要编程)"></a>练习6：完善中断初始化和处理(需要编程)</h2><p>完成编码工作并回答如下问题：</p>
<ol>
<li><p><strong>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪<br>几位代表中断处理代码的入口？</strong></p>
<ul>
<li><p>保护模式下，段寄存器含有段选择子；CPU收到中断信息后，需要先根据中断类型码找到对应的中断处理程序地址，这个过程通过查中断描述符表（获得特定中断处理程序的偏移量并以中断向量为索引查找中断处理程序的段选择子）以及全局描述符表（通过中断处理程序的段选择子获得段基址）完成；一个表项被称作一个门描述符，占<strong>八个字节</strong>。三种类型（还有第四种：调用门描述符，结构与任务门描述符相同）的门描述符结构如下：</p>
<p><img src="https://i.loli.net/2020/10/24/hJeg6HjlRBMD2vF.png" alt="1.png"></p>
</li>
<li><p><strong>第16-31位</strong>（即低四字节中的高16位）段选择子结合<strong>第0-15位、第48-63位</strong>的偏移量可以代表中断处理代码的入口。</p>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><strong>请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，<br>依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个<br>中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。</strong></li>
</ol>
   <img src="https://i.loli.net/2020/10/24/GxB1s7IqPDtQuSj.png" alt="2" style="zoom:80%;" />

<p>   如图，kern/mm/mmu.h中定义了两个宏用于定义或初始化门描述符。对上图宏定义的解释如下：</p>
<p>   <strong>中断门描述符和陷阱门描述符的结构相同，均以结构体gatedesc定义，总大小为8字节。其成员变量的含义如下</strong>：</p>
<ul>
<li><p>gd_off_15_0：低四字节里低16位上的 中断处理程序偏移量</p>
</li>
<li><p>gd_ss：段选择子，位于低四字节中的高16位</p>
</li>
<li><p>gd_args：某些参数，在中断/陷阱门描述符里不会用到，一直设为0即可，占5位</p>
</li>
<li><p>gd_rsvl：某些保留部分，也不会用到，保持0不变，占3位</p>
</li>
<li><p>gd_type：表示当前是什么类型的门描述符，占4位；对应的变量STS_IG32（0xE）和STS_TG32（0xF）存储在kern/mm/mmu.h中；因为中断处理时只需考虑中断门和陷阱门，因此只涉及上述两个宏定义变量</p>
</li>
<li><p>gd_s：某系统参数，设为0即可，仅1位</p>
</li>
<li><p>gd_dpl：中断处理过程涉及的特权级（0或3，其中中断处理程序的DPL只能是ring 0），占两位，分别用kern/mm/mmu.h中定义的DPL_KERNEL和DPL_USER来表示</p>
</li>
<li><p>gd_p：一位标志位，如果段在内存里出现则为1，不在内存里则为0</p>
</li>
<li><p>gd_off_31_16：高四字节里高16位上的中断处理程序偏移量</p>
<p>另：C语法中，变量定义里冒号后面接数字这个格式用于指定该变量的位数。</p>
</li>
</ul>
<p>   <strong>SETGATE宏将被替换为一个语句块，功能是给IDT这个结构体数组（结构体名：gatedesc）的各项成员赋值，即用于初始化门描述符，参数的意义分别是</strong>：</p>
<ul>
<li>gate：取为idt[]的一项，就是一个gatedesc结构体</li>
<li>istrap：0或1，0选择中断门，1选择陷阱门</li>
<li>sel：中断处理程序所在段的段选择子</li>
<li>off：32位偏移量，由16位的两部分拼接而成</li>
<li>dpl：该门描述符对应中断处理程序的特权级</li>
</ul>
<p>   <strong>IDT初始化整体流程是先初始化内核态中断，再初始化系统调用中断，最后在IDTR寄存器中存放IDT的地址，代码如下</strong>：</p>
<p>   <img src="https://i.loli.net/2020/10/24/iU8TXbcC4L6hWfK.png" alt="3.png"></p>
<ul>
<li><p>根据提示，中断服务例程（ISR）的入口地址都存放在uintptr_t类型的__vectors数组中，该数组由tools/vectors.c生成，存放在kern/trap/vector.S中 ；</p>
<p><img src="https://i.loli.net/2020/10/24/TKVZBaI1O5zfSl4.png" alt="4.png"></p>
</li>
<li><p>vectori即为中断向量，跳转到对应的中断向量之后，将调用kern/trap/trapentry.S中__alltraps函数保存被打断的程序的现场；</p>
</li>
<li><p>trap.c中为IDT准备了结构体数组定义：类型为gatedesc的idt[256]，每个IDT表项就是该数组中的一项，使用SETGATE宏进行初始化；</p>
</li>
<li><p>中断的特权级应设为ring 0，使用/kern/mm/memlayout.h中定义的系统、用户特权级变量（DPL_KERNEL，值是0；DPL_USER，值是3）；</p>
</li>
<li><p>IDT的内容初始化完成后，还需要将IDT的起始地址加载到IDTR寄存器里，即需调用lidt指令——在C程序里写调用的方法是使用x86.h中定义的lidt函数（该函数参数类型pseudodesc也定义在x86.h中，可以看到存放了段的大小和基址），其功能是生成内联汇编来调用lidt指令（volatile关键字的意思是编译时拒绝优化）。</p>
<p><img src="https://i.loli.net/2020/10/24/LSJ6IWlETd5iaHO.png" alt="5.png"></p>
<p><img src="https://i.loli.net/2020/10/24/j4UqW1Vo8nQvf2B.png" alt="6.png"></p>
</li>
<li><p>在trap.c中，可以方便地将该文件里定义的pseudodesc类型结构体idt_pd实例化，作为lidt函数的参数：</p>
<p><img src="https://i.loli.net/2020/10/24/XW8weHNy15QsjuU.png" alt="7.png"></p>
</li>
</ul>
<ol start="3">
<li><p><strong>请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中<br>处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向<br>屏幕上打印一行文字”100 ticks”。</strong></p>
<p>trap.h当中定义了中断号；IRQ_OFFSET之后的若干编号代表硬件中断，比如IRQ_OFFSET+IRQ_TIMER表示时钟中断的中断号。</p>
<p><img src="https://i.loli.net/2020/10/24/jvWOuQMfBSAPG5T.png" alt="8.png"></p>
<p>按照给出的提示填充trap_dispatch函数，使用全局变量ticks记录已发生的时钟中断数目；该中断每发生每100（TICK_NUM）次调用一遍print_ticks函数打印字符串即可。</p>
</li>
</ol>
<p>重新编译并运行整个系统（lab1目录下执行make qemu），可以看到打印出了时钟中断信息，按下的键也会显示在屏幕上：</p>
<p><img src="https://i.loli.net/2020/10/24/VWRKfCBpS1xyD6s.png" alt="9.png"></p>
<h2 id="扩展练习-Challenge1-需要编程"><a href="#扩展练习-Challenge1-需要编程" class="headerlink" title="扩展练习 Challenge1(需要编程)"></a>扩展练习 Challenge1(需要编程)</h2><blockquote>
<p>扩展proj4,增加syscall功能，即增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务（通过网络查询所需信息，可找老师咨询。如果完成，且有兴趣做代替考试的实验，可找老师商量）。需写出详细的设计和分析报告。完成出色的可获得适当加分。</p>
</blockquote>
<p>首先为了完成特权级转换，需要了解这些知识：</p>
<ul>
<li>int iret在不同情况下的执行步骤</li>
<li>特权级检查</li>
</ul>
<p>阅读实验指导书，kern/init/init.c和kern/trap/trap.c文件，不难发现这个challenge需要我们完成以下四个内容：</p>
<ul>
<li>kern/init/init.c    中的 switch_to_user</li>
<li>kern/init/init.c    中的 switch_to_kernel</li>
<li>kern/trap/trap.c 中的 case T_SWITCH_TOU #to user</li>
<li>kern/trap/trap.c 中的 case T_SWITCH_TOK #to kernel</li>
</ul>
<p>因为在调用关系中是 init.c调用trap.c，所以先从init.c中入手。</p>
<p>先来看switch_to_user。很好，什么也没有，满足我对于难度的要求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lab1_switch_to_user(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">//LAB1 CHALLENGE 1 : TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有东西只能白手起家，还能咋地。先把写好的代码贴出来，之后再进行详细的解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;	init.c</span><br><span class="line">static void</span><br><span class="line">lab1_switch_to_user(void) &#123;</span><br><span class="line">    &#x2F;&#x2F;LAB1 CHALLENGE 1 : TODO</span><br><span class="line">    asm volatile(</span><br><span class="line">		    &quot;sub $0x8,%%esp \n&quot;</span><br><span class="line">		    &quot;int %0 \n&quot;</span><br><span class="line">		    &quot;movl %%ebp, %%esp \n&quot;</span><br><span class="line">		    :</span><br><span class="line">		    :&quot;i&quot;(T_SWITCH_TOU)</span><br><span class="line">		);</span><br><span class="line">&#125;</span><br><span class="line">static void</span><br><span class="line">lab1_switch_to_kernel(void) &#123;</span><br><span class="line">    &#x2F;&#x2F;LAB1 CHALLENGE 1 :  TODO</span><br><span class="line">    asm volatile(</span><br><span class="line">		    &quot;int %0 \n&quot;</span><br><span class="line">		    &quot;movl %%ebp, %%esp \n&quot;</span><br><span class="line">		    :</span><br><span class="line">		    :&quot;i&quot;(T_SWITCH_TOK)</span><br><span class="line">		);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trap.c</span></span><br><span class="line">	<span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">        <span class="keyword">if</span>(tf-&gt;tf_cs != USER_CS)	<span class="comment">//检查是不是用户态，不是就操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            	cprintf(<span class="string">"...to user\n"</span>);</span><br><span class="line">                <span class="comment">// 设置用户态对应的cs,ds,es,ss四个寄存器</span></span><br><span class="line">            	tf-&gt;tf_cs = USER_CS;</span><br><span class="line">                tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">                <span class="comment">// 为用户态带来可以I/O的快乐</span></span><br><span class="line">                tf-&gt;tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">        <span class="keyword">if</span>(tf-&gt;tf_cs != KERNEL_CS)	<span class="comment">//检查是不是内核态，不是就操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            	cprintf(<span class="string">"...to kernel\n"</span>);</span><br><span class="line">            	<span class="comment">// 设置内核态对应的cs,ds,es三个寄存器</span></span><br><span class="line">                tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">                tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">				<span class="comment">// 剥夺用户态可以使用I/O的快乐</span></span><br><span class="line">                tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>一开始我以为user_to_kernel和kernel_to_user应该没有什么区别，但这个challenge1不愧是个challenge。其中的区别在中断发生的压栈状况有关系。</p>
<p>中断可以发生在任何一个特权级别下，但是不同的特权级处理器使用的栈不同，如果涉及到特权级的变化，需要对SS和ESP寄存器进行压栈。性质如下：</p>
<ul>
<li><p>当低特权级向高特权级切换的压栈(<strong>用户态到内核态</strong>)</p>
<p>需要判断是否能访问这个目标段描述符，要做的就是将找到中断描述符时的CPL与目标段描述符的DPL进行比较。当CPL特权级比DPL低(CPL&gt;DPL)时，要往高特权级栈转移，也就是说要恢复旧栈，因此处理器临时保存旧栈的SS和ESP，然后加载新的特权级和DPL相同的段到SS和ESP中，把旧栈的SS和ESP压入新栈</p>
</li>
<li><p>当无特权级转化时的压栈(<strong>内核态到用户态</strong>)</p>
<p>理论上来说从内核态到用户态也需要对栈进行切换，不过在lab1中并没有完整实现对物理内存的管理，而GDT中的每一个段除了对特权级的要求以外都一样，所以只需要修改一下权限就可以实现了。这也导致这个时候不会压栈，我们需要手动压栈(体现在lab1_switch_to_user中的sub $0x8,%%esp)。</p>
</li>
</ul>
<p>不过在trap.c中的实现比较雷同，把对应的tf指针修改为对应态的内容就行。</p>
<h6 id="遇到的一些麻烦和问题"><a href="#遇到的一些麻烦和问题" class="headerlink" title="遇到的一些麻烦和问题"></a>遇到的一些麻烦和问题</h6><ol>
<li><p><strong>关于int和iretz</strong></p>
<p>这俩东西可以说是中断的灵魂，如果搞不懂这个真的没法做实验。用这两个中断过程来举例</p>
<ol>
<li><p>中断触发后，处理器根据中断向量号找到对应的中断描述符，然后拿<strong>中断发生时的CPL</strong>和<strong>中断描述符</strong>中的<strong>段选择子</strong>对应的<strong>DPL</strong>做对比，如果发现CPL权限比DPL低(CPL数值更大)时，将旧栈压入新栈，具体表现就是将ss_old和esp_old压入ss_new和esp_new中。用户态到内核态的栈切换由TSS和硬件实现</p>
</li>
<li><p><strong>在用户态到内核态的切换过程中</strong>，依次压入(高地址)ss,esp,eflags,cs,eip,errorno(低地址)等参数；<strong>在内核态到用户态的切换过程中</strong>，依次压入(高地址)eflags,cs,eip,errorno(低地址)等参数</p>
</li>
<li><p><strong>在用户态到内核态的切换过程中</strong>，不用给空间，直接用int %0触发中断。这个int %0对应的是我们的输入(T_SWITCH_TOK)，调用前后函数后我们的栈帧如下</p>
<blockquote>
<p>//调用前</p>
<p>(高地址)user_ss,野指针,eflags,user_cs,eip,errorno,trapno,user_ds,user_es(低地址)</p>
<p>// 调用后</p>
<p>(高地址)user_ss,野指针,eflags,kernel_cs,eip,errorno,trapno,kernel_ds,kernel_es(低地址)</p>
</blockquote>
<p><strong>在内核态到用户态的切换过程中</strong>，先通过sub $0x8,%%esp给8B的空间，之后同样用int %0触发中断，此时对应的就是(T_SWITCH_TOU)，调用前后的栈帧如下</p>
<blockquote>
<p>//调用前</p>
<p>(高地址)野指针,野指针,eflags,kernel_cs,eip,errorno,trapno,kernel_ds,kernel_es(低地址)</p>
<p>// 调用后</p>
<p>(高地址)user_ss,野指针,eflags,user_cs,eip,errorno,trapno,user_ds,user_es(低地址)</p>
</blockquote>
</li>
<li><p>执行完中断程序之后，通过<strong>iret</strong>返回，依次弹出对应段选择子从而实现对栈的切换。在弹出eip和cs之后，根据cs中的RPL判断是否需要继续弹出。<strong>也就是说，如果要返回到特权级更低的代码，就要弹出ss和esp</strong>。</p>
<p><strong>在用户态到内核态的切换过程中</strong>，栈中的CS是kernel_cs，DPL=0，当前的CPL=3，代码不会返回到更低的特权级，所以不弹出esp和ss。<strong>但是栈所在的段已经发生了变化</strong>，也就是SS已经发生了变化：在用户态下中断会导致user_ss和user_esp被压入新的内核栈，所以最开始的ss就是kernel_ss。这也是为什么在TOK中不用设置tf_ss。</p>
<p><strong>在内核态到用户态的切换过程中</strong>，栈中的CS是user_cs，DPL=3，当前的CPL=0，代码会返回到更低的特权级，所以会弹出esp和ss，这个时候野指针被pop到esp，user_ss被弹出到ss，实现了栈段的切换，内核切换到了用户栈。</p>
</li>
<li><p>还有最后一句话movl %%ebp, %%esp。同样在两种情况下看</p>
<p><strong>在用户态到内核态的切换过程中</strong>，要回收user_ss,user_esp，所以通过这句话让esp指向ebp，并且顶掉原来储存在这个位置的user_esp，而4中我们知道了这个时候的user_ss实际上是kernel_ss，所以不用管他。</p>
<p><strong>在内核态到用户态的切换过程中</strong>，此时的esp是野指针，是一个内存的初始值，我们需要让他指向ebp。那怎么给ebp呢？很巧妙，在sub $0x8,%%esp这句话执行之后，栈帧状态是这样的</p>
<blockquote>
<p>(高地址)野指针，野指针(低地址)</p>
</blockquote>
<p>但其实原来的ebp刚好就在上面，实际上是这样</p>
<blockquote>
<p>(高地址)原ebp，(ebp指向)，野指针，野指针(低地址)</p>
</blockquote>
<p>所以这句话就能帮助我们让esp的野指针指向ebp</p>
</li>
</ol>
</li>
<li><p><strong>在用户态和内核态的切换时，虽然eip没变，但是段在变，为什么还能正常运行?</strong></p>
<p>一开始没想明白，后面脑子突然上线：哦，<strong>我们现在是保护模式</strong></p>
<p>所以我们的CS不再是直接的代码段，而是段选择子，并不是一个实际的物理段地址而是一个索引，通过这个索引去查这个段具体的物理地址。 </p>
<p>具体的格式如下</p>
<blockquote>
<p>格式为：【索引(13)|TI(1)|RPL(2)】 </p>
<p>索引：GDT表中有8K个表项(2^13=8k) </p>
<p>TI：    0-GDT 1-LDT </p>
<p>RPL：00-kernel，11-user </p>
<p>内核态下的8  = 【00…01|0|00】</p>
<p>用户态下的1b = 【00…11|0|11】</p>
</blockquote>
<p>这里面影响地址的只有索引，他俩的索引一个是1，3。索引和GDT表有关，那么我们看看GDT表的相关内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kern/mm/pmm.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] = &#123;</span></span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]   = SEG_NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1对应的是[SEG_KTEXT]，内核段，ok，3对应的是[SEG_UTEXT]，用户段，也ok。这里出现的新东西是 segdesc 和 SEG，再去看看这俩到底是个啥</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kern/mm/mmu.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_lim_15_0 : <span class="number">16</span>;        <span class="comment">// low bits of segment limit</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_base_15_0 : <span class="number">16</span>;        <span class="comment">// low bits of segment base address</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_base_23_16 : <span class="number">8</span>;        <span class="comment">// middle bits of segment base address</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_type : <span class="number">4</span>;            <span class="comment">// segment type (see STS_ constants)</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_s : <span class="number">1</span>;                <span class="comment">// 0 = system, 1 = application</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_dpl : <span class="number">2</span>;            <span class="comment">// descriptor Privilege Level</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_p : <span class="number">1</span>;                <span class="comment">// present</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_lim_19_16 : <span class="number">4</span>;        <span class="comment">// high bits of segment limit</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_avl : <span class="number">1</span>;            <span class="comment">// unused (available for software use)</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_rsv1 : <span class="number">1</span>;            <span class="comment">// reserved</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_db : <span class="number">1</span>;                <span class="comment">// 0 = 16-bit segment, 1 = 32-bit segment</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_g : <span class="number">1</span>;                <span class="comment">// granularity: limit scaled by 4K when set</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_base_31_24 : <span class="number">8</span>;        <span class="comment">// high bits of segment base address</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG(type, base, lim, dpl)                        \</span></span><br><span class="line">    (struct segdesc)&#123;                                    \</span><br><span class="line">        ((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>, (base) &amp; <span class="number">0xffff</span>,        \</span><br><span class="line">        ((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>, type, <span class="number">1</span>, dpl, <span class="number">1</span>,            \</span><br><span class="line">        (<span class="keyword">unsigned</span>)(lim) &gt;&gt; <span class="number">28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,                \</span><br><span class="line">        (<span class="keyword">unsigned</span>) (base) &gt;&gt; <span class="number">24</span>                            \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到SEG括号内的第二个参数base，都是0x0，破案了，<strong>他们虽然表面上选择子一直在换，但是他们所指向的实际物理段基址并没有变，是一样的</strong>。</p>
</li>
</ol>
<h2 id="扩展练习-Challenge2-需要编程"><a href="#扩展练习-Challenge2-需要编程" class="headerlink" title="扩展练习 Challenge2(需要编程)"></a>扩展练习 Challenge2(需要编程)</h2><blockquote>
<p>用键盘实现用户模式内核模式切换。具体目标是：“键盘输入3时切换到用户模式，键盘输入0时切换到内核模式”。 基本思路是借鉴软中断(syscall功能)的代码，并且把trap.c中软中断处理的设置语句拿过来。</p>
</blockquote>
<p>在Challenge1中我们其实已经实现了用户模式和内核模式的相互切换，所需要的只是增加一个用键盘输入来控制切换的功能。我们找到控制状态切换的trap.c文件中的trap_dispatch函数。他已经很贴心的给我们写了一个case IRQ_OFFSET + IRQ_KBD:(键盘输入情况)</p>
<p>很自然的能够想到，用<strong>if-else</strong>结构就可以实现一个控制。那么到此编程的思路已经十分明确了。直接贴出我们的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD:</span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">"kbd [%03d] %c\n"</span>, c, c);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'0'</span> &amp;&amp; (tf-&gt;tf_cs &amp; <span class="number">3</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                cprintf(<span class="string">"Input 0......switch to kernel\n"</span>);</span><br><span class="line">                tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">                tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">                tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'3'</span> &amp;&amp; (tf-&gt;tf_cs &amp; <span class="number">3</span>) != <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                cprintf(<span class="string">"Input 3......switch to user\n"</span>);</span><br><span class="line">                tf-&gt;tf_cs = USER_CS;</span><br><span class="line">                tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">                tf-&gt;tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>完成了所有的实验和challeng之后，使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make qemu</span><br></pre></td></tr></table></figure>

<p>执行出来的程序应该出现如下情况</p>
<p><img src="https://i.loli.net/2020/10/19/eCbnJzD7joT5RpO.png" alt="01.png"></p>
<p><img src="https://i.loli.net/2020/10/19/Ej9x48r2cCqD6Vf.png" alt="02.png"></p>
<p><img src="https://i.loli.net/2020/10/19/nQ8HevbaUI93lgm.png" alt="03.png"></p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x09</title>
    <url>/2020/11/07/Compiler%E5%AD%A6%E4%B9%A0-0x09/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="编译系统原理预习作业08-刀马WCH"><a href="#编译系统原理预习作业08-刀马WCH" class="headerlink" title="编译系统原理预习作业08@刀马WCH"></a>编译系统原理预习作业08@刀马WCH</h1><h2 id="1：预习中的难点"><a href="#1：预习中的难点" class="headerlink" title="1：预习中的难点"></a>1：预习中的难点</h2><p>算符优先分析&amp;错误处理中对于 错误位置不在栈顶的情况 如何处理</p>
<h2 id="2：算符优先分析-amp-错误处理"><a href="#2：算符优先分析-amp-错误处理" class="headerlink" title="2：算符优先分析&amp;错误处理"></a>2：算符优先分析&amp;错误处理</h2><blockquote>
<p>给出(id+*id进行算符优先分析（包括错误恢复）的完整过程</p>
</blockquote>
<p>先构造如下的算符优先表</p>
<table>
<thead>
<tr>
<th></th>
<th>id</th>
<th>+</th>
<th>*</th>
<th>(</th>
<th>)</th>
<th>$</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td></td>
<td>⋗</td>
<td>⋗</td>
<td></td>
<td>⋗</td>
<td>⋗</td>
</tr>
<tr>
<td>+</td>
<td>⋖</td>
<td>⋗</td>
<td>⋖</td>
<td>⋖</td>
<td>⋗</td>
<td>⋗</td>
</tr>
<tr>
<td>*</td>
<td>⋖</td>
<td>⋗</td>
<td>⋗</td>
<td>⋖</td>
<td>⋗</td>
<td>⋗</td>
</tr>
<tr>
<td>(</td>
<td>⋖</td>
<td>⋖</td>
<td>⋖</td>
<td>⋖</td>
<td>≐</td>
<td></td>
</tr>
<tr>
<td>)</td>
<td></td>
<td>⋗</td>
<td>⋗</td>
<td></td>
<td>⋗</td>
<td>⋗</td>
</tr>
<tr>
<td>$</td>
<td>⋖</td>
<td>⋖</td>
<td>⋖</td>
<td>⋖</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>再构造如下的错误恢复表和有限错误类型</p>
<table>
<thead>
<tr>
<th></th>
<th>id</th>
<th>(</th>
<th>)</th>
<th>$</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>e3</td>
<td>e3</td>
<td>⋗</td>
<td>⋗</td>
</tr>
<tr>
<td>(</td>
<td>⋖</td>
<td>⋖</td>
<td>≐</td>
<td>e4</td>
</tr>
<tr>
<td>)</td>
<td>e3</td>
<td>e3</td>
<td>⋗</td>
<td>⋗</td>
</tr>
<tr>
<td>$</td>
<td>⋖</td>
<td>⋖</td>
<td>e2</td>
<td>e1</td>
</tr>
</tbody></table>
<p>1.e1：插入<strong>id</strong>到输入缓冲，“缺少运算数”</p>
<p>2.e2：删除)，“未匹配右括号”</p>
<p>3.e3：插入+到输入缓冲，“缺少运算符”</p>
<p>4.e4：弹出(，“缺少右括号”</p>
<p>5.e5：+或*两侧不全有非终结符时，忽略此符号，错误信息“缺少运算数”</p>
<p>根据上表进行算符优先分析和错误处理的过程如下(因为不会打这几个符号且没有涉及，用&lt;&gt;=代替)</p>
<table>
<thead>
<tr>
<th>STACK</th>
<th>INPUT</th>
<th>REMARK</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>(id+*id$</td>
<td>$ &lt; (</td>
</tr>
<tr>
<td>$(</td>
<td>id+*id$</td>
<td>( &lt; id</td>
</tr>
<tr>
<td>$(id</td>
<td>+*id$</td>
<td>id &gt; +</td>
</tr>
<tr>
<td>$(E</td>
<td>+*id$</td>
<td>( &lt; +</td>
</tr>
<tr>
<td>$(E+</td>
<td>*id$</td>
<td>+ &lt; *</td>
</tr>
<tr>
<td>$(E+*</td>
<td>id$</td>
<td>* &lt; id</td>
</tr>
<tr>
<td>$(E+*id</td>
<td>$</td>
<td>id &gt; $</td>
</tr>
<tr>
<td>$(E+*E</td>
<td>$</td>
<td>* &gt; $ : e5</td>
</tr>
<tr>
<td>$(E+E</td>
<td>$</td>
<td>+ &gt; $</td>
</tr>
<tr>
<td>$(E</td>
<td>$</td>
<td>e4</td>
</tr>
<tr>
<td>$E</td>
<td>$</td>
<td>accept</td>
</tr>
</tbody></table>
<h2 id="3：NFA识别活前缀"><a href="#3：NFA识别活前缀" class="headerlink" title="3：NFA识别活前缀"></a>3：NFA识别活前缀</h2><blockquote>
<p>继续上一页的分析过程，完成abbcde的分析</p>
</blockquote>
<p>上一页的分析过后我们完成了对abbc的分析，现在我们的状态为</p>
<blockquote>
<p>S-&gt;aA.Be 输入缓冲区为de</p>
</blockquote>
<p>由于此时不存在B，输入ε迁移到状态B-&gt;.d,之后输入d迁移到状态B-&gt;d. </p>
<p>此时可以归约出一个B，回退到状态S-&gt;aA.Be，输入B后进入S-&gt;aAB.e</p>
<p>之后输入e,得到S-&gt;aABe.，归约出一个S，回退到S’-&gt;.S输入S，得到S’-&gt;S. 接受</p>
<h2 id="4：构造LR-0-项目集规范族"><a href="#4：构造LR-0-项目集规范族" class="headerlink" title="4：构造LR(0)项目集规范族"></a>4：构造LR(0)项目集规范族</h2><blockquote>
<p>对下面文法计算LR(0)项目集规范族</p>
<p>S -&gt; aABe</p>
<p>A -&gt; Abc | b</p>
<p>B -&gt; d</p>
</blockquote>
<p>可以生成以下的拓广文法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S&#39; → .S		S&#39; → S.</span><br><span class="line">S  → .aABe	S  → a.ABe	S  → aA.Be	S  → aAB.e	S  → aABe.</span><br><span class="line">A  → .Abc	A  → A.bc	A  → Ab.c	A  → Abc.</span><br><span class="line">A  → .b		A  → b.	</span><br><span class="line">B  → .d		B  → d.</span><br></pre></td></tr></table></figure>

<p>根据拓广文法，得到如下项目集规范族</p>
<p><img src="https://i.loli.net/2020/11/16/waBj4MDIW7QiVtb.png" alt="未命名文件.png"></p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x08</title>
    <url>/2020/11/07/Compiler%E5%AD%A6%E4%B9%A0-0x08/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="编译系统原理预习作业07-刀马WCH"><a href="#编译系统原理预习作业07-刀马WCH" class="headerlink" title="编译系统原理预习作业07@刀马WCH"></a>编译系统原理预习作业07@刀马WCH</h1><a id="more"></a>

<h2 id="1：错误处理"><a href="#1：错误处理" class="headerlink" title="1：错误处理"></a>1：错误处理</h2><p>指出程序中存在哪些错误，分析哪些容易恢复，哪些困难</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> i,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;   </span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        语法错误：缺少分号 容易恢复</span></span><br><span class="line"><span class="comment">        语法错误：函数未声明</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		j=v+f2(i) </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	j=u+f1(u*u);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        语法错误：缺少分号 容易恢复</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		j=j+i*i</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        语法错误：中文引号 容易恢复</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="built_in">printf</span>(“%d\n”,i); 	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f1(j));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2：最右推导"><a href="#2：最右推导" class="headerlink" title="2：最右推导"></a>2：最右推导</h2><p><img src="https://i.loli.net/2020/11/03/qhlCDaIH6MwryBR.png" alt="IMG_0049.PNG"></p>
<h2 id="3：NFA-gt-CFG"><a href="#3：NFA-gt-CFG" class="headerlink" title="3：NFA-&gt;CFG"></a>3：NFA-&gt;CFG</h2><blockquote>
<p>A<del>0</del> → 1A<del>0</del> | 0A<del>1</del> | ε</p>
<p>A<del>1</del> → 0A<del>1</del> | 1A<del>2</del> | ε</p>
<p>A<del>2</del> → 0A<del>1</del> | ε</p>
</blockquote>
<h2 id="4：消除间接左递归"><a href="#4：消除间接左递归" class="headerlink" title="4：消除间接左递归"></a>4：消除间接左递归</h2><blockquote>
<p>S → Aa | b</p>
<p>A → bdA’ | A’</p>
<p>A’ → cA’ | adA’ |ε</p>
</blockquote>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC-01-测试币的领取，交易以及多重签名交易</title>
    <url>/2020/10/27/BTC-01-%E6%B5%8B%E8%AF%95%E5%B8%81%E7%9A%84%E9%A2%86%E5%8F%96%EF%BC%8C%E4%BA%A4%E6%98%93%E4%BB%A5%E5%8F%8A%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D%E4%BA%A4%E6%98%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="BTC-01-测试币的领取，交易以及多重签名交易"><a href="#BTC-01-测试币的领取，交易以及多重签名交易" class="headerlink" title="BTC-01-测试币的领取，交易以及多重签名交易"></a>BTC-01-测试币的领取，交易以及多重签名交易</h1><h2 id="0x00：前言"><a href="#0x00：前言" class="headerlink" title="0x00：前言"></a>0x00：前言</h2><p>区块链作为比特币交易的基础，是一个非常有前景的技术，值得研究(就算不做应用也可以和人吹牛或者防骗)。这里开个篇目用来记录一些比特币交易的常用知识和测试币的领取方法。</p>
<p>分享一本书，<a href="https://pan.baidu.com/s/1mX_s1Na94-0BkelTbiIReg" target="_blank" rel="noopener">《区块链:技术驱动金融》</a>(提取码SMTM),个人觉得非常好，希望能有助于各位读者学习。</p>
<p>这个系列的所有代码可以在<a href="https://github.com/TequilaWch/Blockchain-Learning" target="_blank" rel="noopener">Blockchain-Learning</a>中找到，而你的每一笔交易可以在<a href="https://live.blockcypher.com/btc-testnet/" target="_blank" rel="noopener">区块链浏览器</a>中找到(如果成功的话)。</p>
<p>涉及到的比特币脚本可以在<a href="https://en.bitcoin.it/wiki/Main_Page" target="_blank" rel="noopener">比特币维基</a>中的script部分查看相关定义。</p>
<a id="more"></a>

<h2 id="0x01：测试币的领取"><a href="#0x01：测试币的领取" class="headerlink" title="0x01：测试币的领取"></a>0x01：测试币的领取</h2><p>首先你需要一个python3的环境并且安装了python bitcoinlib库，如果没有的话你可以通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install python-bitcoinlib</span><br></pre></td></tr></table></figure>

<p>来获取这个库。之后你可以运行keygen.py文件生成一个公私钥对(包含一个address和一个privateKey，address是你的publicKey的hash值)。此后你可以通过访问<a href="https://coinfaucet.eu/en/btc-testnet/" target="_blank" rel="noopener">比特币测试网络</a>或者其他的测试币领取网站来获得一些免费的比特币(请记住，用完之后应当返回给这个测试网络，以供之后的人来使用)</p>
<p>如果获取成功，他会给你一个txid和一个address。这个txid你可以类比为钞票上的编号，唯一确定一个事务，通过txid[index]来找到是第几笔输出。而address则是你需要归还比特币的地址。</p>
<p>获取到上面这些内容后需要好好保存，同时修改config目录下的config.py，配置对应的参数。之后便可以进行下一个阶段。</p>
<h2 id="0x02：划分和简单的交易"><a href="#0x02：划分和简单的交易" class="headerlink" title="0x02：划分和简单的交易"></a>0x02：划分和简单的交易</h2><p>因为刚刚我们只领取了一个tx，而在交易过程中tx是无法拆分的，为了满足后续测试需要，应当运行SplitandPay目录下的split_test_coins.py文件，将先前的tx划分成几份(类似于换零钱)，如果你正确配置了参数，会得到一个新的txid和根据你配置的n份零钱，之后可以通过配置如下的参数来决定花费哪一份零钱。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">amount_to_send = <span class="literal">None</span><span class="comment">#需要花费的数目</span></span><br><span class="line">txid_to_spend = (</span><br><span class="line">       <span class="string">'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'</span>)</span><br><span class="line">utxo_index = <span class="literal">None</span><span class="comment">#从0到n</span></span><br></pre></td></tr></table></figure>

<p>但是记住，比如你领取到了0.0123个币，千万不要全部花出去，因为这样会导致你的交易难以被确认(关于确认交易的部分可以看那本书中的第二章)，你需要保留一定的份额作为确认这笔交易者的奖励(比如你领取到了0.0123个币，你花费0.01个币，剩下的0.0023便作为奖励，奖励越高越容易被确认)。</p>
<p>自然，划分后的txid我们也应该很好的保存起来（之前那个就没有用处了）,接下来要做的就是将其交易给之前的测试网给你的address。</p>
<p>一个最简单的比特币交易的输出为：“凭借哈希值为X的公钥，以及这个公钥所有者的签名，获得这笔资金。”这实际上就是一个最常见的比特币脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;address&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>

<p>为了确认一笔交易正确地获取了上一笔交易所输出的资金，需要把交易的输入脚本(scriptSig)和上一笔交易的输出脚本(scriptPubKey)串联，只有这个串联起来的脚本成功执行才能获取资金，串联起来的脚本如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sig&gt;</span><br><span class="line">&lt;pubKey&gt;</span><br><span class="line">--------------</span><br><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;address&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>

<p>读者可以在SplitandPay的ex1中找到对应的写法，我们来看看这个过程中做了什么。</p>
<p>这个过程实际上是个堆栈操作过程，从上往下执行(最右边是栈顶)，每次执行的结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1:NULL	| 起始状态</span><br><span class="line">2:&lt;sig&gt;	| sig压栈</span><br><span class="line">3:&lt;sig&gt;&lt;pubKey&gt;	| pubKey压栈</span><br><span class="line">4:&lt;sig&gt;&lt;pubKey&gt;&lt;pubKey&gt;	| OP_DUP复制栈顶并压栈</span><br><span class="line">5:&lt;sig&gt;&lt;pubKey&gt;&lt;pubKeyHash&gt;	| OP_HASH160将栈顶哈希并替换栈顶</span><br><span class="line">6:&lt;sig&gt;&lt;pubKey&gt;&lt;pubKeyHash&gt;&lt;pubKeyHash?&gt;	| 已知的address压栈</span><br><span class="line">7:&lt;sig&gt;&lt;pubKey&gt;	| 比较address和pubKeyHash，相等后抛弃栈顶开始的两位，不相等就终止</span><br><span class="line">8:true	| 用CHECKSIG验证签名有效，有效则true，无效则false</span><br></pre></td></tr></table></figure>

<p>其余部分详见ex1，不做详细介绍。</p>
<h2 id="0x03：多重签名交易"><a href="#0x03：多重签名交易" class="headerlink" title="0x03：多重签名交易"></a>0x03：多重签名交易</h2><p>这里假设一个情景：一共四个参与者，一位银行(bank)和三位客户(cust)，银行和三位用户共同给一笔钱上锁，需要银行和其中一位用户的签名才能解锁。</p>
<p>这个情景可以分成2个部分：先验证银行，再验证其中一位用户的签名。</p>
<p>验证银行的部分和之前的简单的一对一交易一样，不做叙述。需要说一下验证用户签名的部分。</p>
<p>N名用户对一个数据上锁，需要至少M名用户的签名才能解锁，这个方案被成为是一个M-N的多重签名方案。</p>
<p>多重签名方案需要使用一个操作码OP_CHECKMULTISIG来实现，整个上锁的脚本为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_M</span><br><span class="line">&lt;pubKey 1&gt;</span><br><span class="line">&lt;pubKey 2&gt;</span><br><span class="line">......</span><br><span class="line">&lt;pubKey N&gt;</span><br><span class="line">OP_N</span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>

<p>第一个OP_M说明了至少需要M个签名才能解锁，之后压入N个地址和一个OP_N，即一共有N个参与者。最后用OP_CHECKMULTISIG，只要有M个属于1-N的公钥对应的签名就返回true。</p>
<p>其解锁脚本为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sig 1&gt;</span><br><span class="line">&lt;sig 2&gt;</span><br><span class="line">......</span><br><span class="line">&lt;sig M&gt;</span><br></pre></td></tr></table></figure>

<p>即给出M个签名即可解锁。需要注意的是这个解锁脚本是有一些bug的。OP_CHECKMULTISIG在出栈的时候会多出栈一个元素，所以需要用OP_0来进行一个填充。</p>
<p>再回到我们的情景，是一个bank+1-3的解锁过程，不难想到应该先验证bank，因为没有bank的话有多少个用户签名也无效，再验证用户签名，所以我们的上锁脚本应该这么设计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pubKey bank&gt;</span><br><span class="line">OP_CHECKSIGVERIFY</span><br><span class="line">OP_1</span><br><span class="line">&lt;pubKey 1&gt;</span><br><span class="line">&lt;pubKey 2&gt;</span><br><span class="line">&lt;pubKey 3&gt;</span><br><span class="line">OP_3</span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>

<p>这里之所以使用OP_CHECKSIGVERIFY而不是OP_CHECKSIG，是因为如果使用OP_CHECKSIG会导致栈中有两个true，而我们只需要一个，会导致无法正常使用，而用OP_CHECKSIGVERIFY就会在验证后不把true压栈，解决这个问题。</p>
<p>而我们的解锁脚本应该是这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0</span><br><span class="line">&lt;sig cust&gt;</span><br><span class="line">&lt;sig bank&gt;</span><br></pre></td></tr></table></figure>

<p>这里面sig cust和OP_0的位置可以互换，但是bank的位置不能改变。这个同样是因为栈的关系。我们把两个脚本连起来看就很容易弄懂了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	OP_0</span><br><span class="line">2	&lt;sig cust&gt;</span><br><span class="line">3	&lt;sig bank&gt;</span><br><span class="line">4	&lt;pubKey bank&gt;</span><br><span class="line">5	OP_CHECKSIGVERIFY</span><br><span class="line">6	OP_1</span><br><span class="line">7	&lt;pubKey 1&gt;</span><br><span class="line">8	&lt;pubKey 2&gt;</span><br><span class="line">9	&lt;pubKey 3&gt;</span><br><span class="line">10	OP_3</span><br><span class="line">11	OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>

<p>能注意到3，4，5共同构成了上一个部分讲过的一对一的验证，如果sig bank和sig cust交换位置，那么就无法和pubkey bank一起通过check，整个的栈帧在执行过程中变化如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1:NULL	| 起始状态</span><br><span class="line">2:&lt;sig cust&gt;	| sig cust压栈</span><br><span class="line">3:&lt;sig cust&gt;	| OP_0不动</span><br><span class="line">4:&lt;sig cust&gt;&lt;sig bank&gt;	| sig bank压栈</span><br><span class="line">5:&lt;sig cust&gt;&lt;sig bank&gt;&lt;pubKey bank&gt;	| pubKey bank压栈</span><br><span class="line">6:&lt;sig cust&gt;	| CHECKSIGVERIFY检测通过后移除栈顶两位</span><br><span class="line">7:&lt;sig cust&gt; OP_1	| OP_1说明之前的1个参数作为需要检查的参数</span><br><span class="line">8:&lt;sig cust&gt; OP_1 &lt;pub 1&gt;&lt;pub 2&gt;&lt;pub 3&gt;	| 3个pubkey压栈</span><br><span class="line">9:&lt;sig cust&gt; OP_1 &lt;pub 1&gt;&lt;pub 2&gt;&lt;pub 3&gt;	OP_3 | OP_3说明之前的3个参数作为检查的范围</span><br><span class="line">10:true	| CHECKMULTISIG</span><br></pre></td></tr></table></figure>

<p>整个CHECKMULTISIG的过程如下：</p>
<ol>
<li>弹出OP_3，说明有N个公钥</li>
<li>弹出N个公钥</li>
<li>弹出OP_1，说明需要1个签名</li>
<li>弹出1个签名，计算是否有效</li>
</ol>
<p>至此成功解锁</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x07</title>
    <url>/2020/10/24/Compiler%E5%AD%A6%E4%B9%A0-0x07/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="编译系统原理预习作业05-刀马WCH"><a href="#编译系统原理预习作业05-刀马WCH" class="headerlink" title="编译系统原理预习作业05@刀马WCH"></a>编译系统原理预习作业05@刀马WCH</h1><h2 id="1：NFA→DFA"><a href="#1：NFA→DFA" class="headerlink" title="1：NFA→DFA"></a>1：NFA→DFA</h2><p><img src="https://i.loli.net/2020/10/24/725Z8NuDkHUarnB.png" alt="NFA到DFA.PNG"></p>
<a id="more"></a>

<h2 id="2：DFA化简"><a href="#2：DFA化简" class="headerlink" title="2：DFA化简"></a>2：DFA化简</h2><p><img src="https://i.loli.net/2020/10/24/uM8DHS1W4yzUVsm.png" alt="DFA化简.PNG"></p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络01-用流式Socket实现一个简单的聊天程序</title>
    <url>/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01-%E7%94%A8%E6%B5%81%E5%BC%8FSocket%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="用流式Socket实现一个聊天程序-刀马WCH"><a href="#用流式Socket实现一个聊天程序-刀马WCH" class="headerlink" title="用流式Socket实现一个聊天程序@刀马WCH"></a>用流式Socket实现一个聊天程序@刀马WCH</h1><p>利用Socket编写一个聊天程序</p>
<p>实验要求：</p>
<ol>
<li>给出你聊天协议的完整说明</li>
<li>利用C或C++语言，使用基本的Socket 函数完成程序。不允许使用CSocket等封装后的类编写程序。</li>
<li>使用流式Socket完成程序。</li>
<li>程序应有基本的对话界面，但可以不是图形界面。程序应有正常的退出方式。</li>
<li>完成的程序至少应能实现两个用户之间的英文和中文聊天。</li>
<li>编写的程序应结构清晰，具有较好的可读性</li>
<li>提交源码和实验准备</li>
</ol>
<a id="more"></a>

<h2 id="0x01：前期准备"><a href="#0x01：前期准备" class="headerlink" title="0x01：前期准备"></a>0x01：前期准备</h2><p>流式Socket（SOCK_STREAM）是一种面向连接的Socket，对应的是面向链接的TCP应用服务。因此我们需要编写两个程序：<strong>服务器server.c *<em>和 *</em>客户端client.c</strong>.</p>
<p>为了实现在这两个程序间进行通讯，首先需要让这两个程序建立起联系。由于是在本机实验，服务器和客户端的地址采用回送地址<strong>127.0.0.1</strong></p>
<p>连接之后，需要一些提示信息来方便使用，需要能设置和显示通话双方的身份(id)，需要能支持中英两种字符的交流，需要有一个正常的退出方式。</p>
<p>根据上述要求，准备进行c程序的编写。</p>
<h2 id="0x02：协议设计"><a href="#0x02：协议设计" class="headerlink" title="0x02：协议设计"></a>0x02：协议设计</h2><p>既然是要使用Socket编写一个流式服务器和一个流式客户端，那就得了解Socket是怎么实现服务器与客户端之间的通信的。</p>
<p>Socket是应用层和TCP/IP协议通信的中间的软件抽象层。为用户提供一组简单的接口来实现选定的协议。而流式服务器需要的是TCP协议。</p>
<p>Socket的原型为SOCKET socket(int af, int type, int protocol);通过(地址族，服务类型，使用协议)就可以确定一个Socket。要配置一个流式服务器套接字和流式客户端套接字，可以通过socket(AF_INET,SOCK_STREAM,IPPROTO_TCP)来创建所需的套接字。三个参数的含义依次是：使用TCP/IP-IPv4地址，TCP流套接字，TCP协议。</p>
<p>在TCP协议中，一个通讯过程应该遵循以下的顺序</p>
<ol>
<li>服务器端创建套接字socket()-&gt;与ip地址和端口绑定bind()-&gt;开始监听listen()-&gt;使用accept()阻塞进程直到有客户端连接。</li>
<li>客户端创建套接字socket()-&gt;使用connect()建立连接</li>
<li>客户端wirte()请求数据-&gt;服务器read()接收请求-&gt;服务器处理请求之后write()回应数据-&gt;客户端用read()接收数据</li>
<li>如果不退出，回到3.</li>
<li>客户端退出close()关闭连接-&gt;服务器read()后close()</li>
</ol>
<p>我们的协议基于上述这个通话流程进行设计，具体体现如下：</p>
<ul>
<li>通话开始前需要设置自己的用户名并发送给对方，不然无法开始通话</li>
<li>开始通话后发送设定的提示信息</li>
<li>必须由客户端先发送消息，服务器才能发回消息</li>
<li>任何一方可以通过输入 ‘bye’ 来终止通话</li>
</ul>
<h2 id="0x03：实验过程"><a href="#0x03：实验过程" class="headerlink" title="0x03：实验过程"></a>0x03：实验过程</h2><p>为服务器编写代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* server.cpp */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	把ws2_32.lib库加入到工程文件中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//	存放套接字信息的结构</span></span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	<span class="comment">//	声明两个套接字和对应的地址</span></span><br><span class="line">	SOCKET ServerSocket;</span><br><span class="line">	SOCKET ClientSocket;</span><br><span class="line">	SOCKADDR_IN ServerAddr;</span><br><span class="line">	SOCKADDR_IN ClientAddr;</span><br><span class="line">	<span class="keyword">int</span> iClientAddrLen = <span class="keyword">sizeof</span>(ClientAddr);</span><br><span class="line">	<span class="comment">//	服务器监听端口</span></span><br><span class="line">	USHORT uPort = <span class="number">12345</span>;</span><br><span class="line">	<span class="keyword">char</span> serverName[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> clientName[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> idRecvLen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> idSendLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	声明想要使用的版本为2.2</span></span><br><span class="line">	WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//	创建套接字，地址类型为AD_INET，服务类型为流式(SOCK_STREAM)，协议采用TCP</span></span><br><span class="line">	ServerSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	设置服务器地址</span></span><br><span class="line">	ServerAddr.sin_family = AF_INET;</span><br><span class="line">	<span class="comment">// hton -&gt; host to network，将主机字节序转换成网络字节序</span></span><br><span class="line">	ServerAddr.sin_port = htons(uPort);</span><br><span class="line">	ServerAddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将ServerSocket与上面的IP地址INADDR_ANY和端口号uPort绑定，此时的IP地址由系统自动分配</span></span><br><span class="line">	bind(ServerSocket, (SOCKADDR*)&amp;ServerAddr, <span class="keyword">sizeof</span>(ServerAddr));</span><br><span class="line">	</span><br><span class="line">	listen(ServerSocket, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello,server!\n\nWhat is your name?: "</span>);</span><br><span class="line"></span><br><span class="line">	gets_s(serverName);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Listening......\n"</span>);</span><br><span class="line">	</span><br><span class="line">	ClientSocket = accept(ServerSocket, (SOCKADDR*)&amp;ClientAddr, &amp;iClientAddrLen);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Success! IP:%s Port:%d\nStart chatting! You can input 'bye' to end \n\n\n"</span>,</span><br><span class="line">		inet_ntoa(ClientAddr.sin_addr), htons(ClientAddr.sin_port));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//	发送和接收用户名</span></span><br><span class="line">	idSendLen = send(ClientSocket, serverName, <span class="built_in">strlen</span>(serverName), <span class="number">0</span>);</span><br><span class="line">	idRecvLen = recv(ClientSocket, clientName, <span class="keyword">sizeof</span>(clientName), <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">strcat</span>(clientName, <span class="string">"\0"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	长寿的秘诀是保持呼吸</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s: "</span>, clientName);</span><br><span class="line">		<span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">		idRecvLen = recv(ClientSocket, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">strcat</span>(buffer, <span class="string">"\0"</span>); </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">"bye"</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buffer);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s: "</span>, serverName);</span><br><span class="line">		gets_s(buffer);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">"bye"</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			idSendLen = send(ClientSocket, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		idSendLen = send(ClientSocket, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	closesocket(ClientSocket);</span><br><span class="line">	closesocket(ServerSocket);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为客户端编写代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* client.cpp */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	SOCKET ClientSocket;</span><br><span class="line">	SOCKADDR_IN ClientAddr;</span><br><span class="line">	SOCKADDR_IN ServerAddr;</span><br><span class="line">	USHORT uPort = <span class="number">12345</span>;</span><br><span class="line">	<span class="keyword">char</span> clientName[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> IP[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> serverName[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> idRecvLen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> idSendLen = <span class="number">0</span>;</span><br><span class="line">	WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">	ClientSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello,client! \n\nWhich server you want to connect? Please input server IP: "</span>);</span><br><span class="line">	</span><br><span class="line">	gets_s(IP);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"What is your name?: "</span>);</span><br><span class="line">	</span><br><span class="line">	gets_s(clientName);</span><br><span class="line"></span><br><span class="line">	ServerAddr.sin_family = AF_INET;</span><br><span class="line">	ServerAddr.sin_port = htons(uPort);</span><br><span class="line">	ServerAddr.sin_addr.S_un.S_addr = inet_addr(IP);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Connecting......\n"</span>);</span><br><span class="line">	</span><br><span class="line">	connect(ClientSocket, (SOCKADDR*)&amp;ServerAddr, <span class="keyword">sizeof</span>(ServerAddr));	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Success! IP:%s Port:%d\nStart chatting! You can input 'bye' to end \n\n\n"</span>,</span><br><span class="line">		inet_ntoa(ServerAddr.sin_addr), htons(ServerAddr.sin_port));</span><br><span class="line">	</span><br><span class="line">	idSendLen = send(ClientSocket, clientName, <span class="built_in">strlen</span>(clientName), <span class="number">0</span>);</span><br><span class="line">	idRecvLen = recv(ClientSocket, serverName, <span class="keyword">sizeof</span>(serverName), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(serverName, <span class="string">"\0"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	���ֺ���</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s: "</span>, clientName);</span><br><span class="line">		gets_s(buffer);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">"bye"</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			idSendLen = send(ClientSocket, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		idSendLen = send(ClientSocket, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s: "</span>, serverName);</span><br><span class="line">		<span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">		idRecvLen = recv(ClientSocket, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">strcat</span>(buffer, <span class="string">"\0"</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">"bye"</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buffer);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buffer);</span><br><span class="line">	&#125;</span><br><span class="line">	closesocket(ClientSocket);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实只要实现了服务器，再实现客户端就相对简单了。两者具有很多的共同点和相对较少的差异。其差异如下：</p>
<ul>
<li>服务器需要保存自己和建立连接的客户端的套接字和地址，客户端只用保存服务器地址和自己的套接字。</li>
<li>服务器不用主动建立连接，客户端通过IP地址和服务器建立连接</li>
<li>服务器先接收后发送，客户端先发送后接收</li>
</ul>
<p>其他的socket方法参考ppt和文档，大概能弄懂。剩下的就是运行去测试了。</p>
<h2 id="0x04：实验结果"><a href="#0x04：实验结果" class="headerlink" title="0x04：实验结果"></a>0x04：实验结果</h2><p>懒得再跑一个图了，反正能使且好使。</p>
<p>但是经过多次测试，不在一个网关下是不能通讯的，估计是没有连接上互联网，所以只能在一个网络组里用。</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x06</title>
    <url>/2020/10/21/Compiler%E5%AD%A6%E4%B9%A0-0x06/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="语法分析器辅助构造工具-刀马WCH"><a href="#语法分析器辅助构造工具-刀马WCH" class="headerlink" title="语法分析器辅助构造工具@刀马WCH"></a>语法分析器辅助构造工具@刀马WCH</h1><p>这个报告不用交，就写的不太正式，主要是贴代码和自己踩过的坑。</p>
<h2 id="0x01：熟悉Bison的使用并修改讲义中的Yacc程序"><a href="#0x01：熟悉Bison的使用并修改讲义中的Yacc程序" class="headerlink" title="0x01：熟悉Bison的使用并修改讲义中的Yacc程序"></a>0x01：熟悉Bison的使用并修改讲义中的Yacc程序</h2><blockquote>
<ol>
<li>将所有的词法分析功能均放在yylex函数内实现，为+,-,*,,(,)每个运算符分别定义一个单词类别，在yylex内实现代码，能识别这些单词，并将单词类别返回给词法分析程序</li>
<li>实现功能更强的词法分析程序，可识别并忽略空格，制表符，回车等空白符，能识别多位十进制整数。</li>
<li>修改Yacc程序，不进行表达式的计算，而是实现中缀表达式到后缀表达式的转换</li>
</ol>
</blockquote>
<p>这个部分没遇到啥坑，极其简单，myacc01程序满足要求1，2；myacc02程序满足要求3。源码如下：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    &#x2F;* myacc01.y is a yacc program for lab3 one and two. code by wch *&#x2F;</span><br><span class="line">    #include&lt;stdio.h&gt;</span><br><span class="line">    #include&lt;stdlib.h&gt;</span><br><span class="line">    #ifndef YYSTYPE</span><br><span class="line">    #define YYSTYPE double</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    int yylex();</span><br><span class="line"></span><br><span class="line">    extern int yyparse();</span><br><span class="line"></span><br><span class="line">    FILE* yyin;</span><br><span class="line"></span><br><span class="line">    void yyerror(const char* s);</span><br><span class="line">    %&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER ADD SUB MUL DIV LBR RBR </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%left ADD SUB</span><br><span class="line">%left MUL DIV</span><br><span class="line">%right UMINUS</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lines	:	lines expr &#39;;&#39; &#123; printf(&quot;%f\n&quot;, $2); &#125;</span><br><span class="line">|	lines &#39;;&#39;</span><br><span class="line">|	</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr	:	expr ADD expr &#123; $$ &#x3D; $1 + $3; &#125;</span><br><span class="line">|	expr SUB expr &#123; $$ &#x3D; $1 - $3; &#125;</span><br><span class="line">|	expr MUL expr &#123; $$ &#x3D; $1 * $3; &#125;</span><br><span class="line">|	expr DIV expr &#123; $$ &#x3D; $1 &#x2F; $3; &#125;</span><br><span class="line">|	LBR expr RBR  &#123; $$ &#x3D; $2; &#125;</span><br><span class="line">|	SUB expr %prec UMINUS &#123; $$ &#x3D; -$2; &#125;</span><br><span class="line">|	NUMBER &#123; $$ &#x3D; $1; &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int yylex()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        t &#x3D; getchar();</span><br><span class="line">        if(t &#x3D;&#x3D; &#39;\n&#39; || t &#x3D;&#x3D; &#39; &#39; || t &#x3D;&#x3D; &#39;\t&#39;);</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;+&#39;)return ADD;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;-&#39;)return SUB;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;*&#39;)return MUL;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;&#x2F;&#39;)return DIV;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;(&#39;)return LBR;</span><br><span class="line">            else if(t &#x3D;&#x3D; &#39;)&#39;)return RBR;</span><br><span class="line">        else if(isdigit(t))</span><br><span class="line">        &#123;</span><br><span class="line">            yylval &#x3D; 0;</span><br><span class="line">            while(isdigit(t))</span><br><span class="line">            &#123;</span><br><span class="line">                yylval &#x3D; yylval * 10 + t - &#39;0&#39;;</span><br><span class="line">                t &#x3D; getchar();</span><br><span class="line">            &#125;</span><br><span class="line">            ungetc(t, stdin);</span><br><span class="line">            return NUMBER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;&#96;&#39;)</span><br><span class="line"></span><br><span class="line">        else return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    yyin &#x3D; stdin;</span><br><span class="line">    do&#123;</span><br><span class="line">        yyparse();</span><br><span class="line">        &#125;while(!feof(yyin));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void yyerror(const char* s)</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;Parse error: %s\n&quot;, s);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    &#x2F;* myacc02.y is a yacc program for lab3 three. code by wch *&#x2F;</span><br><span class="line">    #include&lt;stdio.h&gt;</span><br><span class="line">    #include&lt;stdlib.h&gt;</span><br><span class="line">    #include&lt;string.h&gt;</span><br><span class="line">    #ifndef YYSTYPE</span><br><span class="line">    #define YYSTYPE char*</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    char idStr[50];</span><br><span class="line">    char numStr[50];</span><br><span class="line"></span><br><span class="line">    int yylex();</span><br><span class="line">    extern int yyparse();</span><br><span class="line"></span><br><span class="line">    FILE* yyin;</span><br><span class="line">    void yyerror(const char* s);</span><br><span class="line">    %&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER ADD SUB MUL DIV ID LBR RBR</span><br><span class="line"></span><br><span class="line">%left ADD SUB</span><br><span class="line">%left MUL DIV</span><br><span class="line">%right UMINUS</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lines	:	lines expr &#39;\n&#39; &#123; printf(&quot;%s\n&quot;, $2); &#125;</span><br><span class="line">|	lines &#39;\n&#39;</span><br><span class="line">|	</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr	:	expr ADD expr &#123; $$ &#x3D; (char *)malloc(50*sizeof(char));strcpy($$,$1);strcat($$,$3);strcat($$,&quot;+ &quot;); &#125;</span><br><span class="line">|	expr SUB expr &#123; $$ &#x3D; (char *)malloc(50*sizeof(char));strcpy($$,$1);strcat($$,$3);strcat($$,&quot;- &quot;); &#125;</span><br><span class="line">|	expr MUL expr &#123; $$ &#x3D; (char *)malloc(50*sizeof(char));strcpy($$,$1);strcat($$,$3);strcat($$,&quot;* &quot;); &#125;</span><br><span class="line">|	expr DIV expr &#123; $$ &#x3D; (char *)malloc(50*sizeof(char));strcpy($$,$1);strcat($$,$3);strcat($$,&quot;&#x2F; &quot;); &#125;</span><br><span class="line">|	LBR expr RBR  &#123; $$ &#x3D; (char *)malloc(50*sizeof(char));strcpy($$,$2); &#125;</span><br><span class="line">|	NUMBER &#123; $$ &#x3D; (char *)malloc(50*sizeof(char));strcpy($$,$1);strcat($$,&quot; &quot;); &#125;</span><br><span class="line">|	ID &#123; $$ &#x3D; (char *)malloc(50*sizeof(char));strcpy($$,$1);strcat($$,&quot; &quot;); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int yylex()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        t &#x3D; getchar();</span><br><span class="line">        if(t &#x3D;&#x3D; &#39; &#39; || t &#x3D;&#x3D; &#39;\t&#39;);</span><br><span class="line">        else if(( t &gt;&#x3D; &#39;0&#39;) &amp;&amp; (t &lt;&#x3D; &#39;9&#39;))</span><br><span class="line">        &#123;</span><br><span class="line">            int ti &#x3D; 0;</span><br><span class="line">            while(( t &gt;&#x3D; &#39;0&#39;) &amp;&amp; (t &lt;&#x3D; &#39;9&#39;))</span><br><span class="line">            &#123;</span><br><span class="line">                numStr[ti] &#x3D; t;</span><br><span class="line">                t &#x3D; getchar();</span><br><span class="line">                ti++;</span><br><span class="line">            &#125;</span><br><span class="line">            numStr[ti] &#x3D; &#39;\0&#39;;</span><br><span class="line">            yylval &#x3D; numStr;</span><br><span class="line">            ungetc(t, stdin);</span><br><span class="line">            return NUMBER;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(( t &gt;&#x3D; &#39;a&#39; &amp;&amp; t &lt;&#x3D; &#39;z&#39; ) || ( t &gt;&#x3D; &#39;A&#39; &amp;&amp; t &lt;&#x3D; &#39;Z&#39;) || ( t &#x3D;&#x3D; &#39;_&#39; ))</span><br><span class="line">        &#123;</span><br><span class="line">            int ti &#x3D; 0;</span><br><span class="line">            while(( t &gt;&#x3D; &#39;a&#39; &amp;&amp; t &lt;&#x3D; &#39;z&#39; ) || ( t &gt;&#x3D; &#39;A&#39; &amp;&amp; t &lt;&#x3D; &#39;Z&#39;) || ( t &#x3D;&#x3D; &#39;_&#39; ) || (t &gt;&#x3D; &#39;0&#39; &amp;&amp; t &lt;&#x3D; &#39;9&#39;))</span><br><span class="line">            &#123;</span><br><span class="line">                idStr[ti] &#x3D; t;</span><br><span class="line">                t &#x3D; getchar();</span><br><span class="line">                ti++;</span><br><span class="line">            &#125;</span><br><span class="line">            idStr[ti] &#x3D; &#39;\0&#39;;</span><br><span class="line">            yylval &#x3D; idStr;</span><br><span class="line">            ungetc(t, stdin);</span><br><span class="line">            return ID;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;+&#39;)return ADD;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;-&#39;)return SUB;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;*&#39;)return MUL;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;&#x2F;&#39;)return DIV;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;(&#39;)return LBR;</span><br><span class="line">            else if(t &#x3D;&#x3D; &#39;)&#39;)return RBR;</span><br><span class="line">        else return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    yyin &#x3D; stdin;</span><br><span class="line">    do&#123;</span><br><span class="line">        yyparse();</span><br><span class="line">        &#125;while(!feof(yyin));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void yyerror(const char* s)</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;Parse error: %s\n&quot;, s);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x02：思考"><a href="#0x02：思考" class="headerlink" title="0x02：思考"></a>0x02：思考</h2><blockquote>
<ul>
<li>在1.2的基础上，实现功能更强的词法分析和语法分析程序，使之能支持变量，修改词法分析程序，能识别变量(标识符)和“=”符号，修改语法分析器，使之能分析，翻译“a=2”形式的赋值语句(或者更复杂“a=表达式”)，当变量出现在表达式中时，能正确获取其值进行计算(未赋值的变量取0).当然，这些都需要实现符号表功能。</li>
<li>将翻译目标改为生成汇编代码</li>
</ul>
</blockquote>
<p>写这个部分就有点让人头疼了，写了两个版本都不能很好的完成功能。</p>
<p>变量的赋值和存储比较好搞定，用一个map数据结构就可以(其实用数组就行，但是数组不好查询)；</p>
<p>第一个版本中<strong>yylval声明为double类型</strong>，在这个架构下可以正常的赋值和运算，但是变量名只能是一个字符(double类型的局限性)，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    &#x2F;* myacc03.y is a yacc program for lab3 challenge. code by wch *&#x2F;</span><br><span class="line">    #include&lt;stdio.h&gt;</span><br><span class="line">    #include&lt;stdlib.h&gt;</span><br><span class="line">    #include&lt;map&gt;</span><br><span class="line">    #ifndef YYSTYPE</span><br><span class="line">    #define YYSTYPE double</span><br><span class="line">    #endif</span><br><span class="line">    using namespace std;</span><br><span class="line"></span><br><span class="line">    map&lt;char, double&gt;syMap;</span><br><span class="line">    map&lt;char, double&gt;::iterator flag;;</span><br><span class="line">    char id;</span><br><span class="line">    int yylex();</span><br><span class="line"></span><br><span class="line">    extern int yyparse();</span><br><span class="line"></span><br><span class="line">    double assign(char id, double value);</span><br><span class="line"></span><br><span class="line">    double read(double id);</span><br><span class="line"></span><br><span class="line">    FILE* yyin;</span><br><span class="line"></span><br><span class="line">    void yyerror(const char* s);</span><br><span class="line">    %&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER ADD SUB MUL DIV EQL LBR RBR ID</span><br><span class="line"></span><br><span class="line">%left EQL</span><br><span class="line">%left ADD SUB</span><br><span class="line">%left MUL DIV</span><br><span class="line">%right UMINUS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lines	:	lines expr &#39;;&#39; &#123; printf(&quot;%f\n&quot;, $2); &#125;</span><br><span class="line">|	lines &#39;;&#39;</span><br><span class="line">|	</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr	:	expr ADD expr &#123; $$ &#x3D; $1 + $3; &#125;</span><br><span class="line">|	expr SUB expr &#123; $$ &#x3D; $1 - $3; &#125;</span><br><span class="line">|	expr MUL expr &#123; $$ &#x3D; $1 * $3; &#125;</span><br><span class="line">|	expr DIV expr &#123; $$ &#x3D; $1 &#x2F; $3; &#125;</span><br><span class="line">|	LBR expr RBR  &#123; $$ &#x3D; $2; &#125;</span><br><span class="line">|	SUB expr %prec UMINUS &#123; $$ &#x3D; -$2; &#125;</span><br><span class="line">|	NUMBER </span><br><span class="line">|	ID	      &#123; $$ &#x3D; read($1); &#125;</span><br><span class="line">|	asexpr	      </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">asexpr	:	ID EQL expr   &#123; $$ &#x3D; assign($1,$3); &#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int yylex()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        t &#x3D; getchar();</span><br><span class="line">        if(t &#x3D;&#x3D; &#39;\n&#39; || t &#x3D;&#x3D; &#39; &#39; || t &#x3D;&#x3D; &#39;\t&#39;);</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;+&#39;)return ADD;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;-&#39;)return SUB;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;*&#39;)return MUL;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;&#x2F;&#39;)return DIV;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;(&#39;)return LBR;</span><br><span class="line">            else if(t &#x3D;&#x3D; &#39;)&#39;)return RBR;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;&#x3D;&#39;)return EQL;</span><br><span class="line">        else if(isdigit(t))</span><br><span class="line">        &#123;</span><br><span class="line">            yylval &#x3D; 0;</span><br><span class="line">            while(isdigit(t))</span><br><span class="line">            &#123;</span><br><span class="line">                yylval &#x3D; yylval * 10 + t - &#39;0&#39;;</span><br><span class="line">                t &#x3D; getchar();</span><br><span class="line">            &#125;</span><br><span class="line">            ungetc(t, stdin);</span><br><span class="line">            return NUMBER;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(( t &gt;&#x3D; &#39;a&#39; &amp;&amp; t &lt;&#x3D; &#39;z&#39; ) || ( t &gt;&#x3D; &#39;A&#39; &amp;&amp; t &lt;&#x3D; &#39;Z&#39;) || ( t &#x3D;&#x3D; &#39;_&#39; ))</span><br><span class="line">        &#123;</span><br><span class="line">            yylval &#x3D; double(t);</span><br><span class="line">            return ID;</span><br><span class="line">        &#125;</span><br><span class="line">        else return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double assign(char id, double value)</span><br><span class="line">&#123;</span><br><span class="line">    syMap[id] &#x3D; value;</span><br><span class="line">    return syMap[char(id)];</span><br><span class="line">&#125;</span><br><span class="line">double read(double id)</span><br><span class="line">&#123;</span><br><span class="line">    return syMap[char(id)];</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    yyin &#x3D; stdin;</span><br><span class="line">    do&#123;</span><br><span class="line">        yyparse();</span><br><span class="line">        &#125;while(!feof(yyin));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void yyerror(const char* s)</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;Parse error: %s\n&quot;, s);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后觉得人得有更高的追求，于是把<strong>yylval改成char*类型</strong>，从而可以命名任意变量。我本来以为我要做的就是解决double和char*的转换，我真傻，真的。在编写的过程中我依次遇到了以下神奇的bug（而且每个bug都是解决上个bug后冒出来的）</p>
<ol>
<li>a op b的时候会被识别为 b op b</li>
<li>map插入的值不能被读出</li>
<li>所有变量的值都在被修改</li>
</ol>
<p>最后发现这些都是因为地址不对导致的，及其恶心，意识到用char<em>传一个地址是不可取的，于是转而投向了*</em>string**的怀抱。</p>
<p>只能说，真香(虽然此处遇到一个原先的printf输出string会乱码的问题，改用cout就没事了)。</p>
<p>最后的代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    &#x2F;* myacc03.y is a yacc program for lab3 challenge. code by wch *&#x2F;</span><br><span class="line">    #include&lt;stdio.h&gt;</span><br><span class="line">    #include&lt;stdlib.h&gt;</span><br><span class="line">    #include&lt;map&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">    #include&lt;sstream&gt;</span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">    #ifndef YYSTYPE</span><br><span class="line">    #define YYSTYPE string</span><br><span class="line">    #endif</span><br><span class="line">    using namespace std;</span><br><span class="line"></span><br><span class="line">    map&lt;string, string&gt;syMap;</span><br><span class="line">    map&lt;string, string&gt;::iterator flag;</span><br><span class="line">    char idStr[50];</span><br><span class="line">    string assign (string id,string value);</span><br><span class="line">    string read   (string id);</span><br><span class="line">    string double_to_char(double value);</span><br><span class="line">    double atof(string value);</span><br><span class="line">    string add(string a, string b);</span><br><span class="line">    string sub(string a, string b);</span><br><span class="line">    string mul(string a, string b);</span><br><span class="line">    string div(string a, string b);</span><br><span class="line">    string neg(string a);</span><br><span class="line"></span><br><span class="line">    void print_value(string a);</span><br><span class="line"></span><br><span class="line">    int yylex();</span><br><span class="line">    extern int yyparse();</span><br><span class="line"></span><br><span class="line">    FILE* yyin;</span><br><span class="line"></span><br><span class="line">    void yyerror(const string s);</span><br><span class="line">    %&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER ADD SUB MUL DIV EQL LBR RBR ID</span><br><span class="line"></span><br><span class="line">%left EQL</span><br><span class="line">%left ADD SUB</span><br><span class="line">%left MUL DIV</span><br><span class="line">%right UMINUS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lines	:	lines expr &#39;;&#39; &#123; print_value($2); &#125;</span><br><span class="line">|	lines &#39;;&#39;</span><br><span class="line">|	</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr	:	expr ADD expr &#123; $$ &#x3D; add($1, $3); &#125;</span><br><span class="line">|	expr SUB expr &#123; $$ &#x3D; sub($1, $3); &#125;</span><br><span class="line">|	expr MUL expr &#123; $$ &#x3D; mul($1, $3); &#125;</span><br><span class="line">|	expr DIV expr &#123; $$ &#x3D; div($1, $3); &#125;</span><br><span class="line">|	LBR expr RBR  &#123; $$ &#x3D; $2; &#125;</span><br><span class="line">|	SUB expr %prec UMINUS &#123; $$ &#x3D; neg($2); &#125;</span><br><span class="line">|	NUMBER	      &#123; $$ &#x3D; $1; &#125; </span><br><span class="line">|	ID	      &#123; $$ &#x3D; read($1); &#125;</span><br><span class="line">|	asexpr	      </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">asexpr	:	ID EQL expr   &#123; $$ &#x3D; assign($1,$3); &#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int yylex()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        t &#x3D; getchar();</span><br><span class="line">        if(t &#x3D;&#x3D; &#39;\n&#39; || t &#x3D;&#x3D; &#39; &#39; || t &#x3D;&#x3D; &#39;\t&#39;);</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;+&#39;)return ADD;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;-&#39;)return SUB;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;*&#39;)return MUL;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;&#x2F;&#39;)return DIV;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;(&#39;)return LBR;</span><br><span class="line">            else if(t &#x3D;&#x3D; &#39;)&#39;)return RBR;</span><br><span class="line">        else if(t &#x3D;&#x3D; &#39;&#x3D;&#39;)return EQL;</span><br><span class="line">        else if(( t &gt;&#x3D; &#39;0&#39;) &amp;&amp; (t &lt;&#x3D; &#39;9&#39;))</span><br><span class="line">        &#123;</span><br><span class="line">            char* numStr &#x3D; new char[50];</span><br><span class="line">            int ti &#x3D; 0;</span><br><span class="line">            while(( t &gt;&#x3D; &#39;0&#39;) &amp;&amp; (t &lt;&#x3D; &#39;9&#39;))</span><br><span class="line">            &#123;</span><br><span class="line">                numStr[ti] &#x3D; t;</span><br><span class="line">                t &#x3D; getchar();</span><br><span class="line">                ti++; </span><br><span class="line">            &#125;</span><br><span class="line">            numStr[ti] &#x3D; &#39;\0&#39;;</span><br><span class="line">            yylval &#x3D; numStr;</span><br><span class="line">            ungetc(t, stdin);</span><br><span class="line">            return NUMBER;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(( t &gt;&#x3D; &#39;a&#39; &amp;&amp; t &lt;&#x3D; &#39;z&#39; ) || ( t &gt;&#x3D; &#39;A&#39; &amp;&amp; t &lt;&#x3D; &#39;Z&#39;) || ( t &#x3D;&#x3D; &#39;_&#39; ))</span><br><span class="line">        &#123;	</span><br><span class="line"></span><br><span class="line">            int ti &#x3D; 0;</span><br><span class="line">            while(( t &gt;&#x3D; &#39;a&#39; &amp;&amp; t &lt;&#x3D; &#39;z&#39; ) || ( t &gt;&#x3D; &#39;A&#39; &amp;&amp; t &lt;&#x3D; &#39;Z&#39;) || ( t &#x3D;&#x3D; &#39;_&#39; ) || (t &gt;&#x3D; &#39;0&#39; &amp;&amp; t &lt;&#x3D; &#39;9&#39;))</span><br><span class="line">            &#123;</span><br><span class="line">                idStr[ti] &#x3D; t;</span><br><span class="line">                t &#x3D; getchar();</span><br><span class="line">                ti++;</span><br><span class="line">            &#125;</span><br><span class="line">            idStr[ti] &#x3D; &#39;\0&#39;;</span><br><span class="line">            yylval &#x3D; idStr;</span><br><span class="line">            ungetc(t, stdin);</span><br><span class="line">            return ID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string assign (string id,string value)</span><br><span class="line">&#123;</span><br><span class="line">    syMap[id] &#x3D; value;</span><br><span class="line">    return syMap[id];</span><br><span class="line">&#125;</span><br><span class="line">string read   (string id)</span><br><span class="line">&#123;</span><br><span class="line">    flag &#x3D; syMap.find(id);</span><br><span class="line">    if(flag !&#x3D; syMap.end())return syMap[id];</span><br><span class="line">    else return &quot;0\0&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double atof(string value)</span><br><span class="line">&#123;	</span><br><span class="line">    double num;	</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; value;</span><br><span class="line">    ss &gt;&gt; num;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string double_to_char(double value)</span><br><span class="line">&#123;</span><br><span class="line">    char* temp &#x3D; new char[50];</span><br><span class="line">    int sig &#x3D; 16;</span><br><span class="line">    gcvt(value, sig, temp);</span><br><span class="line">    string ret &#x3D; temp;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string add(string a, string b)</span><br><span class="line">&#123;</span><br><span class="line">    double val &#x3D; atof(a)+atof(b);</span><br><span class="line">    return double_to_char(val);</span><br><span class="line">&#125;</span><br><span class="line">string sub(string a, string b)</span><br><span class="line">&#123;</span><br><span class="line">    double val &#x3D; atof(a)-atof(b);</span><br><span class="line">    return double_to_char(val);</span><br><span class="line">&#125;</span><br><span class="line">string mul(string a, string b)</span><br><span class="line">&#123;</span><br><span class="line">    double val &#x3D; atof(a)*atof(b);</span><br><span class="line">    return double_to_char(val);</span><br><span class="line">&#125;</span><br><span class="line">string div(string a, string b)</span><br><span class="line">&#123;</span><br><span class="line">    double val &#x3D; atof(a)&#x2F;atof(b);</span><br><span class="line">    return double_to_char(val);</span><br><span class="line">&#125;</span><br><span class="line">string neg(string a)</span><br><span class="line">&#123;</span><br><span class="line">    double aval &#x3D; atof(a);</span><br><span class="line">    double val &#x3D; -aval;</span><br><span class="line">    return double_to_char(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_value(string a)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;&#39;\n&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    yyin &#x3D; stdin;</span><br><span class="line">    do&#123;</span><br><span class="line">        yyparse();</span><br><span class="line">        &#125;while(!feof(yyin));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void yyerror(const string s)</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;Parse error: %s\n&quot;, s);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：I LOVE COMPILER</p>
<p><img src="https://i.loli.net/2020/10/21/mZ5GIzcgYw1hQob.png" alt="1.png"></p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x05</title>
    <url>/2020/10/18/Compiler%E5%AD%A6%E4%B9%A0-0x05/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="编译系统原理预习作业04-刀马WCH"><a href="#编译系统原理预习作业04-刀马WCH" class="headerlink" title="编译系统原理预习作业04@刀马WCH"></a>编译系统原理预习作业04@刀马WCH</h1><h2 id="1：画状态转换图"><a href="#1：画状态转换图" class="headerlink" title="1：画状态转换图"></a>1：画状态转换图</h2><blockquote>
<p>尝试画正则表达式(a|b)*abb对应的状态转换图。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/18/Zv5MDF7S9uHk4wf.png" alt="IMG_0036.PNG"></p>
<a id="more"></a>

<h2 id="2：设计有限自动机"><a href="#2：设计有限自动机" class="headerlink" title="2：设计有限自动机"></a>2：设计有限自动机</h2><blockquote>
<p>设计一个不包含子串011的0，1串</p>
</blockquote>
<p>转换图如下</p>
<p><img src="https://i.loli.net/2020/10/18/XFcgl1G3xUV7wdQ.png" alt="IMG_0033.PNG"></p>
<p>其对应的五元组如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S  &#x3D;  &#123;0，1，2，3&#125; </span><br><span class="line">s0 &#x3D;  0</span><br><span class="line">F  &#x3D;  &#123;0，1，2&#125;</span><br><span class="line">Σ  &#x3D;  &#123;0，1&#125;</span><br><span class="line">δ(0,0)  &#x3D; 1, δ(1,0)  &#x3D; 1, δ(2,0)  &#x3D; 1, δ(3,0)  &#x3D; 3</span><br><span class="line">δ(0,1)  &#x3D; 0, δ(1,1)  &#x3D; 2, δ(2,1)  &#x3D; 3, δ(3,1)  &#x3D; 3</span><br></pre></td></tr></table></figure>

<h2 id="3：正则表达式→NFA"><a href="#3：正则表达式→NFA" class="headerlink" title="3：正则表达式→NFA"></a>3：正则表达式→NFA</h2><blockquote>
<p>((ε | a)b*)*</p>
</blockquote>
<p>分解下来是这样的一个正则表达式</p>
<p><img src="https://i.loli.net/2020/10/18/EzjcPsoNCL2t3a6.png" alt="IMG_0034.PNG"></p>
<p>因此由这个正则表达式生成NFA的过程如下</p>
<p><img src="https://i.loli.net/2020/10/18/m1rXWv6VZPLeJQK.png" alt="IMG_0035.PNG"></p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x04</title>
    <url>/2020/10/11/Compiler%E5%AD%A6%E4%B9%A0-0x04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="lab2–自己做个编译器-刀马WCH"><a href="#lab2–自己做个编译器-刀马WCH" class="headerlink" title="lab2–自己做个编译器@刀马WCH"></a>lab2–自己做个编译器@刀马WCH</h1><blockquote>
<p>基于上次实验的结果，我们知道了一个程序从c++到机器语言经过了怎样的过程。在这次的实验中我们要开始为自己的编译器做准备了。这次的工作比较简单，我们要做的是定义自己的C语言子集–利用上下文无关文法；以及对一个c程序编写一个等价的汇编程序实现相同的功能。</p>
</blockquote>
<p>关键词：上下文无关文法，汇编程序，c语言子集</p>
<a id="more"></a>

<h2 id="0x01-定义C语言子集"><a href="#0x01-定义C语言子集" class="headerlink" title="0x01: 定义C语言子集"></a>0x01: 定义C语言子集</h2><blockquote>
<p>你所使用的编译器支持哪些主要的C(C++)语言特性？在此基础上定义你的编译器支持的C语言子集，并用C语言描述你的C语言子集</p>
</blockquote>
<p>不管是GCC还是Visual Studio，他们基本上支持所有的C语言特性，所以轮不到我们为他操心。先为自己的C语言子集做准备吧。从最基本的东西一点点往上加，才能做出最后的成品。</p>
<ol>
<li><p>要利用C语言实现运算，首先要有变量，先从整数类型int开始</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vDec:变量声明语句; type:变量类型; idlist:变量名列表;</span><br><span class="line">vDec   → type idlist						</span><br><span class="line">type   → int</span><br><span class="line">idlist → id,idlist | id</span><br><span class="line"># VT&#x3D;&#123;int&#125;; VN&#x3D;&#123;vDec,type,idlist&#125;; S&#x3D;vDec</span><br></pre></td></tr></table></figure>
</li>
<li><p>有了变量之后还要给变量赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># asExpr:赋值表达式; expr:普通表达式; unExpr:一元表达式; biExpr:二元表达式;</span><br><span class="line"># digit:数值; num:数字;</span><br><span class="line">asExpr → id &#x3D; expr</span><br><span class="line">expr   → asExpr | unExpr | biExpr</span><br><span class="line">unExpr → digit | id</span><br><span class="line">digit  → digit num</span><br><span class="line">num    → 0 | 1 | ... | 9</span><br><span class="line"># biExpr在下一个片段说</span><br><span class="line"># VT&#x3D;&#123;id,num&#125;; VN&#x3D;&#123;asExpr,expr.unExpr,digit,biExpr&#125;; S&#x3D;asExpr</span><br></pre></td></tr></table></figure>
</li>
<li><p>biExpr中实现加减乘除模五个运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># biExpr:二元表达式; addExp:加减表达式; mulExp:乘除模表达式;</span><br><span class="line">biExpr → addExp </span><br><span class="line">addExp → addExp + mulEXP | addExp - mulExp | mulExp</span><br><span class="line">mulExp → mulExp * unExpr | mulExp &#x2F; unExpr | mulExp % unExpr | unExpr</span><br><span class="line">unExpr → digit | id</span><br><span class="line">digit  → digit num</span><br><span class="line">num    → 0 | 1 | ... | 9</span><br><span class="line"># VT&#x3D;&#123;id,num&#125;; VN&#x3D;&#123;biExpr,addExp,mulExp,unExpr,digit&#125;; S&#x3D;biExpr</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一种比较特别的单拿出来，就是关系表达式relExp和相等表达式eqExpr，实现大于小于等于逻辑关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># relExp:关系表达式; eqExpr:相等表达式;</span><br><span class="line">relExp → relExp &gt;  addExp</span><br><span class="line">	   → relExp &lt;  addExp</span><br><span class="line">	   → relExp &gt;&#x3D; addExp</span><br><span class="line">	   → relExp &lt;&#x3D; addExp</span><br><span class="line">	   → addExp</span><br><span class="line">eqExpr → relExp | eqExpr !&#x3D; relExp | eqExpr &#x3D;&#x3D; relExp</span><br><span class="line"># VT&#x3D;&#123;id,num&#125;; VN&#x3D;&#123;eqExpr,relExp,addExp&#125;; S&#x3D;eqExpr</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了正常的执行顺序，还需要一些分支语 句和循环语句来满足使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># stmt:语句</span><br><span class="line">stmt     → if(eqExpr) stmt else stmt</span><br><span class="line">stmt     → while(eqExpr) stmt</span><br><span class="line">stmt     → for(expr;eqExpr;expr) stmt</span><br><span class="line">stmt     → expr; [expr;]</span><br><span class="line"># VT&#x3D;&#123;if,while,for,else&#125;; VN&#x3D;&#123;stmt,eqExpr,expr&#125;; S&#x3D;stmt</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后还要有函数定义，这个是编程的灵魂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># fDef:函数定义语句; paralist:参数列表; pDec:参数定义; epsilon:空;</span><br><span class="line">fDef     → type fname (paralist) stmt</span><br><span class="line">paralist → paralist, pDec | pDec | epsilon</span><br><span class="line">pDec     → type id</span><br><span class="line"># VT&#x3D;&#123;id&#125;; VN&#x3D;&#123;fDef,paralist,pDec&#125;; S&#x3D;fDef</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>有了上面这些定义，应该就囊括了最基本的C语言特性了(希望如此)。初步的准备工作到此结束。</p>
<h2 id="0x02-编写一个C程序的汇编程序"><a href="#0x02-编写一个C程序的汇编程序" class="headerlink" title="0x02: 编写一个C程序的汇编程序"></a>0x02: 编写一个C程序的汇编程序</h2><blockquote>
<p>对某个C程序编写等价的汇编程序，用汇编器生成可执行程序，调试通过，能正常运行</p>
</blockquote>
<p>长期以来，编程界都认为刚接触一门新语言时，如果首先使用它来编写一个在屏幕上显示消息“Hello world!”的程序，将给你带来好运。所以我们就来写一个helloworld的x86汇编程序吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* helloworld.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello,World! \n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hello();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为这个简单的c程序编写如下的x86汇编代码myhello.s</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rodata段 储存常量</span><br><span class="line">	.section .rodata</span><br><span class="line">STR0:</span><br><span class="line">	.string &quot;Hello,World! \n&quot;</span><br><span class="line"># hello</span><br><span class="line">	.text</span><br><span class="line">	.globl hello</span><br><span class="line">	.type  hello, @function</span><br><span class="line">hello:</span><br><span class="line">#printf()</span><br><span class="line">	pushl $STR0</span><br><span class="line">	call printf</span><br><span class="line">	addl $4,%esp</span><br><span class="line">	ret</span><br><span class="line"># main</span><br><span class="line">	.text</span><br><span class="line">	.globl main</span><br><span class="line">	.type main, @function</span><br><span class="line">main:</span><br><span class="line"># hello()</span><br><span class="line">	call hello</span><br><span class="line"># return 0</span><br><span class="line">	movl $0,%eax</span><br><span class="line">	ret</span><br><span class="line"># 听从建议保留</span><br><span class="line">	.section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>

<p>通过以下命令生成一个myhello.out文件，在qemu-i386上运行，正常输出了一个helloworld，得行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc myhello.s -m32 -o myhello.out</span><br><span class="line">$ qemu-i386 myhello.out</span><br></pre></td></tr></table></figure>

<p>但是我们上面费老大劲写的这么多CFG，光写个helloworld显得我们做了很多无用功，我们编写一个包括了上面所有内容的程序torture.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* torture.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_mult</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"a+b=: %d\n"</span>,a+b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"a*b=: %d\n"</span>,a*b);</span><br><span class="line">        &#125;</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">1</span>;</span><br><span class="line">    add_mult(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己编写mytor.s如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rodata段 储存常量</span><br><span class="line">	.section .rodata</span><br><span class="line">STR0:</span><br><span class="line">	.string &quot;a+b&#x3D;: %d\n&quot;</span><br><span class="line">STR1:</span><br><span class="line">	.string &quot;a*b&#x3D;: %d\n&quot;</span><br><span class="line">	</span><br><span class="line"># 函数add_mult</span><br><span class="line">	.text</span><br><span class="line">	.globl add_mult</span><br><span class="line">	.type  add_mult, @function</span><br><span class="line">add_mult:</span><br><span class="line"># int i &#x3D; 0;</span><br><span class="line">	movl $0,%edx</span><br><span class="line"># a存到%ebx,b存到%ecx	</span><br><span class="line">	movl 4(%esp),%ebx</span><br><span class="line">	movl 8(%esp),%ecx</span><br><span class="line"># while(i&lt;2)</span><br><span class="line">	jmp  judge</span><br><span class="line">do:</span><br><span class="line">	# if(i &#x3D;&#x3D; 0)</span><br><span class="line">	cmpl $0,%edx</span><br><span class="line">	jne  p2</span><br><span class="line">	# printf(&quot;a+b&#x3D;: %d\n&quot;,a+b);</span><br><span class="line">p1:	</span><br><span class="line">	movl %ebx,%eax</span><br><span class="line">	addl %ecx,%eax</span><br><span class="line">	pushl %edx</span><br><span class="line">	pushl %eax</span><br><span class="line">	pushl $STR0</span><br><span class="line">	call printf</span><br><span class="line">	addl $8,%esp</span><br><span class="line">	popl %edx</span><br><span class="line">	jmp  inc</span><br><span class="line">	# printf(&quot;a*b&#x3D;: %d\n&quot;,a*b);</span><br><span class="line">p2:</span><br><span class="line">	pushl %edx</span><br><span class="line">	movl %ebx,%eax</span><br><span class="line">	imull %ecx,%eax</span><br><span class="line">	pushl %eax</span><br><span class="line">	pushl $STR1</span><br><span class="line">	call printf</span><br><span class="line">	addl $8,%esp</span><br><span class="line">	popl  %edx</span><br><span class="line">	# i &#x3D; i + 1;</span><br><span class="line">inc:</span><br><span class="line">	addl $1,%edx</span><br><span class="line">judge:</span><br><span class="line">	cmpl $2,%edx</span><br><span class="line">	jl   do</span><br><span class="line">	ret</span><br><span class="line"># 函数main</span><br><span class="line">	.text</span><br><span class="line">	.globl main</span><br><span class="line">	.type  main, @function</span><br><span class="line">main:</span><br><span class="line"># int a&#x3D;0,b&#x3D;1;</span><br><span class="line">	movl $0,%eax</span><br><span class="line">	movl $1,%ebx</span><br><span class="line"># add_mult(a,b)</span><br><span class="line">	pushl %ebx</span><br><span class="line">	pushl %eax</span><br><span class="line">	call  add_mult</span><br><span class="line">	addl  $8,%esp</span><br><span class="line"># return 0	</span><br><span class="line">	movl $0,%eax</span><br><span class="line">	ret</span><br><span class="line"># 听从建议保留</span><br><span class="line">	.section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>

<p>能跑出正确的结果，这个实验部分到此告一段落。</p>
<h2 id="0x03：思考"><a href="#0x03：思考" class="headerlink" title="0x03：思考"></a>0x03：思考</h2><p> 要实现一个计算机程序将C程序转化成汇编程序，应该经过这样几步：</p>
<ol>
<li>为每一种语法设计翻译规则</li>
<li>采用算法将输入的语句于语法规则匹配</li>
<li>如果某一语句没有符合的语法，弹出错误信息并终止尝试；</li>
<li>按照语法规则翻译C程序，输出生成的汇编程序</li>
</ol>
<p>编译器肯定不能只翻译一个程序，而应该把所有的这种语言写的程序给翻译了。这个时候我们需要用到语法制导翻译：根据对应的属性来生成对应的代码。</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x03</title>
    <url>/2020/09/29/Compiler%E5%AD%A6%E4%B9%A0-0x03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="编译系统原理预习作业03-刀马WCH"><a href="#编译系统原理预习作业03-刀马WCH" class="headerlink" title="编译系统原理预习作业03@刀马WCH"></a>编译系统原理预习作业03@刀马WCH</h1><h2 id="1：翻译模式设计"><a href="#1：翻译模式设计" class="headerlink" title="1：翻译模式设计"></a>1：翻译模式设计</h2><blockquote>
<p>构造翻译模式，中缀→前缀，构造<strong>9-5*2</strong>的带语义动作的语法分析树。</p>
</blockquote>
<p>构造带语义动作的产生式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr → &#123;print(&#39;+&#39;)&#125; expr + term </span><br><span class="line">	 → &#123;print(&#39;-&#39;)&#125; expr - term</span><br><span class="line">	 → term</span><br><span class="line"></span><br><span class="line">term → &#123;print(&#39;*&#39;)&#125; term * fact</span><br><span class="line">	 → &#123;print(&#39;&#x2F;&#39;)&#125; term &#x2F; fact</span><br><span class="line">	 → fact</span><br><span class="line">	 </span><br><span class="line">fact → (expr)</span><br><span class="line">	 → &#123;print(&#39;0&#39;)&#125;	0	</span><br><span class="line">	 ......</span><br><span class="line">	 → &#123;print(&#39;9&#39;)&#125; 9</span><br></pre></td></tr></table></figure>

<p>根据上面的产生式，可以制作带语义动作的语法分析树如下</p>
<a id="more"></a>

<p><img src="https://i.loli.net/2020/09/29/XkSIQBz4RiZF86J.png" alt="translatationmode.png"></p>
<h2 id="2：语法分析平凡算法"><a href="#2：语法分析平凡算法" class="headerlink" title="2：语法分析平凡算法"></a>2：语法分析平凡算法</h2><p>对下面文法，采用平凡算法分析句子 <strong>9-5+2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr → expr + term &#123;print(&#39;+&#39;)&#125;</span><br><span class="line">	 → expr - term &#123;print(&#39;-&#39;)&#125; </span><br><span class="line">	 → term</span><br><span class="line"></span><br><span class="line">term → 0	&#123;print(&#39;0&#39;)&#125;	</span><br><span class="line">	 ......</span><br><span class="line">	 → 9	&#123;print(&#39;9&#39;)&#125;</span><br></pre></td></tr></table></figure>

<p>根据平凡算法规则，我们可以给出分析过程如下(根节点为 expr)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr   → expr1 + term1 	&#123;print(&#39;+&#39;)&#125;									&#x2F;&#x2F;此时指针指向9,开始匹配</span><br><span class="line">expr1  → expr2 + term2	&#123;print(&#39;+&#39;)&#125;									</span><br><span class="line">expr2  → expr3 + term3	&#123;print(&#39;+&#39;)&#125;									&#x2F;&#x2F;失败，回溯</span><br><span class="line">	   → expr3 - term3	&#123;print(&#39;-&#39;)&#125;									&#x2F;&#x2F;失败，回溯</span><br><span class="line">	   → term4</span><br><span class="line">term4  → 9 &#123;print(&#39;9&#39;)&#125;                       							&#x2F;&#x2F;匹配成功，指针后移到 -</span><br><span class="line">expr1  → 9 &#123;print(&#39;9&#39;)&#125; + term2	&#123;print(&#39;+&#39;)&#125;							&#x2F;&#x2F;失败，‘+’和‘-’不匹配，回溯</span><br><span class="line">	   → 9 &#123;print(&#39;9&#39;)&#125; - term2	&#123;print(&#39;-&#39;)&#125;							&#x2F;&#x2F;重复之前过程 匹配成功，指针后移到 5</span><br><span class="line">term2  → 5 &#123;print(&#39;5&#39;)&#125;                        							&#x2F;&#x2F;匹配成功，指针后移到 + , expr1匹配完成</span><br><span class="line">expr   → 9&#123;print(&#39;9&#39;)&#125; - 5&#123;print(&#39;5&#39;)&#125;&#123;print(&#39;-&#39;)&#125; + term1&#123;print(&#39;+&#39;)&#125;	&#x2F;&#x2F;匹配成功，指针后移到 2</span><br><span class="line"></span><br><span class="line">term1  → 2																&#x2F;&#x2F;匹配成功，输入结束</span><br><span class="line">expr   → 9&#123;print(&#39;9&#39;)&#125; - 5&#123;print(&#39;5&#39;)&#125; &#123;print(&#39;-&#39;)&#125; + 2&#123;print(&#39;2&#39;)&#125; &#123;print(&#39;+&#39;)&#125;</span><br><span class="line">	   → 9 5 - 2 +														&#x2F;&#x2F;最终输出</span><br></pre></td></tr></table></figure>



<h2 id="3：文法改写"><a href="#3：文法改写" class="headerlink" title="3：文法改写"></a>3：文法改写</h2><p>为令下面文法可用预测分析法进行分析，将下列文法改写为<strong>非左递归文法</strong>并<strong>计算每个候选式的FIRST集</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr → expr + term &#123;print(&#39;+&#39;)&#125;</span><br><span class="line">	 → expr - term &#123;print(&#39;-&#39;)&#125; </span><br><span class="line">	 → term</span><br><span class="line"></span><br><span class="line">term → 0	&#123;print(&#39;0&#39;)&#125;	</span><br><span class="line">	 ......</span><br><span class="line">	 → 9	&#123;print(&#39;9&#39;)&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们将其合并一下，得到这样的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr → (expr (+term)|(-term)) | term</span><br><span class="line">A    → βR</span><br><span class="line">R    → αR | epsilon</span><br><span class="line">α    → (+term) | (-term)</span><br><span class="line">β    → term</span><br></pre></td></tr></table></figure>

<p>所以其非左递归文法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr → term rest</span><br><span class="line">rest → ((+term)|(-term) rest) | epsilon</span><br></pre></td></tr></table></figure>

<p>再计算候选式的FIRST集，可以得到如下结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FIRST(expr) &#x3D; &#123;term&#125;</span><br><span class="line">FIRST(rest) &#x3D; &#123;epsilon,&#39;+&#39;,&#39;-&#39;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x02</title>
    <url>/2020/09/26/Compiler%E5%AD%A6%E4%B9%A0-0x02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="What-happened？–从C-到机器语言-刀马WCH"><a href="#What-happened？–从C-到机器语言-刀马WCH" class="headerlink" title="What happened？–从C++到机器语言@刀马WCH"></a>What happened？–从C++到机器语言@刀马WCH</h1><blockquote>
<p>我们都知道输入 <strong>cout &lt;&lt; “hello world” ;</strong> 可以让机器在屏幕上显示一串 <em>hello world</em>，但是你知道为什么输入这句指令就可以得到这个结果吗？或者说，你知道在整个编译过程中，<strong>预处理器</strong>，<strong>编译器</strong>，<strong>汇编器</strong>和<strong>链接器</strong>都做了什么吗？</p>
</blockquote>
<p>关键词：<strong>编译</strong>，<strong>汇编</strong>，<strong>预处理</strong>，<strong>编程语言</strong>，<strong>机器语言</strong>，<strong>G++</strong> ，<strong>C++</strong></p>
<a id="more"></a>

<h2 id="0x00-引言"><a href="#0x00-引言" class="headerlink" title="0x00 引言"></a>0x00 引言</h2><blockquote>
<p> <em>你给我翻译翻译，什么叫做惊喜？    –张麻子《让子弹飞》</em>    </p>
</blockquote>
<p>​    这个世界上有许许多多的编程语言，经常听到的C/C++，Java，Python都是这个大家族的一份子。有的语言看起来不像人能看懂的东西，有的语言看起来好像和英语差不多，还有的语言甚至是文言文。但这些语言只要按照一定的语法规则写好，在我们配置好环境的计算机上都是可以运行的，这是为什么呢？</p>
<p>​    排除法，首先不是机器为每种语言都装了一种处理他的硬件，因为如果是这样，我们的机器将无比庞大，而不是像现在这样一个书包就能背着走。其次不是计算机很聪明，什么文字他都看得懂。那么原因只剩下了一个–有东西把这些不同语言的程序翻译成了机器能懂得的指令–机器语言</p>
<p>​    随着学习的深入，我们知道了编程语言，汇编语言和机器语言的区别，也知道了预处理器，编译器，汇编器和链接器在这个过程中的角色。在接下来的内容中，我们将在<strong>Ubuntu18.04</strong>系统中，使用<strong>G++</strong>编译器对一段简单的阶乘C++代码进行编译，探究在从编程到运行这个过程中，<em>预处理器<em>，</em>编译器<em>，</em>汇编器</em> 和 <em>链接器</em> 分别做了什么。</p>
<p>阶乘程序的源代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/* factorial.cpp */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">    <span class="keyword">int</span> i,n,f;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">    f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        f = f * i;</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在终端执行这样几条指令，可以得到不同处理阶段的文件，接下来的研究就从这些文件中入手</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行预处理，将得到的文件重定向到 factorial.u中</span><br><span class="line">$ g++ -E factorial.cpp &gt; factorial.u </span><br><span class="line">&#x2F;&#x2F; 执行预处理和编译，将得到的汇编代码存入factorial.s中</span><br><span class="line">$ g++ -S factorial.cpp </span><br><span class="line">&#x2F;&#x2F; 执行预处理，编译和汇编，将文件转换为obj形式存入factorial.o中</span><br><span class="line">$ g++ -c factorial.cpp</span><br><span class="line">&#x2F;&#x2F; 执行预处理，编译，汇编和链接，生成一个可以运行的factorial文件</span><br><span class="line">$ g++ factorial.cpp -o factorial</span><br></pre></td></tr></table></figure>

<p>执行完这些指令之后，我们可以得到这样一些文件，我们的准备工作就已经完成了。</p>
<p><img src="https://i.loli.net/2020/09/23/p7S3Nj6PMfCrcmt.png" alt="1.png"></p>
<h2 id="0x01-What-did-Preprocessor-do"><a href="#0x01-What-did-Preprocessor-do" class="headerlink" title="0x01  What did Preprocessor do"></a>0x01  What did Preprocessor do</h2><p>既然要看<strong>预处理器(Preprocessor)</strong>在这个过程中做了什么，我们自然要从.cpp文件和.u文件入手来比较。.cpp文件的代码在上一个部分已经给出，下面贴出部分.u文件的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 代码最顶部</span><br><span class="line"># 1 &quot;&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;c++&#x2F;7&#x2F;bits&#x2F;c++config.h&quot; 1 3</span><br><span class="line"># 229 &quot;&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;c++&#x2F;7&#x2F;bits&#x2F;c++config.h&quot; 3</span><br><span class="line"></span><br><span class="line"># 229 &quot;&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;c++&#x2F;7&#x2F;bits&#x2F;c++config.h&quot; 3</span><br><span class="line">namespace std</span><br><span class="line">&#123;</span><br><span class="line">  typedef long unsigned int size_t;</span><br><span class="line">  typedef long int ptrdiff_t;</span><br><span class="line"></span><br><span class="line">  typedef decltype(nullptr) nullptr_t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 251 &quot;&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;c++&#x2F;7&#x2F;bits&#x2F;c++config.h&quot; 3</span><br><span class="line">namespace std</span><br><span class="line">&#123;</span><br><span class="line">  inline namespace __cxx11 __attribute__((__abi_tag__ (&quot;cxx11&quot;))) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace __gnu_cxx</span><br><span class="line">&#123;</span><br><span class="line">  inline namespace __cxx11 __attribute__((__abi_tag__ (&quot;cxx11&quot;))) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代码最底部</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int i,n,f;</span><br><span class="line"> cin&gt;&gt;n;</span><br><span class="line"> i &#x3D; 2;</span><br><span class="line"> f &#x3D; 1;</span><br><span class="line"> while(i&lt;&#x3D;n)</span><br><span class="line"> &#123;</span><br><span class="line">  f &#x3D; f*i;</span><br><span class="line">  i &#x3D; i+1;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;f&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，原先写的C++代码除了这一句 <strong># include&lt;iostream&gt;</strong> 以外，全部放在了.u文件的末尾，那我们的  <strong># include&lt;iostream&gt;</strong>指令呢?</p>
<p>我们可以查找一下 &lt;iostream&gt; 的具体内容，不难发现他的内容和.u文件中多出来的内容一样。实际上预处理阶段所做的事情就是处理所有的预处理器指令，这类指令的特征是由 <strong>#</strong> 这个符号开头。这些指令并不罕见，除了上面的例子以外，我们还经常会遇到这些，他们都是预处理器指令的一类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;  // 接入头文件</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> F (f*i)  <span class="comment">// 宏定义指令</span></span></span><br></pre></td></tr></table></figure>

<p>不妨通过增加上面两个预处理指令到源代码中，将源代码中的 <strong>f = f * i;</strong> 语句替换成 <strong>f = F ;</strong>，再预处理生成一个新的.u文件，来比较其中的区别。我们可以发现在代码的前端没有变化，但底部变成了这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1 &quot;&#x2F;usr&#x2F;include&#x2F;c++&#x2F;7&#x2F;ctime&quot; 1 3</span><br><span class="line"># 39 &quot;&#x2F;usr&#x2F;include&#x2F;c++&#x2F;7&#x2F;ctime&quot; 3</span><br><span class="line">       </span><br><span class="line"># 40 &quot;&#x2F;usr&#x2F;include&#x2F;c++&#x2F;7&#x2F;ctime&quot; 3</span><br><span class="line"># 58 &quot;&#x2F;usr&#x2F;include&#x2F;c++&#x2F;7&#x2F;ctime&quot; 3</span><br><span class="line">namespace std</span><br><span class="line">&#123;</span><br><span class="line">  using ::clock_t;</span><br><span class="line">  using ::time_t;</span><br><span class="line">  using ::tm;</span><br><span class="line"></span><br><span class="line">  using ::clock;</span><br><span class="line">  using ::difftime;</span><br><span class="line">  using ::mktime;</span><br><span class="line">  using ::time;</span><br><span class="line">  using ::asctime;</span><br><span class="line">  using ::ctime;</span><br><span class="line">  using ::gmtime;</span><br><span class="line">  using ::localtime;</span><br><span class="line">  using ::strftime;</span><br><span class="line">&#125;</span><br><span class="line"># 3 &quot;fac2.cpp&quot; 2</span><br><span class="line"></span><br><span class="line"># 5 &quot;fac2.cpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,n,f;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    i &#x3D; 2;</span><br><span class="line">    f &#x3D; 1;</span><br><span class="line">    while(i &lt;&#x3D; n)</span><br><span class="line">    &#123;</span><br><span class="line">        f &#x3D; (f*i);</span><br><span class="line">        i &#x3D; i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样预处理器所作的操作便已经很清楚了：<strong>预处理器将原先代码中的预处理器指令先进行处理，对源代码进行格式化的处理</strong></p>
<p>其中的两种预处理器指令<strong>include</strong> 和 <strong>define</strong> 的功能也一目了然。其他的预处理指令也可以通过这种方式知道其用法，这里不深入探讨。</p>
<blockquote>
<p><strong>include</strong> 指令将引入的头文件完完全全地附加到源代码中的引入位置</p>
<p><strong>define</strong> 指令将代码中所有定义的实体替换成被定义的代码，直到它对应的 <strong>undef</strong> 指令出现为止</p>
</blockquote>
<h2 id="0x02-What-did-Compiler-do"><a href="#0x02-What-did-Compiler-do" class="headerlink" title="0x02 What did Compiler do"></a>0x02 What did Compiler do</h2><p>上一部分里我们通过对比.cpp和.u文件知道了预处理器的功能，这一部分我们将对比.u文件和.s文件比较，从而理解编译器在做什么。</p>
<p>下面是.s文件中的文本，可以看到我们的cpp程序此时已经变成了一个x86汇编语言程序(<del>越来越不像人话</del>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	.file	&quot;factorial.cpp&quot;</span><br><span class="line">	.text</span><br><span class="line">	.section	.rodata</span><br><span class="line">	.type	_ZStL19piecewise_construct, @object</span><br><span class="line">	.size	_ZStL19piecewise_construct, 1</span><br><span class="line">_ZStL19piecewise_construct:</span><br><span class="line">	.zero	1</span><br><span class="line">	.local	_ZStL8__ioinit</span><br><span class="line">	.comm	_ZStL8__ioinit,1,1</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1493:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	movq	%fs:40, %rax</span><br><span class="line">	movq	%rax, -8(%rbp)</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	leaq	-20(%rbp), %rax</span><br><span class="line">	movq	%rax, %rsi</span><br><span class="line">	leaq	_ZSt3cin(%rip), %rdi</span><br><span class="line">	call	_ZNSirsERi@PLT</span><br><span class="line">	movl	$2, -16(%rbp)</span><br><span class="line">	movl	$1, -12(%rbp)</span><br><span class="line">.L3:</span><br><span class="line">	movl	-20(%rbp), %eax</span><br><span class="line">	cmpl	%eax, -16(%rbp)</span><br><span class="line">	jg	.L2</span><br><span class="line">	movl	-12(%rbp), %eax</span><br><span class="line">	imull	-16(%rbp), %eax</span><br><span class="line">	movl	%eax, -12(%rbp)</span><br><span class="line">	addl	$1, -16(%rbp)</span><br><span class="line">	jmp	.L3</span><br><span class="line">.L2:</span><br><span class="line">	movl	-12(%rbp), %eax</span><br><span class="line">	movl	%eax, %esi</span><br><span class="line">	leaq	_ZSt4cout(%rip), %rdi</span><br><span class="line">	call	_ZNSolsEi@PLT</span><br><span class="line">	movq	%rax, %rdx</span><br><span class="line">	movq	_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@GOTPCREL(%rip), %rax</span><br><span class="line">	movq	%rax, %rsi</span><br><span class="line">	movq	%rdx, %rdi</span><br><span class="line">	call	_ZNSolsEPFRSoS_E@PLT</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	movq	-8(%rbp), %rcx</span><br><span class="line">	xorq	%fs:40, %rcx</span><br><span class="line">	je	.L5</span><br><span class="line">	call	__stack_chk_fail@PLT</span><br><span class="line">.L5:</span><br><span class="line">	leave</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE1493:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.type	_Z41__static_initialization_and_destruction_0ii, @function</span><br><span class="line">_Z41__static_initialization_and_destruction_0ii:</span><br><span class="line">.LFB1979:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	movl	%edi, -4(%rbp)</span><br><span class="line">	movl	%esi, -8(%rbp)</span><br><span class="line">	cmpl	$1, -4(%rbp)</span><br><span class="line">	jne	.L8</span><br><span class="line">	cmpl	$65535, -8(%rbp)</span><br><span class="line">	jne	.L8</span><br><span class="line">	leaq	_ZStL8__ioinit(%rip), %rdi</span><br><span class="line">	call	_ZNSt8ios_base4InitC1Ev@PLT</span><br><span class="line">	leaq	__dso_handle(%rip), %rdx</span><br><span class="line">	leaq	_ZStL8__ioinit(%rip), %rsi</span><br><span class="line">	movq	_ZNSt8ios_base4InitD1Ev@GOTPCREL(%rip), %rax</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	call	__cxa_atexit@PLT</span><br><span class="line">.L8:</span><br><span class="line">	nop</span><br><span class="line">	leave</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE1979:</span><br><span class="line">	.size	_Z41__static_initialization_and_destruction_0ii, .-_Z41__static_initialization_and_destruction_0ii</span><br><span class="line">	.type	_GLOBAL__sub_I_main, @function</span><br><span class="line">_GLOBAL__sub_I_main:</span><br><span class="line">.LFB1980:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	movl	$65535, %esi</span><br><span class="line">	movl	$1, %edi</span><br><span class="line">	call	_Z41__static_initialization_and_destruction_0ii</span><br><span class="line">	popq	%rbp</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE1980:</span><br><span class="line">	.size	_GLOBAL__sub_I_main, .-_GLOBAL__sub_I_main</span><br><span class="line">	.section	.init_array,&quot;aw&quot;</span><br><span class="line">	.align 8</span><br><span class="line">	.quad	_GLOBAL__sub_I_main</span><br><span class="line">	.hidden	__dso_handle</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>

<p>可以看到在代码的最后一段，指明了编译器，系统版本等信息，而在代码的中间有大量的类似于 <em>_GLOBAL__sub_I_main</em> 的系统函数调用。这时的程序已经很接近机器可以理解的程序了。但是此时的.s文件仍然是一个能看的文本文档，还没有真正完成他的转换。</p>
<h2 id="0x03-What-did-Assembler-do"><a href="#0x03-What-did-Assembler-do" class="headerlink" title="0x03 What did Assembler do"></a>0x03 What did Assembler do</h2><p>前面不管是.cpp还是.u还是.s文件，他们好歹是一个可以正常打开的文本文档。在经过了汇编器的处理之后，它就变成了一个学名叫做<strong>可重定位目标程序</strong>的二进制obj文件(后缀为.o)</p>
<p>当我们想用一些常规的文本编辑器打开.o文件的时候，不出意外地失败了。因为这个文件已经不是常规的文本了，他是用二进制表示的，因此我们选择16进制文本编辑器<strong>winhex</strong>来打开这个文件，就得到了下面的这个截图。</p>
<p><img src="https://i.loli.net/2020/09/24/IXx8EpgbmvQ93Ke.png" alt="3.png"></p>
<p>虽然这个东西乍一看非常的离谱，全是数字和乱码，给人的第一反应就是这东西不是人看的。但其实仔细看可以发现整个窗口分为三个部分：最左边的是<strong>Offset偏移量</strong>，它说明了二进制代码的地址相对于开头的偏移量(单位：字节)；而中间的是<strong>每一段从0到15的16个字节的具体内容</strong>，上面的数字能确定这个十六进制数的地址，下面的十六进制数就是内容，比如被选中部分的第一个十六进制数47的位置就是00000313；而最右边的是<strong>ANSI ASCII</strong>，就是winhex很尽力的把中间的内容翻译成字符的结果，我们可以通过右边找到一些关键信息，比如说被选中的这一段 <strong>GCC: (Ubuntu 7.5.0-3ubuntu1~18.04)</strong>，我们可以发现他就是上一部分中.s文件里末尾的<strong>.ident</strong>，接着往下翻也能找到更多的和之前汇编代码相同的内容。因此我们很容易就能得到以下的结果：</p>
<p>我们知道在一个汇编程序里，采用<a href="https://baike.baidu.com/item/助记符" target="_blank" rel="noopener">助记符</a>表达指令<a href="https://baike.baidu.com/item/操作码" target="_blank" rel="noopener">操作码</a>，采用<a href="https://baike.baidu.com/item/标识符/7105638" target="_blank" rel="noopener">标识符</a>表示指令<a href="https://baike.baidu.com/item/操作数/7658270" target="_blank" rel="noopener">操作数</a>，而汇编器所作的工作就是把助记符和标识符转换成机器可以理解的01指令，也就是机器语言。但是这步得到的机器语言依旧是没有办法运行的，它还不是一个合格的可执行文件–别忘了，里面还有大量的系统函数调用。</p>
<h2 id="0x04-What-did-Linker-do"><a href="#0x04-What-did-Linker-do" class="headerlink" title="0x04 What did Linker do"></a>0x04 What did Linker do</h2><p>最后的最后，为了让这个.o能编程一个合格的可执行文件，我们还需要一个叫做链接器的大宝贝。链接器通过将不同的.o文件链接在一起，从而使每个.o文件中涉及到的外部函数调用都可以被正常执行，合并在一起后的就是我们的可执行文件了。</p>
<p>在终端输入以下代码，就可以运行来看看了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;factorial</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/23/nWkxFdaL9JME3ub.png" alt="3.png"></p>
<h2 id="0x05-What-else？"><a href="#0x05-What-else？" class="headerlink" title="0x05 What else？"></a>0x05 What else？</h2><p>一个编译器的正常工作流程到这里已经是over了，如果时间倒推80年，我靠这篇文章得个奖不是问题，可惜推不得。现在的编译器除了执行这些基础的功能以外，还可以帮助我们的程序员对程序进行优化，调试，让程序自动并行化等。</p>
<p>比如说对于G++的优化选项一共有-O/-O1,-O2,-O3,-O0,-Os等几个级别，我们可以通过以下的指令来查看不同等级的优化能开启什么样的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ -Q -O --help&#x3D;optimizers  &#x2F;&#x2F; -O意味着对应的优化等级</span><br></pre></td></tr></table></figure>

<p>下面我们就用 <strong>-O1</strong> 和 <strong>-O2</strong> 来举例，观察其不同的差别。首先是节选的 -O1 启用的优化选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-faggressive-loop-optimizations 	[enabled]</span><br><span class="line">-falign-functions           		[disabled]</span><br><span class="line">-falign-jumps               		[disabled]</span><br><span class="line">-falign-labels              		[disabled]</span><br><span class="line">-falign-loops               		[disabled]</span><br><span class="line">-fassociative-math          		[disabled]</span><br><span class="line">-fasynchronous-unwind-tables 		[enabled]</span><br><span class="line">-fauto-inc-dec              		[enabled]</span><br><span class="line">-fbranch-count-reg          		[enabled]</span><br><span class="line">-fbranch-probabilities      		[disabled]</span><br><span class="line">-fbranch-target-load-optimize 	[disabled]</span><br><span class="line">-fbranch-target-load-optimize2 	[disabled]</span><br><span class="line">-fbtr-bb-exclusive          		[disabled]</span><br><span class="line">-fcaller-saves              		[disabled]</span><br><span class="line">-fcode-hoisting             		[disabled]</span><br><span class="line">-fcombine-stack-adjustments 		[enabled]</span><br><span class="line">-fcompare-elim              		[enabled]</span><br><span class="line">-fconserve-stack            		[disabled]</span><br><span class="line">-fcprop-registers           		[enabled]</span><br><span class="line">-fcrossjumping              		[disabled]</span><br><span class="line">-fcse-follow-jumps          		[disabled]</span><br><span class="line">-fcx-fortran-rules          		[disabled]</span><br><span class="line">-fcx-limited-range          		[disabled]</span><br><span class="line">-fdce                       		[enabled]</span><br></pre></td></tr></table></figure>

<p>之后是 -O2启用的优化选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-faggressive-loop-optimizations 	[enabled]</span><br><span class="line">-falign-functions           		[disabled]</span><br><span class="line">-falign-jumps               		[disabled]</span><br><span class="line">-falign-labels              		[enabled]			&#x2F;&#x2F;new</span><br><span class="line">-falign-loops               		[disabled]</span><br><span class="line">-fassociative-math          		[disabled]</span><br><span class="line">-fasynchronous-unwind-tables 		[enabled]</span><br><span class="line">-fauto-inc-dec              		[enabled]</span><br><span class="line">-fbranch-count-reg          		[enabled]</span><br><span class="line">-fbranch-probabilities      		[disabled]</span><br><span class="line">-fbranch-target-load-optimize 	[disabled]</span><br><span class="line">-fbranch-target-load-optimize2 	[disabled]</span><br><span class="line">-fbtr-bb-exclusive          		[disabled]</span><br><span class="line">-fcaller-saves              		[enabled]			&#x2F;&#x2F;new</span><br><span class="line">-fcode-hoisting             		[enabled]			&#x2F;&#x2F;new</span><br><span class="line">-fcombine-stack-adjustments 		[enabled]</span><br><span class="line">-fcompare-elim              		[enabled]</span><br><span class="line">-fconserve-stack            		[disabled]</span><br><span class="line">-fcprop-registers           		[enabled]</span><br><span class="line">-fcrossjumping              		[enabled]			&#x2F;&#x2F;new</span><br><span class="line">-fcse-follow-jumps          		[enabled]			&#x2F;&#x2F;new</span><br><span class="line">-fcx-fortran-rules          		[disabled]</span><br><span class="line">-fcx-limited-range          		[disabled]</span><br><span class="line">-fdce                       		[enabled]</span><br></pre></td></tr></table></figure>

<p>可以看到-O2是在-O1的基础上开启了新的优化选项，实际上，更高级的优化等级都是在上一级之上增加新的选项。随着编译优化等级的不断提升，可执行程序的性能也不断提升，但是这种提升是以更多的编译时间作为代价的，这也很好理解，毕竟要是没有代价的话肯定顶配拉满。</p>
<p>同时对于G++编译器而言，它在开启编译优化和没开启编译优化的工作目标也是不一样的。在<strong>没开启编译优化</strong>时，G++的目标是：<strong>减少编译时间并生成预期的结果</strong>，也就是在没有特殊要求的时候，尽快弄完，能使就好，不在乎程序质量优不优。而在开启了编译优化的时候，G++编译器的目的是：<strong>优化性能，减少大小</strong>，就像一个匠人，不光要做到能使，还要<strong>好使</strong>，还要<strong>精细</strong>，但是这就需要慢工出细活，会导致编译时间变长，同时也更难调试。</p>
<p>此外，通过以下的指令还可以生成文本格式的AST输出和中间代码多阶段的输出。在需要靠这些文件分析的时候可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;得到文本格式的AST</span><br><span class="line">$ g++ -fdump-tree-original-raw .&#x2F;***.c </span><br><span class="line">&#x2F;&#x2F;得到中间代码生成的多阶段输出，可以用graphviz可视化</span><br><span class="line">$ g++ -fdump-tree-all-graph .&#x2F;***.c</span><br><span class="line">$ g++ -fdump-rtl-all-graph .&#x2F;***.c</span><br></pre></td></tr></table></figure>

<p>至于其他的功能，比如并行化，调试等功能在此不进行介绍了(<del>篇幅实在长</del>)。最后再说说编译器的历史吧。</p>
<p>最早的编译器是1950年代，由John Backus带领的小组进行对FORTRAN语言及其编译器的开发。当时的开发工作非常的困难，因为那时候还没有语法分析的技术。这个时候出现了一位天降猛男：<strong>Noam Chomsky</strong>。</p>
<p>他对于自然语言结构的研究导致了根据语言文法的难易程度以及识别他们所需要的算法来对语言进行分类，其中包括了0,1,2,3四型文法，并且每一类型文法都是前者的一个特例。而<strong>2型文法</strong>(上下文无关文法)被证明是程序设计语言中最有用的，直到今天依旧代表程序设计语言结构的标准。</p>
<p>同时，<strong>有限状态自动机</strong>(Finite Automaton)和<strong>正则表达式</strong>(Regular Expression)同上下文无关文法紧密相关，对应着上面提到的<strong>3型文法</strong>，对他们的研究和Chomsky的研究几乎是同时开始的，由此引发了表示程序设计语言的单词的符号方式。</p>
<p>之后的人们又深化了生成有效目标代码的方法，这时便有了最初的编译器。不过虽然被称为<strong>优化技术</strong>(Optimization Technique)，但实际上从未真正的得到过被优化的目标代码，更合适的称呼应该是<strong>代码改进技术</strong>(Code Improvement Technique)。</p>
<p>这个时候分析问题便不是一个难题了，人们开始投入很大的功夫来研究编译器的自动构造，这些程序被称为<strong>编译器的编译器</strong>(Compiler-compiler),其中最著名的是 <strong>Yacc</strong>，类似的，有限状态自动机的研究也发展出了一种被称为扫描程序生成器的工具，<strong>Lex</strong>。</p>
<h2 id="0x06-结语"><a href="#0x06-结语" class="headerlink" title="0x06 结语"></a>0x06 结语</h2><p>编译器在编程中是一个非常关键的部分，如果没有编译器的存在，靠汇编指令和机器指令编写几个GB的程序无疑是让人痛苦的。计算机技术能发展到今天的模样，编译器的功劳是不可或缺的。</p>
<p>在编译器的开发和设计过程中，前人的思想是值得我们去借鉴的。比如用语义分析的方式来化简问题，用抽象的方式来简化设计，用递归的方式来减少工作量，这些都非常值得我们去学习。</p>
<p>站在巨人的肩膀上，我们能看的更远。但是不要只顾着看向远方，看看巨人们的思想同样能让我们受益匪浅。</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x01</title>
    <url>/2020/09/19/Compiler%E5%AD%A6%E4%B9%A0-0x01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="编译系统原理预习作业02-刀马WCH"><a href="#编译系统原理预习作业02-刀马WCH" class="headerlink" title="编译系统原理预习作业02@刀马WCH"></a>编译系统原理预习作业02@刀马WCH</h1><h2 id="1：CFG设计练习"><a href="#1：CFG设计练习" class="headerlink" title="1：CFG设计练习"></a>1：CFG设计练习</h2><p>设计产生式描述while语句</p>
<blockquote>
<p>while(expression)  statement</p>
</blockquote>
<p>设计产生式描述for语句</p>
<blockquote>
<p>for(expression<sub>1</sub>;expression<sub>2</sub>;expression<sub>3</sub>)  statement</p>
</blockquote>
<p>设计产生式描述变量声明语句</p>
<blockquote>
<p>int(float , double,  char) id<sub>1</sub> , id<sub>2</sub> , … ;</p>
</blockquote>
<a id="more"></a>

<p>对于这个while语句，其定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; BNF定义</span><br><span class="line">WHILE_STATEMENT ::&#x3D; &quot;while&quot; &quot;(&quot; expression|value &quot;)&quot; statement</span><br><span class="line">&#x2F;&#x2F; 产生式</span><br><span class="line">stmt → while(expr)stmt</span><br><span class="line">expr → (expr boolop expr)|value</span><br></pre></td></tr></table></figure>

<p>对于这个for语句，其定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; BNF定义</span><br><span class="line">FOR_STATEMENT ::&#x3D; </span><br><span class="line">&quot;for&quot; &quot;(&quot; (variable_declaration | (expression&quot;;&quot;)| &quot;;&quot;)[ expression ] &quot;;&quot;[ expression ]&quot;)&quot; statement</span><br><span class="line">&#x2F;&#x2F; 产生式</span><br><span class="line">stmt  	  → for(expr1;expr2;expr3)stmt</span><br><span class="line">expr1 	  → init | id | epsilon</span><br><span class="line">expr2 	  → condition | epsilon</span><br><span class="line">expr3 	  → increment | epsilon</span><br><span class="line">init  	  → int|float|double|char id &#x3D; value </span><br><span class="line">condition → (expr boolop expr)|value</span><br><span class="line">increment → id op value|id </span><br><span class="line">expr 	  → (expr op expr)|value</span><br></pre></td></tr></table></figure>

<p>对于变量声明语句，其定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; BNF定义</span><br><span class="line">DEFINE_STATEMENT ::&#x3D; &quot;int&quot;|&quot;char&quot;|&quot;float&quot;|&quot;double&quot;  &lt;id&gt;[&quot;&#x3D;&quot;][value] &#123;&quot;,&quot;id[&quot;&#x3D;&quot;][value]&#125;&quot;;&quot;</span><br><span class="line">&#x2F;&#x2F; 产生式</span><br><span class="line">stmt → int|float|double|char ids</span><br><span class="line">ids  → (ids,id)|ids|id</span><br></pre></td></tr></table></figure>

<h2 id="2：推导"><a href="#2：推导" class="headerlink" title="2：推导"></a>2：推导</h2><p>给出下面句子的推导过程并画出相应的语法分析树</p>
<blockquote>
<p>表达式如下</p>
<p><em>expr</em>     →   <em>expr + term | expr – term | term</em></p>
<p><em>term</em>    →  <em>term \</em> factor | term / factor | factor*</p>
<p><em>factor</em>  →   <strong>digit</strong> <em>| ( expr )</em></p>
<p>digit    →   0 | 1 | 2 | 3 | … | 9</p>
<p>目标句子为</p>
<p>7 - 3 * (4 + 6)</p>
</blockquote>
<p>其推导过程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr → expr - term</span><br><span class="line">	 → term - term * factor</span><br><span class="line">	 → factor - factor * (expr)</span><br><span class="line">	 → digit - digit * (expr + term)</span><br><span class="line">	 → 7 - 3 * (term + factor)</span><br><span class="line">	 → 7 - 3 * (factor + digit)</span><br><span class="line">	 → 7 - 3 * (digit + 6)</span><br><span class="line">	 → 7 - 3 * (4 + 6)</span><br></pre></td></tr></table></figure>

<p>可以绘制其语法分析树如下</p>
<p><img src="https://i.loli.net/2020/09/20/sDMdXgRFQZfuAS5.png" alt="未命名文件.png"></p>
<h2 id="3：注释语法分析树"><a href="#3：注释语法分析树" class="headerlink" title="3：注释语法分析树"></a>3：注释语法分析树</h2><p>对句子 <strong>9-5+2</strong> 给出其注释语法分析树</p>
<p>仿照样例过程，其语法规则如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr.t &#x3D; expr1.t||term.t||&quot;-&quot;</span><br><span class="line">expr.t &#x3D; expr1.t||term.t||&quot;+&quot;</span><br><span class="line">expr.t &#x3D; expr1.t||expr2.t||&quot;-&quot;</span><br><span class="line">expr.t &#x3D; expr1.t||expr2.t||&quot;+&quot;</span><br><span class="line">expr.t &#x3D; term.t</span><br><span class="line">term.t &#x3D; &quot;0&quot;|&quot;1&quot;|...|&quot;9&quot;</span><br></pre></td></tr></table></figure>

<p>根据上方的语法规则，可以给出注释语法分析树如下，得到的后缀表达式为：<strong>95-2+</strong></p>
<p><img src="https://i.loli.net/2020/09/19/nDvzYO98Ch1oUtk.png" alt="3.png"></p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler学习-0x00</title>
    <url>/2020/09/14/Compiler%E5%AD%A6%E4%B9%A0-0x00/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="编译系统原理预习作业01-刀马WCH"><a href="#编译系统原理预习作业01-刀马WCH" class="headerlink" title="编译系统原理预习作业01@刀马WCH"></a>编译系统原理预习作业01@刀马WCH</h1><h2 id="1：C语言编程和优化"><a href="#1：C语言编程和优化" class="headerlink" title="1：C语言编程和优化"></a>1：C语言编程和优化</h2><p>需要下面两个功能相同的代码谁的速度更快。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* loop 1*&#x2F;</span><br><span class="line">for(i &#x3D; 0; i &lt; n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">	a[i] &#x3D; a[i]*2000;</span><br><span class="line">	a[i] &#x3D; a[i]&#x2F;10000;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* loop 2 *&#x2F;</span><br><span class="line">b &#x3D; a;</span><br><span class="line">for(i &#x3D; 0; i &lt; n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">	*b &#x3D; *b*2000;</span><br><span class="line">	*b &#x3D; *b&#x2F;10000;</span><br><span class="line">	b++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初步判断，loop2要更快一点，因为直接对于指针进行操作，而不是loop1对偏移量操作，省略一次加法。 编写代码测试如下</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; x+1 &lt;&lt; &quot;:&quot;&lt;&lt; &quot;it is No.1 test,our n &#x3D;1000&quot; &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F; 初始化</span><br><span class="line">int a[r1];</span><br><span class="line">for (int j &#x3D; 0; j &lt; r1; j++)</span><br><span class="line">&#123;</span><br><span class="line">	a[j] &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">int *b &#x3D; a;</span><br><span class="line">CTimer timer;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; loop 1</span><br><span class="line">timer.time_in();</span><br><span class="line">for (int x &#x3D; 0; x &lt; r1; x++)&#x2F;&#x2F;为了保证数是一个int型，对示例进行了修改</span><br><span class="line">&#123;</span><br><span class="line">	a[x] &#x3D; a[x] * 10000;</span><br><span class="line">	a[x] &#x3D; a[x] &#x2F; 2000;</span><br><span class="line">&#125;</span><br><span class="line">lp11[x] &#x3D; timer.time_out() * 10000;</span><br><span class="line">cout &lt;&lt; &quot;time loop1 used:&quot; &lt;&lt; lp11[x] &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F; loop 2</span><br><span class="line">timer.time_in();</span><br><span class="line">for (int y &#x3D; 0; y &lt; r1; y++)&#x2F;&#x2F;为了保证数是一个int型，对示例进行了修改</span><br><span class="line">&#123;</span><br><span class="line">	*b &#x3D; *b * 10000;</span><br><span class="line">	*b &#x3D; *b &#x2F; 2000;</span><br><span class="line">b++;</span><br><span class="line">&#125;</span><br><span class="line">lp21[x] &#x3D; timer.time_out() * 10000;</span><br><span class="line">cout &lt;&lt; &quot;time loop2 used:&quot; &lt;&lt; lp21[x] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>其中 CTimer 是为了满足计时要求，编写的一个计时器方法，实现代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CTimer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CTimer(void);</span><br><span class="line">	~CTimer(void);</span><br><span class="line"></span><br><span class="line">	int time_in();</span><br><span class="line">	double time_out();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	LARGE_INTEGER litmp;</span><br><span class="line">	LONGLONG qt1, qt2;</span><br><span class="line">	double dft, dff, dfm;</span><br><span class="line">&#125;;</span><br><span class="line">CTimer::CTimer(void)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">CTimer::~CTimer(void)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">int CTimer::time_in()</span><br><span class="line">&#123;</span><br><span class="line">	QueryPerformanceFrequency(&amp;litmp);&#x2F;&#x2F;获得时钟频率</span><br><span class="line">	dff &#x3D; (double)litmp.QuadPart;</span><br><span class="line"></span><br><span class="line">	QueryPerformanceCounter(&amp;litmp);&#x2F;&#x2F;获得初始值</span><br><span class="line">	qt1 &#x3D; litmp.QuadPart;</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">double CTimer::time_out()</span><br><span class="line">&#123;</span><br><span class="line">	QueryPerformanceCounter(&amp;litmp);&#x2F;&#x2F;获得终止值</span><br><span class="line">	qt2 &#x3D; litmp.QuadPart;</span><br><span class="line"></span><br><span class="line">	dfm &#x3D; (double)(qt2 - qt1);</span><br><span class="line">	dft &#x3D; dfm &#x2F; dff;&#x2F;&#x2F;获得对应的时间值</span><br><span class="line"></span><br><span class="line">	return dft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后设置两层循环。内层循环分别测试当r1 = 1000|10000|100000时的情况，外层循环进行十次，记录每次的时间的一万倍以便之后求平均数。运行结果如下</p>
<p><img src="https://i.loli.net/2020/09/13/tnNvxR6Sf7eq2hi.png" alt="1.png"></p>
<p>可以发现loop1在这三种水平下都比loop2快，而且多次运行可以发现每次的运行时间并不一致，结果也会有偏差。为了获得运行更快的目标程序，应该会选loop1的方式。</p>
<p>如果需要一个更完整的测试方案，应该需要在不同的os，不同的版本，不同的编译器上测试，还要扩大测试范围（比如说1 to 100000000）且提高测试精度（比如1000 to 5000 to 10000）这样。</p>
<h2 id="2：对数据库查询表达式进行分词"><a href="#2：对数据库查询表达式进行分词" class="headerlink" title="2：对数据库查询表达式进行分词"></a>2：对数据库查询表达式进行分词</h2><p>对下面的这个查询语句进行分词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Model &#x3D; “Civic” AND Year &#x3D; “2001”</span><br></pre></td></tr></table></figure>

<p>模仿PPT中的示例，分词如下</p>
<p><img src="https://i.loli.net/2020/09/13/XHKkNmEnsJPDxdv.png" alt="2.png"></p>
<h2 id="3：静态检查"><a href="#3：静态检查" class="headerlink" title="3：静态检查"></a>3：静态检查</h2><p>创建一个test.c文件，文件代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">char firstChar1(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    return *s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int *glob;</span><br><span class="line"></span><br><span class="line">int *f(int **x)</span><br><span class="line">&#123;</span><br><span class="line">   int sa[2] &#x3D; &#123;0,1&#125;;</span><br><span class="line">   int loc &#x3D; 3;</span><br><span class="line">   glob &#x3D; loc;</span><br><span class="line">   *x &#x3D; &amp;sa[0];</span><br><span class="line">   return &amp;loc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void h(void)</span><br><span class="line">&#123;</span><br><span class="line">   unsigned int i;</span><br><span class="line">   if(i&gt;&#x3D;0)</span><br><span class="line">   &#123;</span><br><span class="line">       printf(&quot;&gt;&#x3D;0\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">       printf(&quot;&lt;0&quot;);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下载并安装静态检测工具 splint，随后打开  splint console应用。输入以下指令</p>
<blockquote>
<p>splint  目标c文件路径</p>
</blockquote>
<p>就可以开始静态检测。第一次运行的时候由于此前没有使用过c语言相关的库，没有在环境变量中找到 <em>stdio.h</em> 这个文件。将 splint自带的<em>stdio.h*文件路径添加到系统的 *INCLUDE</em> 环境变量中就可以正常执行。再次运行得到如下结果</p>
<p><img src="https://i.loli.net/2020/09/14/fJnc6TH9Mpb2ZIF.png" alt="3.png"></p>
<p>可以看到检测出了8个存在的错误。具体错误如下：</p>
<ol>
<li>类型不兼容</li>
<li>悬空引用</li>
<li>立即地址传输不一致</li>
<li>堆栈分配的存储位置*x可以由参数x访问</li>
<li>无符号值与0比较</li>
<li>变量i未定义</li>
<li>使用未声明的标识符printf</li>
<li>导出的变量未在外部使用。</li>
</ol>
<h2 id="4：递归定义"><a href="#4：递归定义" class="headerlink" title="4：递归定义"></a>4：递归定义</h2><p>在变量声明中，允许任意多个标识符形成的标识符列表，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a,b,……,x;</span><br></pre></td></tr></table></figure>

<p>用自然语言描述标识符列表的递归定义如下：</p>
<blockquote>
<p>检查 variable_list 的第一个标识符及其后面的分隔符</p>
<p>​        如果为 “,”，为此标识符分配空间并检查下一个标识符及其后面的分隔符</p>
<p>​        如果为 “;”，为此标识符分配空间并结束本次循环</p>
</blockquote>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>nku2019计算方法期末试题</title>
    <url>/2020/09/09/nku2019%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="nku2019计算方法期末试题"><a href="#nku2019计算方法期末试题" class="headerlink" title="nku2019计算方法期末试题"></a>nku2019计算方法期末试题</h1><blockquote>
<p>纯回忆版本 不全请见谅</p>
</blockquote>
<a id="more"></a>

<p>1：已知 y(n) = x<sup>n</sup> 求<br>$$<br>\bigtriangleup ^ny(n)/ \bigtriangledown ^ny(n)<br>$$</p>
<p>2：给出以下插值节点和 f(x)= 1 / (a-x)</p>
<table>
<thead>
<tr>
<th>X</th>
<th>x<sub>0</sub></th>
<th>x<sub>1</sub></th>
<th>x<sub>2</sub></th>
<th>x<sub>3</sub></th>
<th>x<sub>4</sub></th>
<th>x<sub>5</sub></th>
<th>x<sub>6</sub></th>
</tr>
</thead>
<tbody><tr>
<td>F(X)</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</tbody></table>
<p>求f[x<sub>0</sub>,x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>,x<sub>4</sub>,x<sub>5</sub>,x<sub>6</sub>]和当a=4时此表达式的值</p>
<p>3：给出以下插值节点，使用Newton法求不超过4次的插值公式f(x)的各项系数</p>
<table>
<thead>
<tr>
<th>x</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>f(x)</td>
<td>1</td>
<td>1</td>
<td>5</td>
<td>34</td>
</tr>
<tr>
<td>f<sup>‘</sup>(x)</td>
<td></td>
<td></td>
<td>8</td>
<td></td>
</tr>
</tbody></table>
<p>4：令f(x) = e<sup>x</sup>, 在[0, 1]区间上, 对于多项式系φ = {1, x}求出此区间内对f(x)的最大平方逼近,即求形如ax+b的对于f(x)的最佳逼近.</p>
<p>5：(矩阵忘了)令A为一3x3矩阵, B为一1x3向量[10, -15, 1]</p>
<p>(1) 对A进行LU分解(Doolittle分解).<br>(2) 求B的1范数, 2范数, ∞范数.<br>(3) 求L的1范数, ∞范数.<br>(4) 对L求计算2范数时的特征值方程,仅给出表达式(不要求求解).</p>
<p>6： 考虑积分近似<br>$$<br>\int_{-7h}^{7h}f(x)dx \approx Af(-7h)+Bf(0)+C(7h)<br>$$</p>
<p>求A, B, C的值使上式右部具有最大的代数精度,并求当A, B, C取此值时的代数精度.</p>
]]></content>
      <tags>
        <tag>财富密码</tag>
      </tags>
  </entry>
  <entry>
    <title>新生常见问题FAQ</title>
    <url>/2020/08/24/%E6%96%B0%E7%94%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98FAQ/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="新生常见问题-F-amp-Q"><a href="#新生常见问题-F-amp-Q" class="headerlink" title="新生常见问题 F &amp; Q"></a>新生常见问题 F &amp; Q</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于这几天发现新同学们的问题具有普遍的共性，想着或许是你们不太能从 嗷嗷的 <strong>新生入学指南</strong> 中找到需要的信息，因此我和几位同学总结了一下常见的问题和解答，应该能解答你们的大部分疑问。</p>
<p>但是，我希望你们能记得，要学会查找已有的信息。学长学姐花心思写好的文章和指南，不是为了让你们看一眼（<del>或者压根不看</del>）然后就转头就问<em>我该怎么怎么办</em>。<strong>一个合格的大学生应该有自己查找和解决问题的能力</strong>。祝大家大学生活愉快</p>
<a id="more"></a>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>以下问题排序不分先后</p>
<h6 id="1：父母能不能送进学校"><a href="#1：父母能不能送进学校" class="headerlink" title="1：父母能不能送进学校"></a>1：父母能不能送进学校</h6><p>往年可以，今年由于疫情原因不一定可以，需要等待辅导员通知，所以最好做好最差的打算–需要从西门带着行李走到南门</p>
<h6 id="2：寄快递-信件地址（只针对津南）"><a href="#2：寄快递-信件地址（只针对津南）" class="headerlink" title="2：寄快递/信件地址（只针对津南）"></a>2：寄快递/信件地址（只针对津南）</h6><p><strong>快递：</strong>天津市 津南区 海河教育园区 同砚路38号南开大学 文/理科组团</p>
<p><strong>信件：</strong>天津市 津南区 海河教育园区 同砚路38号南开大学 文/理科组团 xx宿舍 xxx</p>
<p><strong>邮编：</strong>300350</p>
<h6 id="3：电脑"><a href="#3：电脑" class="headerlink" title="3：电脑"></a>3：电脑</h6><p>看文章看文章，在这个网站左侧点击 <strong>标签</strong>-》<strong>杂文</strong>就能看到相关的两篇指南</p>
<h6 id="4：分学院分专业"><a href="#4：分学院分专业" class="headerlink" title="4：分学院分专业"></a>4：分学院分专业</h6><p>今年由于是非常特殊的大类招生，政策不确定。往年是入校分学院，学院内部大一下分</p>
<h6 id="5：怎么去学校"><a href="#5：怎么去学校" class="headerlink" title="5：怎么去学校"></a>5：怎么去学校</h6><p>路线太长了，同样是在这个网站左侧点击 <strong>标签</strong>-》<strong>杂文</strong>-》<strong>新生入学指南</strong>，进入文章后看<strong>第一部分的第22小节 交通</strong></p>
<h6 id="6：能不能提前进宿舍"><a href="#6：能不能提前进宿舍" class="headerlink" title="6：能不能提前进宿舍"></a>6：能不能提前进宿舍</h6><p>应该不能</p>
<h6 id="7：关于二次选拔"><a href="#7：关于二次选拔" class="headerlink" title="7：关于二次选拔"></a>7：关于二次选拔</h6><p>入校考试发生在军训期间，考数学和英语。这项成绩只有两个影响：1是如果你要报考伯苓班/特色班的话，需要看你的成绩；2是如果你们是入校就分学院的话，要看你的成绩，成绩高的能优先选择；对于其他情况没有影响，就算考0分也没事。</p>
<p>入校考试的难度大概是全国卷难度，英语没有听力，可能会涉及到部分高数内容。</p>
<p>没有原题，没有题型。如果想要备考，建议看看高考内容就行。</p>
<p>但是更建议享受一个快乐的假期</p>
<h6 id="8：军训"><a href="#8：军训" class="headerlink" title="8：军训"></a>8：军训</h6><p>军训挺累的，但也很快乐，持续两周左右。</p>
<p>军训期间晚上不查寝，不允许挂蚊帐和床帘。军训的仪容仪表在嗷嗷的那篇文章中有些，再不看打死。</p>
<p>军训可以选择加入政工组，起得更早睡得更晚，做服务保障工作和新闻推送工作，但是不用参加早上和下午的训练//晨练和晚训要参加。</p>
<p>军训分数教官给，不要皮</p>
<p>军训期间的防晒工作等也可以看嗷嗷的那篇文章。</p>
<h6 id="9：行李箱"><a href="#9：行李箱" class="headerlink" title="9：行李箱"></a>9：行李箱</h6><p>学校不限制，能进门就行。飞机可能会限制托运大小。</p>
<h6 id="10：男女比例"><a href="#10：男女比例" class="headerlink" title="10：男女比例"></a>10：男女比例</h6><p>男接近6.5吧emmm，没有统计过，因为没啥用。</p>
<p>首先人眼光要长远，学校里这么多学院，天津这么多学校，中国那么多省，都能找，不用局限一个学院。</p>
<p><del>其次银行里的金条再多，和你有关系吗</del></p>
]]></content>
      <tags>
        <tag>恶魔的轻语闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>写给新生：如何挑选电脑</title>
    <url>/2020/08/20/%E5%86%99%E7%BB%99%E6%96%B0%E7%94%9F-%E5%A6%82%E4%BD%95%E6%8C%91%E9%80%89%E7%94%B5%E8%84%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="写给新生：如何挑选电脑"><a href="#写给新生：如何挑选电脑" class="headerlink" title="写给新生：如何挑选电脑"></a>写给新生：如何挑选电脑</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每年的新生入校前，除了被问学校的环境如何以外，问得最多的一个问题就是：我是xxx专业的，我要不要买电脑，电脑买什么样的好，有没有什么推荐？</p>
<p>由于电脑其实是一个很个性化的东西，没有哪个学长学姐能给你一个确切的说法，因此我打算通过这篇文章，为新生们普及一下选电脑的原则和方式。当然这只是我一家之言，有其他建议的朋友可以在评论区留言。首先我们要记住<del>艾斯比奥特曼</del>选电脑的五大准则</p>
<blockquote>
<ol>
<li>电脑是一种用途广泛的学习工具，不管是不是计算机专业的都建议购买</li>
<li>电脑不要在电脑城买！购买优先级 京东&gt;淘宝&gt;官方实体店&gt;闲鱼&gt;电脑城</li>
<li>抛开价位谈推荐及其不现实，如果真的需要学长学姐给推荐电脑，一定要说好预期价位</li>
<li>不要想着上了大学我必不可能玩游戏，只要有玩游戏的可能就尽量往好的配置选，不然后悔莫及</li>
<li>3000的台式性能可能比6000的本还好</li>
</ol>
</blockquote>
<p>下面我们就这这些经典问题进行分节讨论，请确认自己记住了上面的五大准则再往下看</p>
<a id="more"></a>

<h2 id="要不要买电脑"><a href="#要不要买电脑" class="headerlink" title="要不要买电脑"></a>要不要买电脑</h2><p>数字化时代了，真的，电脑是一个很重要的东西。微信朋友圈各种插入的python教程广告还不足以证明吗？即便你不是计算机专业的，只要你参加学生社团或者学生部门，你在以后的日子里总会遇到包括但不局限于 <strong>视频剪辑/图片处理/PPT制作/论文查重/文件传输</strong> 等一系列使用电脑会非常容易的事务。就比如今年的疫情让你不得不上网课，拿个电脑屏幕也比手机大啊。</p>
<p>退一万步讲你都不参加，你总要上课吧，你上课总要写论文吧，你还想动辄手写3k-1w字的论文不成？而且据我了解，很多学校都对非计算机专业的学生有计算机二级证的要求，弄台电脑你也好学啊是不是。</p>
<p>如果你是计算机专业的，还问要不要买电脑，把头伸过来我给你上点buff。</p>
<h2 id="电脑买什么样的好"><a href="#电脑买什么样的好" class="headerlink" title="电脑买什么样的好"></a>电脑买什么样的好</h2><p>大学中常见的电脑配置有这几种：</p>
<blockquote>
<ol>
<li>游戏本(优点：性能好，满足玩游戏需求，满足办公需求。缺点：贵，重)</li>
<li>轻薄本(优点：便宜，轻便，易于携带，满足大部分办公需求。缺点：玩游戏就是铁板烧，为了轻薄会削减配置)</li>
<li>轻薄游戏本(优点：名字好听。缺点：既不游戏，还不轻薄，还贵)</li>
<li>轻薄本+台式(优点：寝室里可以玩游戏，办公时可以随身带。缺点：贵，麻烦，回家不方便，占地方)</li>
</ol>
</blockquote>
<p>从价位而言，一台好一点的游戏本大概在6K-8K左右，一台能满足使用的轻薄本大概在3K-5K左右，台式机的话看自己的配置决定价钱。我们举一个轻薄本和一个游戏本的例子来说明。<em>斜体内容是对价格影响较大的因素</em></p>
<table>
<thead>
<tr>
<th>名称</th>
<th><em>CPU</em></th>
<th><em>内存</em></th>
<th><em>显卡</em></th>
<th>刷新频率</th>
<th><em>固态</em></th>
<th>机械</th>
<th>屏幕</th>
<th>类型</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td>惠普暗影精灵5</td>
<td>i7-9750H</td>
<td>16G</td>
<td>GTX1650 4G独显</td>
<td>144HZ</td>
<td>512G</td>
<td>1T</td>
<td>15.6</td>
<td>游戏本</td>
<td>7799</td>
</tr>
<tr>
<td>华为MateBook D14</td>
<td>AMD</td>
<td>16G</td>
<td>AMD 集显</td>
<td>60HZ</td>
<td>512G</td>
<td>无</td>
<td>14.0</td>
<td>轻薄本</td>
<td>4088</td>
</tr>
</tbody></table>
<p>看出区别了吗？轻薄本为了满足轻薄的要求，舍弃掉了沉重的机械硬盘，同时整体大小也比游戏本要小。由于不需要满足游戏功能，在显卡，CPU还有他没给出的散热以及电池方面都不如游戏本。削减掉这些配置带来的是轻，薄还有相对便宜的价格。</p>
<p>而游戏本的配置就突出一个满足游戏体验，采用业界最新的配置就是为了紧跟游戏不断提升的配置要求，1T的机械硬盘可以存储8个《荒野大镖客2：救赎》(116G)，满足你的使用需求。同时为了保证性能，其风扇和电池都比轻薄本要好得多。往上添加这么多东西就导致游戏本是真的贵且重，不是猛汉的计算机专业学生建议酌情考虑，因为你会频繁的背着电脑到处跑。</p>
<p>对于计算机专业的学生，在早期的学习中轻薄本足以满足使用需求。但是当你们写的工程越来越大，算法越来越复杂，配置较差的轻薄本在运行时可能会非常揪心甚至黑屏，因此我建议别图便宜，就算是弄轻薄本，咱也搞个好点的。</p>
<p>轻薄本加台式的配置，轻薄本在上面说的有。台式建议去 <strong>图吧</strong> 以及 <strong>卡吧</strong> 了解一些，虽然破烂佬很多，但是对配置的了解确实有一手。</p>
<h2 id="有没有什么推荐"><a href="#有没有什么推荐" class="headerlink" title="有没有什么推荐"></a>有没有什么推荐</h2><p>给你一个大概的门类，没有上榜不代表不推荐，只是没见过</p>
<blockquote>
<ul>
<li>轻薄本：华为，小米，联想，苹果，戴尔(虽然我周围用的人都在骂)，神舟，惠普。              //其实大厂基本都有一手轻薄本</li>
<li>游戏本：惠普暗影精灵/光影精灵，联想拯救者，戴尔游匣，神舟战神，机械革命深海幽灵，小米游戏本(基于个人使用体验)</li>
</ul>
</blockquote>
<p>中意哪个就去看哪个吧，我也不是富家子弟，没都用过hhh。也可以看看评论区老哥的说法。</p>
<h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>我身边有苦于电脑存储不够的，每次要装新东西得删很多东西的人，也有一台老电脑顶到现在的人。买电脑的时候一定要考虑清楚了自己需要什么的功能，可能会出现什么样的状况，不然就只能追悔莫及。</p>
<p>以上内容仅属于<a href="https://github.com/TequilaWch" target="_blank" rel="noopener">刀马WCH</a>(邮箱<a href="mailto:BattleWCH@163.com">BattleWCH@163.com</a>)的个人见解，如有不当感谢指正。</p>
]]></content>
      <tags>
        <tag>恶魔的轻语闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>2020新生指南-转载自大胖嗷子</title>
    <url>/2020/08/17/2020%E6%96%B0%E7%94%9F%E6%8C%87%E5%8D%97-%E8%BD%AC%E8%BD%BD%E8%87%AA%E5%A4%A7%E8%83%96%E5%97%B7%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2020新生指南"><a href="#2020新生指南" class="headerlink" title="2020新生指南"></a>2020新生指南</h1><p>本文转载自我的好哥们大胖嗷子，我希望能提供更多样的平台让大家能看到。不止是2020年新生，也不止是南开大学的新生，相信大家都能从中了解到自己所想了解的一切。文末附带他的个人公众号嗷范特西Zone的二维码，希望大家多多关注。大学生活愉快！</p>
<blockquote>
<p>​    首先，欢迎20级的学弟学妹来到南开大学学习和生活！</p>
<p>​    2020新生指南在学长学姐编写的18、19新生攻略的基础上增添了一些细节，并依据政策和环境的变化进行了更新，作为2020年入学的学弟学妹们生活、学习等方面的一个参考。</p>
<p>​    这些也只是我们根据自己的生活、学习经历总结出的一些经验和教训而已，一定要清楚的就是，这些经验和教训是基于“我们”（参与编写新生攻略和指南的学长学姐们）的生活和学习总结出来的，虽然我们都在南开大学学习和生活，但毕竟个人经历不同，以及现在时代也在飞速变化和发展、各种政策和体制层面的改革不断，<strong>也许有些事情，到了你们这里已经不那么适用了</strong>，这一点，还请各位学弟学妹们能够带着批判性的目光阅读此新生指南。</p>
<p>​    当然，新生指南中的内容还是经过多方的咨询、讨论和研究，最终总结而成的，我们认为对各位能够真正有所帮助的建议和经验，由于官方可能很少给出这种特别详细的介绍，所以今年我（大胖嗷子）也决定将这个新生指南广泛地传播出去。</p>
<p>​    以后，当然也希望能够坚持下去。</p>
<p>​    但我入校以来，大多时候在<strong>津南校区</strong>（新校区）学习和生活，为了更好地编写<strong>八里台校区</strong>（老校区）部分的指南，我特地邀请了嘉皮同学和我共同编写。</p>
<p>​    我是2018年考入南开计算机类，现就读于网络空间安全学院；嘉皮于2019年考入南开大学的中国语言文学类，现就读于文学院。我们在编写2020招生指南的过程中也咨询了很多不厌其烦地接受我们的采访和提问的同学们，在此一并向他们致以诚挚的谢意。</p>
<p>​    我们很荣幸，今年同在南开大学招生组做志愿者，并因此相识。我们知道，今年来到南开园的你们当中，不乏高考发挥失常，与理想的高校失之交臂的；亦不乏“超常发挥”、欣喜若狂，其实是努力终有回报而顺利考入南开的。也有一些学弟学妹——本就带着“学长，想好了，还是选南开！非常希望成为南开再度崛起的见证者，更荣幸即将成为这一过程的建设者！”的愿望和理想，来到了南开。无论你是哪一种，我们都想对你讲两点事情：</p>
<p>​    第一，南开不会让你失望，这里，就是你想象中大学的样子，这里，只要你积极、善良、乐观，你的生活就是幸福的。南开给你提供的机会足够多，就看你能否把握住了。</p>
<p>​    第二，不要用你的现在侮辱你的未来，永远不要觉得人生一辈子就这样了。如果没有相信的勇气，那真的，你就不可能成就更好的自己。</p>
<p>​    我们所爱之人和事，或许在别人眼里皆是平凡，是我们的喜爱为其增添了别样的色彩——所以有很多时候，外界的声音都是参考，你不开心了，就不必参考，这个新生指南也一样。</p>
<p>​    愿你们在大学和以后的日子里，保持善良温婉之心，有事做，有人爱，有所期待。</p>
<div style="text-align: right"> 大胖嗷子，嘉皮  </div>

<div style="text-align: right"> 写于2020年 </div>
</blockquote>
<p><em>WCH：由于文章真的太长了（Respect）我有对其进行过省略处理，完整内容见公众号。所有斜体字均为我个人添加</em></p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>注意：本新生指南中<strong>学子卡</strong>=<strong>一卡通</strong>，指可用于洗浴、吃饭等的电子卡。</p>
<p><strong>太平洋学子卡</strong>指的是学校每年为本科生统一下发的<strong>交通银行卡</strong>，应与一卡通有所区分</p>
<h3 id="一：生活"><a href="#一：生活" class="headerlink" title="一：生活"></a>一：生活</h3><h4 id="1：宿舍"><a href="#1：宿舍" class="headerlink" title="1：宿舍"></a>1：宿舍</h4><p>​    津南校区每学年的宿舍费是1200元。八里台校区为700-1200元不等。</p>
<p>​    <strong>津南校区</strong>的宿舍宽敞舒适，<strong>上床下桌</strong>，上床有小楼梯，储物柜充足（独立书桌有抽屉和柜子，有独立的大衣柜，绝大多数宿舍还在门后设有小型储物柜）。</p>
<p>​    有一个小阳台，阳台设有窗户，且与宿舍有一道门阻隔，夏天屋里开着空调，阳台仍可以开窗通风（衣服干得快），非常人性化，有晾衣杆，自己准备好衣架。（晾衣杆很高，需要辅助工具）</p>
<p>​    <strong>没有独立卫浴</strong>，省去了扫厕所的麻烦；每层楼设有公共洗浴间和洗手间，有物业保洁的阿姨专门打扫。</p>
<p>​    <strong>洗浴间有隔间，没有门</strong>（当然这个对于东北的孩儿来说都不是事儿），24小时热水，后面会详细介绍洗浴的相关事宜。</p>
<p>​    空调、暖气每个宿舍都有，空调需要另交租金，一般就把四年的一起都租了，具体去哪里缴费到时候宿管阿姨会告诉大家。平均下来每个人四年也就几百块钱。</p>
<p>​    <strong>八里台校区</strong>的话，宿舍一般是4-6人间，<strong>上下铺</strong>的，但有配备桌子。由于宿舍本身的面积问题（有些楼都是文物级别的了），储物的地方相对少了一些，但也基本够用。可惜不能保证每间宿舍都有阳台了，晾衣服、晒被子可能麻烦点，一般都是晾在每层楼的公共水房中所有能看到杆儿的地方（甚至门把手）。有些宿舍五楼的水房有一个通向外面的阳台，采光相对更好一些，可以用来晒被子（注意春秋风大的时候，加以固定，不然你亲爱的被子可能扑街）。</p>
<p>​    洗浴，是统一去浴园（类似于大澡堂，但据说有隔间的那种），浴园有营业时间限制，需要注意一下。现在由于是疫情防控仍不可放松的阶段，浴园的最新开放时间（截至2020年8月8日，新生入学后大概率还会调整，具体请关注“<strong>南开大学后勤保障服务</strong>”公众号，获取最新消息）为每日15:30至22:30，且为分时段预约洗浴模式。</p>
<p>​    2019年开始所有宿舍都陆续安装了空调，现在已经全都安上了；暖气也可以保证每个宿舍都有，起码冬暖夏凉能保证了。具体的租赁事宜还是听宿管阿姨安排就好。</p>
<h4 id="2：洗浴"><a href="#2：洗浴" class="headerlink" title="2：洗浴"></a>2：洗浴</h4><p>​    <strong>津南校区</strong>每层楼都设有洗浴间，24小时热水，洗澡时需要插入一卡通计费使用。本科生收费标准是<strong>1元/4分钟</strong>（没错，按时间收费，不是按流量。</p>
<p>​    当一卡通接触到机器的感应区时就会开始扣费，从一元钱往下扣：0.98、0.95、0.93、0.9、0.88、0.85、0.83、0.8……所以在你不用水的时候，<strong>把卡拔出来再插进去可以停止计费</strong>，然后再次插入时会重新从一元钱开始扣费；否则就不会停止计费，直到过了4分钟。很多人不知道拔卡再插入可以停止计费，手忙脚乱地洗，就很尴尬。（<del>你猜我怎么知道的</del>）</p>
<p>​    离开的时候，<strong>记得拿好自己的卡！洗澡前确定卡里有足够的钱！</strong></p>
<p>​    <strong>八里台校区</strong>的浴园，大致流程如下：</p>
<p>​    1.在一楼排队拿到手牌，也就是各个区域的储物柜钥匙，男生上二楼，女生上三楼，先找到自己的分区(abcedf)，再拿手牌上的“钥匙”卡入柜子的凹槽中，使劲摁一下就可以打开了(不太好描述，第一次打不开不要不好意思，找个学长/学姐问一下就好了)（<del>嘉皮：我才不告诉你当时我就没打开</del>）</p>
<p>​    2.在柜子里存放好衣物，锁好，带好手牌进入淋浴区，找一个隔间就可以洗澡啦！</p>
<p>​    3.在每一个隔间的墙上都有放置一卡通的计费装置，把一卡通放在里面，淋浴头会出水并计费，把一卡通拿出来再放入第二次的时候会停水并停止计费(<strong>中途可以多次停止哟，不要浪费水资源还有浪费钱</strong>)。这个和津南校区洗浴间的道理是一样的。</p>
<p>​    4.注意事项：淋浴头有几率突然停止出水，换一个再放一卡通就可以了，<strong>走的时候不要忘记拿一卡通！！！一定提前确定一卡通里有足够的钱！！！</strong>（一卡通相关事宜后面会有详细介绍）</p>
<h4 id="3：饮水"><a href="#3：饮水" class="headerlink" title="3：饮水"></a>3：饮水</h4><p>​    <strong>津南校区</strong>宿舍的每层楼都有至少一台饮水机（直饮水），新生入学时需要去指定地点办一张专门的水卡（水卡不同于吃饭洗浴用的一卡通），水卡的充值和挂失也在同一个地方——学5B和5C宿舍之间的门洞里，在5B楼的侧面，有一个小楼梯，一楼，就是办水卡的地方。直饮水有常温和热水两种，插卡出水，拔卡停止出水。水卡有多充多送的政策，比如冲500送100，而且可以随时把这个钱退出来（当然赠送的100是不能退的，比如你喝了80块钱的水，退出的钱就是500；喝了150块钱的，退出的就是450块钱）大家可以根据需要充值。</p>
<p><strong>八里台校区</strong>每个宿舍的一楼都有饮水机，有热水和凉水，支付宝付款，偶尔还有优惠活动；如果分到了那种三四栋楼连在一起的宿舍，其中一栋楼里还有免费的热水，但需要从楼外走过去，很有一种历史的厚重感（<del>bushi</del>）。学校每年都会对水质进行两次的彻底检验，每周也会有专员来宿舍检测水质，饮水系统滤芯每学期都会更换，饮用水没有异味，质量大可放心。</p>
<h4 id="4：洗衣"><a href="#4：洗衣" class="headerlink" title="4：洗衣"></a>4：洗衣</h4><p>​    <strong>津南校区</strong>宿舍的每层楼都有至少两台洗衣机，下载“U净”APP，每次扫描洗衣机上的二维码就可以洗衣了。收费标准分三档（根据时间和水量），2.5、3.5、4.5元，时间分别是25、35、45分钟。理科商业街也有一家洗衣店，提供干洗、大件衣物的洗涤等服务。<br>6<br>​    <strong>八里台校区</strong>每层楼的公共水房里有洗衣间，里面有几个洗衣机，使用手机支付，按流程操作即可。需要手洗的衣服，带着盆去公共水房洗就好了</p>
<h4 id="5：购物"><a href="#5：购物" class="headerlink" title="5：购物"></a>5：购物</h4><p>​    <strong>津南校区</strong>理科、文科商业街各设有超市，理科商业街的是著名的711便利店，其出售的饭团、好炖（不纯正的关东煮）和包子烧卖等堪称南开学子早餐和宵夜的救命稻草（都是起晚了要迟到的或者懒得去食堂排队的），也会有很多“高档”的、用微波炉热一热就能吃的便当之类的，味道还不错，就是分量不大，价格偏贵。总之，711给人的感觉很高大上，东西都很精致，规模比较小，相应就会贵一些。那么文科的世纪华联超市就非常的接地气了——要啥有啥，曲别针、图钉、彩带、气球、小型霓虹灯、钳子，都有（别问我怎么知道的）。而且东西的话相对没有那么贵，所以一般需要生活用品的话，都是去华联买的比较多。</p>
<p>​    当然，不要忘了网购！<strong>津南校区</strong>所有的<strong>非信件类快递地址</strong>都写下面这个：</p>
<blockquote>
<p>天津市津南区海河教育园区同砚路38号南开大学新校区文科/理科组团邮编：300350</p>
</blockquote>
<p>​    快递不能直接送到宿舍楼或学院楼，都是近邻宝代收，微信搜索“近邻宝”公众号并关注，就可以收到快递到达的提醒！</p>
<p>​    也有很多人在家里买好之后邮过来（一般都是棉被、褥子之类的），也写这个地址就可以！到时候会有人打电话或微信公众号/短信提醒你具体去哪里取快递。</p>
<p>​    近邻宝代收时，中小件都会放入快递柜中，到时候去取快递的时候，找到对应号码的快递柜，在公众号点击“立即开箱”或在快递柜中央的电子屏输入取件码，对应的柜门就会弹开，取出后把柜门关好就行了。</p>
<p>​    注意：不是所有网购的东西近邻宝都可以代收，如果是特大件，或者相关快递公司没有与近邻宝建立联系的话，需要去西北门（校医院附近的那个门，在文科华联超市那边）自取。（快递员开车来，一般上午通知你的话，需要12:00-14:00间取走；下午通知你的话，需要16:00-18:00间取走；如果取件有困难也可以沟通一下，次日或改天再取）目前市面上大多数快递公司如京东、圆通、韵达、天天、申通、中通、顺丰、唯品会等均已与近邻宝公司合作，大多商品均可入柜。</p>
<p>​    <strong>八里台校区</strong>几个主要超市的位置分别在一食堂旁边、二食堂一楼、三食堂一楼、浴园楼下和西门附近，不同超市中的同类商品价格有所差异，需要大家去探索和对比。西门出门一段距离后，有一家大型的家乐福超市，适合进行全面采购。南门出门不远就是鲁能城购物中心，适合逛吃（跑题了）。</p>
<p>​    或者天塔地铁站（也在八里台校区附近）出来就有一个农贸市场，东西很全而且便宜。然后八里台校区的快递，通用地址如下：</p>
<blockquote>
<p>天津市南开区学府街道卫津路94号南开大学XX宿舍楼邮编300350</p>
</blockquote>
<p>​    但其实和津南校区一样，快递员也不会把快递送到宿舍楼里，之前都是短信通知地点和货号，在规定时间内去指定地点翻自己的快递，找工作人员扫码领取。几个快递点分别位于：<strong>一食堂门口</strong>、<strong>排球场旁边</strong>、<strong>16宿门口(顺丰)</strong>、<strong>浴园门口和西区公寓门口</strong>。</p>
<p>​    但是！！！划重点！！！嘉皮同学发现了菜鸟驿站入驻南开大学八里台校区的推送（来自公众号“南开大学后勤保障服务”，2020年7月4日发布的），虽然还没有机会亲身体验一次，但看起来八里台校区和津南校区一样，拥有类似于“近邻宝”的智能快递柜了！具体的取件方法，上面的推送中有所介绍，20级的孩儿们，还真是幸运啊！</p>
<h4 id="6：厨房"><a href="#6：厨房" class="headerlink" title="6：厨房"></a>6：厨房</h4><p>津南校区宿舍的每层楼（或只在一楼）设有厨房，基本的设施有冰箱、微波炉和电磁炉，锅碗瓢盆需要自己准备。有了这些，基本上煎鸡蛋、牛排，炒几个菜，甚至是吃顿火锅都是可以做到的。</p>
<p>八里台校区，嗯，宿舍没有厨房。</p>
<h4 id="7：自动售货机"><a href="#7：自动售货机" class="headerlink" title="7：自动售货机"></a>7：自动售货机</h4><p>​    <strong>津南校区</strong>宿舍的每层楼（或在一楼）设有自动售货机，提供各种饮料；一楼还设有咖啡机，在同学们熬夜的时候可以去充充电。当然这些只是听说，教三宿舍（原后勤员工二宿舍）好像都没有（<em>确实都没有</em>）</p>
<p>​    <strong>八里台校区</strong>，公主楼和二主楼里有一些，也会卖一些饮料之类的。有些宿舍设有诚信超市，无人售货，是为了同学们方便（懒得出楼/赶时间/宿舍门禁了）设立的，有桶装泡面、饼干、火腿肠、奶茶、榨菜之类的食物。</p>
<h4 id="8：健身"><a href="#8：健身" class="headerlink" title="8：健身"></a>8：健身</h4><p>​    <strong>津南校区</strong>“每一栋”学生宿舍楼都在一楼开辟了健身区，瑜伽、跳绳、健腹、举重、呼啦圈……同学们不出宿舍楼就能健身。健身区作为学生成长社区的一部分设在一楼的共享空间，大约20平方米。其中，男生健身区配有哑铃、俯卧撑架、健腹轮、健身炮筒、仰卧起坐板、飞盘、臂力器等；女生健身区配有瑜伽垫、瑜伽球、呼啦圈、弹力绳、小号健身炮筒及仰卧起坐板、飞盘等。你问我为什么“每一栋”加上了双引号？因为教三除外。</p>
<p>​    <strong>八里台校区</strong>，五楼有天台。（短短五个字透漏出无限的辛酸与无奈）(<em>教三天台都没有</em>)但这个天台还是不错的！还可以晾衣服晒被子之类的。</p>
<h4 id="9：校内公交车"><a href="#9：校内公交车" class="headerlink" title="9：校内公交车"></a>9：校内公交车</h4><p>​    <strong>津南校区</strong>设有225路校内公交车，招手即停，票价一元（投币），运行时间为6:00-21:00，路线为西门-马蹄湖-理科食堂-梨树园-图书馆-学生活动中心体育馆-文科食堂-专家公寓-西门（间隔时间未知，我都是凭运气碰的）。如果拿的行李很多，就从西门蹭一波225，到理科食堂或文科食堂下车，一般就离宿舍很近了。</p>
<p>​    <strong>八里台校区</strong>有观光车，没有窗户，只有篷的那种，真的是纯观光用……所以也很少有学生坐的。</p>
<h4 id="10：校医院"><a href="#10：校医院" class="headerlink" title="10：校医院"></a>10：校医院</h4><p>​    <strong>津南校区</strong>的校医院在文科组团，世纪华联超市附近的位置，感冒发烧一类的小病还是可以看的，但一般也不给开什么药；所以常用的感冒药、退烧药、止泻药、胃药、跌打损伤药和消炎药等，都尽量从家里带来一些，以备不时之需。如果要出门买药的话，可以骑校园内的“校园小白车”（共享电动车）去咸水沽地区的同仁堂药店（百度或高德导航吧，还是挺远的，骑车要十来分钟，但百年老店靠谱）而且稍微严重一点的症状，就自己或联系辅导员打车去咸水沽医院（二甲）/海河医院（三甲）了，打车十几分钟到，还是不用太担心的。</p>
<p>​    相比之下，<strong>八里台校区</strong>的校医院似乎更靠谱一些，各诊室较为齐全，可以正常开药，但不能打点滴（吊瓶、输液），也对外开放，经常有各个地方的老爷爷老奶奶过来开药。再有复杂一点的病的话，就转一中心医院了，距离南开也就不到3公里的距离。</p>
<h4 id="11：理发店"><a href="#11：理发店" class="headerlink" title="11：理发店"></a>11：理发店</h4><p>​    <strong>津南校区</strong>文理科各设有一个理发店，相比之下，理科的感觉技术高一些，可以办一张500元的储值会员卡，每次剪头以享受七五折优惠（虽然个人觉得还是比较贵）。不过，如果你真想做个高级一点的发型的话……不如考虑下市里的理发店？</p>
<p>​    <strong>八里台校区</strong>在西南村有一家理发店，不知现在是否有过改朝换代和升级，18年我入学的时候，那可是名震一时——如果你想闭关学习却又担心自己定力不足，那么就去西南村的理发店剪个头吧——一个月内你肯定是没脸见人了！浴园楼下有一个“金砍刀理发店”——别跑！别怕！口误！“金剪刀理发店”。这个店，挺好的，也就是剪个平头要38，也就是剪个平头给你剪成杂草丛，也就是染个黑色的头发几个月后还变黄。<br>​    北村有一家理发店，相对靠谱多了，似乎叫做“雅丝兰美发沙龙”（可能有偏差，很神奇，我们问到的人中，没有人准确记得这家理发店到底叫啥）</p>
<h4 id="12：水果店"><a href="#12：水果店" class="headerlink" title="12：水果店"></a>12：水果店</h4><p>​    <strong>津南校区</strong>文科世纪华联销售水果，理科也有水果店，在商业街的一楼。理科水果店的质量要明显优于文科的，而且还相对便宜。文科的孩儿们也不要沮丧，理科的可以提供外送，文科那边只要微信下单等收就行。</p>
<p>​    然后有一个“水果的士”的公众号，也提供水果的配送服务，水果齐全好吃而且便宜，但由于他也没给我们广告费，所以就不多介绍了。也不知他能不能经受住疫情的考验，大家可以关注公众号，如果恢复售卖了一定会有通知的</p>
<p>​    <strong>八里台校区</strong>可以去西南村的市场里，那个地方很像菜市场，颇具生活气息。</p>
<h4 id="13：文具店"><a href="#13：文具店" class="headerlink" title="13：文具店"></a>13：文具店</h4><p>​    <strong>津南校区</strong>文科世纪华联附近有一家，也会卖一些生活中的小商品。世纪华联和711也有卖，不过个人感觉网购最划算。</p>
<p>​    <strong>八里台校区</strong>二主楼楼下有一家小文具店，浴园超市也有部分文具出售，也可以去西南村的菜市场、不好意思、市场里。</p>
<h4 id="14：手机-电脑维修"><a href="#14：手机-电脑维修" class="headerlink" title="14：手机/电脑维修"></a>14：手机/电脑维修</h4><p>​    <strong>津南校区</strong>文理科商业街各有一家，口碑差不多，<strong>一样的烂</strong>。没见过几个修好的。(<em>修电脑不如自己动手，但是换硅脂清灰还行</em>)<br>推荐去鲁能城修吧。</p>
<p>​    <strong>八里台校区</strong>，出校门不远处，紧邻家乐福有一家“百脑汇”——堪称修电脑不行、宰客第一名、口碑最差的电脑维修地之一。不然大家还是进城修吧。</p>
<p>​    <strong>另外澄清一下，虽然我也是学的计算机类的专业，但我真的不会修电脑！</strong></p>
<h4 id="15：自行车维修"><a href="#15：自行车维修" class="headerlink" title="15：自行车维修"></a>15：自行车维修</h4><p>​    <strong>津南校区</strong>一处在文科研究生宿舍地下车库，世纪华联大门正对的那个就是，一处在理科学5B和学5C之间。</p>
<p>​    <strong>八里台校区</strong>，16宿门口、西区公寓门口、浴园旁边各有一处</p>
<h4 id="16：书店，纪念品店"><a href="#16：书店，纪念品店" class="headerlink" title="16：书店，纪念品店"></a>16：书店，纪念品店</h4><p>​    <strong>津南校区</strong>就在文科商业街有一家二手书店。</p>
<p>​    <strong>八里台校区</strong>“南开大学北村书店”也是专门卖二手书的，大多是九成新，而且价格非常便宜。</p>
<p>​    <strong>津南校区</strong>纪念品商店位于理科商业街和文科留学生公寓旁边，在纪念明信片上写下一段文字送给远方，互道一声好。</p>
<p>​    <strong>八里台校区</strong>，从东门进入步行约两百米处就是纪念品商店了。</p>
<h4 id="17：教学楼"><a href="#17：教学楼" class="headerlink" title="17：教学楼"></a>17：教学楼</h4><p><strong>津南校区</strong>最常用的教学楼就是“公共教学楼”（以下简称“公教”）和“综合实验楼”，它们都在图书馆旁边，只隔一条街，位置处在文理科生活组团中间位置，从哪里来都不远。其中公教B、C区的开放时间为7:00（存疑，没去过那么早）-23:00（冬季有时会调整到22:30），只要没有课的教室，就可以用来自习。大家本科阶段约90%的课程都会在公教完成。公共教学楼和综合实验楼之间地势较低，被修建后成为了“文化谷”，从图书馆7楼望去非常漂亮。从图书馆出发，穿过“文化谷”，就到了体育馆。</p>
<p><strong>八里台校区</strong>，主要上课的两个教学楼是主楼和二主楼，都会开放一定的自习区域，不过由于主楼的桌椅比较狭窄，同学们一般会选择在二主楼自习。</p>
<h4 id="18：图书馆"><a href="#18：图书馆" class="headerlink" title="18：图书馆"></a>18：图书馆</h4><p>​    南开大学图书馆创建于1919年，前身为1927年卢木斋先生捐资兴建的木斋图书馆和西南联大时期的联大图书馆。伴随南开大学的整体战略发展。</p>
<p>​    图书馆现有<strong>津南校区</strong>（中心馆）和<strong>八里台校区</strong>（逸夫馆、理科馆、经济分馆）两个校区的四处馆舍，总建筑面积71610余平方米，总阅览座位4000余席。其实八里台还有一处文中馆，这是一个颇具历史的图书馆，非常有历史厚重感，但环境…有点一言难尽。（嘉皮：主要是冬天好冷&gt;_&lt;）然后八里台的逸夫馆（中心馆），整修闭馆好几年了…外观看起来已经建好了，不知道何时才能再次开放。</p>
<p>​    津南校区的中心馆于2013年6月奠基，2015年正式投入使用。图书馆位于校区中心位置，建筑面积46418平方米，地上共9层，风格庄重大气。中心馆投入使用后，图书馆的硬件水平有了极大的提升，在此基础上不断拓展各种形式的创新服务，除传统的纸质文献借阅、多媒体阅览、参考咨询、馆际互借、文献传递、学科服务、科技查新及讲座、展览等服务之外，移动图书馆、RFID系统、座位管理系统、3D导航、自助借还、自助文印系统等智能化信息管理系统的应用使图书馆的现代化水平日益提高。此外还增设了多个研修间以及多媒体体验区、休闲讨论区和具备院线级高清视频和3D视频播放功能的放映厅。图书馆将会在一些时段放映电影。</p>
<h4 id="19：体育馆"><a href="#19：体育馆" class="headerlink" title="19：体育馆"></a>19：体育馆</h4><p>​    15年12月起，<strong>津南校区体育馆</strong>正式对本校师生开放，内建有乒乓馆，羽毛球馆，篮球馆，体艺教室，游泳馆等多功能场馆。</p>
<p>​    乒乓球馆、羽毛球馆、排球馆课余时间对本校师生开放，本校师生可凭本人学生证、教师证、一卡通进入活动。其中羽毛球馆在周一至周五的工作日的每天下午四点到六点免费开放，其他时间需要在网上预定场地。排球馆需要预定，每个场地每小时50元。（标准排球对阵是12人，平均下来每人每小时4块钱多一点）篮球馆、艺体室在课余时间对体育类社团活动和院系比赛开放。</p>
<p>​    体育馆整体上由三部分构成，从外观看起来像一个“三步台阶”，南侧的部分高度最高，在功能上设计作为篮球馆和大型会场使用；中间高度次之的部分作为网球馆、羽毛球馆和综合训练馆使用，北侧的部分是游泳馆。此外还有健美教室，跆拳道馆等多样化教室。</p>
<p>​    在这炎炎夏日，最受欢迎的应该就是游泳馆啦！目前游泳馆已开放。开放时间为9:00-22:00,21点后停止入场，收费标准是5元/小时，办卡有优惠。带上你的泳衣，一起去迎接透心凉吧！</p>
<p>​    <strong>八里台校区</strong>有两个体育馆，一老一新。相比于老体育馆，新馆占地面积大、设施齐全，有击剑馆、游泳馆、排球馆等各类体育设施。同时设有可以办卡的健身房，以及今年新建并预计投入使用的滑冰场地。</p>
<h4 id="20：学生活动中心"><a href="#20：学生活动中心" class="headerlink" title="20：学生活动中心"></a>20：学生活动中心</h4><p>​    从空中俯视一番，鸟瞰南开大学津南校区，格外引人注目的是校园东部邻水而立的一幢极具现代气息的白色建筑。这六栋大小不等的立方体呈放射状排布，围绕中心庭院布置交通空间和公共空间。从空中俯瞰貌似一朵绽放的海棠花(<em><del>大钢菊</del></em>)，寓意着花样青春和勃勃生机。</p>
<p>​    新学活占地面积5500平方米，总建筑面积10000平方米，一共有3层，共15米高，东侧邻水，有一部分悬挑于湖面。水天相映，是不是别有一番雅趣呢？</p>
<p>​    接下来，我们进去看看吧。学活内部从右至左逆时针分布ABCDEF六个区域，其中海棠花的两个“花瓣”被打造成了一个音乐厅和一个大剧场。音乐厅共有279个座位，而座椅前后较大的高度差则为观众们带来了良好的视野。再也不用为只看到后脑勺烦恼了……新学活的座椅全部采用静音设计，最大限度减少了对演出的干扰。所以你再也不会在看演出的时候听到吱呀的声音啦。一看到最后一排座位，大家肯定想问在这么远还能听到舞台声音吗？可以确定地告诉大家，可以！因为音乐厅的内饰吊顶墙面是邀请专业的声学团队设计的，即便不用话筒，舞台声音也可清晰传递到最后一排。</p>
<p>​    而“海棠花”北侧最大的“花瓣”就是大剧场的所在啦。在大剧场里一共设有801个座椅。除了上面介绍的以外，新学活还为学生文艺活动提供了充足的空间。这里就是为合唱而设计的排练厅。</p>
<h4 id="21：饮食"><a href="#21：饮食" class="headerlink" title="21：饮食"></a>21：饮食</h4><p>​    <strong>津南校区</strong>的文理科各设有一个食堂。</p>
<p>​    理科食堂，又称学二食堂，主要分为三层。理科一楼以家常菜为主，主食与菜品分窗口出售，侧面有一些特色窗口（面条、包子烧卖、岩烤饭、煲仔饭是真的好吃）。早餐种类相对文科更为丰富、也更好吃一些。另外有一家饮品店和一家面包店。</p>
<p>​    理科二楼有各种特色美食，有烤鱼、麻辣烫、小火锅等。入口处是自选快餐。水吧有鲜榨果汁、奶茶等。营业至21:00，但一般20:00就没啥吃的了</p>
<p>​    美食广场也位于理科食堂二楼，有烧烤、烤冷面、豆皮、乐客汉堡、韩式年糕等。美食广场消费可办理餐卡或手机支付，不可使用一卡通，营业至晚11点。（过了晚上九点钟吃夜宵的地方）</p>
<p>​    理科三楼有一些自选的饭菜，还接受包房预定（十几人大圆桌的那种）。</p>
<p>​    文科食堂，又称学一食堂。一楼的早餐主要是各种饼，有粥、豆浆、豆腐脑、鸡蛋等（我觉得，不好吃！但人与人之间的口味有差异啦）。食堂中央有水吧，出售各种饮品，也有雪糕和盒装水果出售。清真食堂也位于文科食堂一楼，全部为清真菜品，有早餐供应。推荐一楼的凉皮和石板鸡蛋。</p>
<p>​    文科二楼有自选快餐、西式快餐、麻辣香锅、黄焖鸡等，也有一家饮品店。入口可办理餐卡。二楼推荐花甲粉和水饺。</p>
<p>​    学一食堂和学二食堂均可刷一卡通支付或支付宝付款。注意：支付宝付款需要先进行在校生的认证，不然会被多收取15%的费用。</p>
<p>​    除文理科食堂外，理科商业街有串串淑淑（比东北差远了的烧烤，想吃好吃的烧烤去咸水沽的“东北虎烧烤”）、兰州拉面（兰州炒饭真香）、骨稻香排骨饭（好像要黄了）、711（饭团是真的好吃）；文科食堂附近设有思蜀（四川人说一点也不辣的川菜）(真不辣，和四不四川没关系)、舒香（总体评价最好）、橘南小巷（火锅！！）、拉面（里面的饭比面好吃，略贵，但分量也是真的足）、赛百味、90咖啡（有炸鸡薯条等，但不如理科的乐客汉堡好吃）等。</p>
<p>​    <strong>八里台校区</strong>有五个食堂，位置较为集中，其中二食堂较为现代化，共三层，环境整洁明亮，但饭菜价格相对较贵。一楼的纸包鱼是朋友聚餐和情侣打卡处，二楼的瓦罐汤，巴沙鱼，羊杂汤，新疆菜馆都很好吃，三楼的馨香园餐厅适合多人聚餐或请客吃饭，各地美食涉猎范围广，基本能满足不同口味的需求。三食堂是文物级别的建筑，由梁思成先生设计而成，环境相对普通，饭菜价格亲民且很好吃，早餐种类丰富，红枣豆浆不加糖也甜甜的超好喝，夏天会提供免费的绿豆汤解暑，三食堂的面食人气也很高。一食堂和清真食堂相邻，面积较小但各有特点，一食堂早饭种类多，午餐晚餐供应以米饭为主，清真食堂就餐环境好，拉面、饭菜都很受欢迎，实习餐厅在一食堂二楼，提供各种各样的炒菜和盖饭，由于本人不常去这三个食堂，欢迎学弟学妹来自己探索呀。</p>
<p>​    八里台绝对不能错过的就是西南村！南开师生心中的小吃一条街，老王豆皮、老陶包子铺、锅盔、烤冷面都是小红书上的网红打卡地，用学长的话来说，能在这里生存下来的店铺味道都有其竞争的资本，</p>
<p>​    另外，校园内西区公寓对面的肠粉，二主楼晚上下课后的烤地瓜，西门出门的四川菜馆，鲁能城外卖的奶茶和鲜芋仙，隔壁天大学五食堂冬天的糖葫芦都值得推荐。（南开八里台与天大卫津路校区是相连通的，一不小心可以走到天大去，如果去天大的食堂的话需要他们的饭卡哟，可以约上天大的朋友或者借一张天大同学的饭卡）</p>
<h4 id="22：交通"><a href="#22：交通" class="headerlink" title="22：交通"></a>22：交通</h4><p>​    <strong>八里台和津南校区之间</strong>：公交612路（慢线）：全年运行。八里台校区开行时间为6:00至20:30，津南校区开行时间为6:30至20:30，每20-30分钟开行一班，票价2至3元，可投币/支付宝乘车码/一卡通（需开通相关功能）支付。运行区间为八里台校区西门内公交总站至天南大新址公交站，在复康路手表厂站、卫津南路天塔站、我校津南校区西门停靠。612路快线：全年运行，运行时间为6：30至21:15，每20-30分钟开行一班，车辆为普通公交车，票价5元，可投币/支付宝乘车码/一卡通（需开通）支付。遇到点对点直达公交开行时，大站快速公交开行时间顺延。运行区间为八里台校区西门内公交总站至津南校区西门。仅在复康路手表厂站及卫津南路天塔站停靠。</p>
<p>​    <strong>津南校区到咸水沽镇</strong>：在2017年11月开通了前往咸水沽以及月坛商厦的公交205线，205线要在津南校区西北门外乘坐。</p>
<p>​    <strong>津南校区与各大火车站、飞机站之间</strong>：</p>
<blockquote>
<p>(1)天津站—地铁三号线—营口道站换乘地铁一号线—华山里地铁站出站—华山里公交站乘613路—南开大学新校区西门站</p>
<p>(2)天津站—地铁三号线—天塔站出站—换乘612路/612快线—南开大学新校区西门站</p>
<p>(3)天津西站—地铁一号线—华山里地铁站出站—华山里公交站乘613路—南开大学新校西门站</p>
<p>(4)天津南站—地铁三号线—营口道换乘地铁一号线—华山里地铁站出站—华山里公交站乘613路—南开大学新校西门站</p>
<p>(5)滨海国际机场—地铁二号线—天津站换乘地铁三号线—营口道换乘地铁一号线—华山里地铁站出站—华山里公交站乘613路—南开大学新校西门站</p>
</blockquote>
<h4 id="23：其他"><a href="#23：其他" class="headerlink" title="23：其他"></a>23：其他</h4><h5 id="1-电费"><a href="#1-电费" class="headerlink" title="1.电费"></a>1.电费</h5><p>​    学校每年会给每个宿舍提供300度免费电，当剩余电量只有10度的时候，宿舍就会断电，这个时候在微信群里@一下宿管阿姨，阿姨就会告诉你“xxx宿舍只剩十度电了！”，然后阿姨把电卡插一下，你们就可以用剩下的10度电度过漫漫长夜，第二天就要赶紧去交电费了。交电费有两种方式：第一种要拿着电卡去师生服务大厅（津南校区综合业务楼西楼一楼，八里台办公楼），找到相应窗口办理就好了——基本已经被淘汰的方式。第二种可以直接在飞书APP上的南开微应用缴费，具体的价格是0.49元/度，节约用电人人有责！（注意22:00-3:00系统关闭，无法缴费）</p>
<h5 id="2-限电（功率限制）、防火"><a href="#2-限电（功率限制）、防火" class="headerlink" title="2.限电（功率限制）、防火"></a>2.限电（功率限制）、防火</h5><p>​    无论是八里台还是津南校区，宿舍内都不能使用大功率电器——具体限制是300w以内，什么概念呢？除了热水袋，电热器基本都不能用，包括吹风机。如果在津南的话，宿舍内的公共水房内有插座，那个是没有功率限制的，可以在那里使用吹风机。当然，空调走的线路也是没有功率限制的，所以大家使用空调的时候可以不必担心。300w还是挺小的，有的时候宿舍内所有的插座都用上的时候，可能就会跳闸，这时候可以在微信群里@一下宿管阿姨，如果不是只剩10度电的情况，那就是总功率超限了——一般10分钟内可以恢复供电。但是！注意！！！如果频繁地因功率超限而断电，阿姨就必然会登门拜访了。2018级，就有人，因在宿舍内使用电饭煲（虽然很小了，但还是超功率的），导致全宿舍楼断电，而被通报批评并记过处理了。宿舍里“原则上”不允许外接插排。我强调“原则上”了。但这个来检查的时候，查到了没收也是没话说的，毕竟安全第一，这是头等大事。用电安全不可疏忽，大家切记要小心！离开宿舍的时候也记得把所有电源都切断，充电器拔出来等等。莫等酿成大祸后追悔莫及！</p>
<h5 id="3-防盗"><a href="#3-防盗" class="headerlink" title="3.防盗"></a>3.防盗</h5><p>​    虽然我们的门禁需要刷一卡通才能进，但注意，当你刷卡后尾随你进入的可能不是你的同学或辅导员，所以晚上尽量锁好门，白天离开或自己在屋里睡觉的时候一定一定要锁好门！贵重物品放在柜子里锁好。</p>
<h5 id="4-防狼"><a href="#4-防狼" class="headerlink" title="4.防狼"></a>4.防狼</h5><p>​    八里台的人，鱼龙混杂，津南校区地理位置偏远荒凉，晚上的时候尽量结伴而行，现在这个时代已经不分男女了，都要小心哦！津南校区尽量不要往校园的边缘地区、百米之内见不到人的地方去。</p>
<h5 id="5-防骗"><a href="#5-防骗" class="headerlink" title="5.防骗"></a>5.防骗</h5><p>​    <strong>热情帮忙</strong>，拿走行李一去不回怎么说呢…除非你很熟悉的学长学姐…不要把自己的行李就那么傻傻地给别人了啊！！还有就是，帮你拿可以，你得看着他给你送到宿舍楼下才行啊！</p>
<p>​    <strong>替交学费</strong>，拿走钱后不知去向咱现在，都网上直接缴费了，几下操作就能成，不用别人帮。</p>
<p>​    <strong>冒充老乡</strong>，谈笑间盗取财物这个主要是在高铁等交通工具上。</p>
<p>​    <strong>假冒师长</strong>，光天化日之下盗取财物你在上课之前只需要认识一个人，就是你的辅导员，其他“老师”全当作骗子好了。前几年还有更离谱的，正上着课呢突然冲进来几个人，自称是校领导，没收上课玩手机的同学的手机。真有人受骗的。</p>
<p>​    <strong>寝室推销</strong>，假冒伪劣产品需防范第一、无论是学姐还是学长，无论卖的是刷鞋的清洁剂还是四六级练习题，只要进宿舍推销的，卖的东西一定是假的；第二、请在他离开你的房间进入其他房间推销时迅速联系宿管阿姨（保护自己，不要正面冲突），同时联系学校保卫处，骗子们会因违反治安管理条例、涉嫌诈骗等罪名被警察叔叔带走。</p>
<p>​    <strong>诈骗电话</strong>，骗取个人隐私及财物回复验证码的、要账号和密码的，都是骗子。学校不会以电话的形式指挥你操作，申请助学金或助学贷款的同学尤其注意不要被骗。告诉你们解决诈骗和骚扰电话的方法——用一个不锈钢的盆子把手机扣上，拿着你的勺子对着盆子就是一顿猛敲。效果显著，间歇性或永久性耳鸣或失聪。</p>
<p>​    <strong>编造谎言</strong>，蒙骗家长急需汇钱告诉你的家长…你如果急需钱的话会给家长打电活或发个语音，以证明的确是TA的亲儿子/姑娘，不是骗子。</p>
<p>​    <strong>虚假承诺</strong>，谨防落入中介陷阱就一句话，说得天花乱坠的，还不是为了坑你的钱？</p>
<p>​    <strong>假装可怜</strong>，同情心换来财物损失校园里好像不允许乞丐存在，所以都是骗子高度警惕.</p>
<p>​    <strong>非法传销</strong>学校里面没有，如果涉及到校外的公司或组织，别傻乎乎地就跟去了好吗？</p>
<p>​    量入为出，适度消费，警惕校园贷人的欲望是无限的。得知道自己家几斤几两，得理解父母有多辛苦，要懂得感恩，而不是只知道一味地败家。莫与问路的、找地方吃饭的陌生人有过多接触，莫上陌生人的车，防止被不法分子拐卖。</p>
<p>​    最后说一个我心目中的流氓玩意儿——校园手机卡（inankai）每年开学季都会有学长学姐——真的是南开大学在读本科生，你“亲学长亲学姐”，向你推销手机卡——inankai。inankai是覆盖南开大学的另一个校园网体系，号称速度、信号完爆NKUWLAN——这一点我可以负责任地跟你说，基本等于放屁。当初为了确认此事，我采访了888位使用过inankai手机卡的在读本科生（15、16级现已毕业），其中说inankai信号不比NKUWLAN好、速度不比NKUWLAN快的人数为712人——好评率不到20%。而且这里面有很多套路，你根本就想不清楚的。还有说在你宿舍安装宽带的，我也是醉了，你知不知道你的宿舍可能根本就没有宽带的接口，往哪儿安？？但我也就只说这么多了，再多说我就被喷了——毕竟每年那些推销的，可能就有我身边的同学，影响人家的利益了，肯定要来找我撕逼，没空搭理，烦。当初就发个朋友圈都来跟我逼逼叨叨的，虽然全让我骂走了，但就很无趣！<br>​    自8月初开始，这条招聘的信息在朋友圈广为流传。我不知道这个消息的始发者是谁，但我们可以来分析一波：如果真的，推销成功一个可以让该兼职大学生赚到100块钱，那么你觉得运营商的利润会是多少？这样看来，办卡的就是活脱脱的韭菜本菜，不然你真以为移动联通电信是慈善机构呢？当然，如果这个宣传是假的，那么就涉嫌虚假宣传，甚至诈骗了。我并不害怕说出我的真实感受——inankai，在我心里，垃圾，请谨慎办理。也没必要非得办个天津的手机卡，现在长途和漫游都取消了，主要是办个流量套餐合适的就行。</p>
<h5 id="6-网费"><a href="#6-网费" class="headerlink" title="6.网费"></a>6.网费</h5><p>​    2019年根据校网信办的最新政策，NKUWLAN（校园网）每人每个月有10个G的免费流量，超出的部分按照0.001元/Mb（折合约1元/G）标准计费。缴纳网费的方法有两种：一是到圈存机用一卡通交网费。圈存机设立地点：津南校区：综合业务西楼一楼师生服务大厅、文理科食堂；八里台校区：学一食堂一楼大厅、学二食堂一楼和二楼的楼梯间、主楼和二主楼的一楼大厅、学生活动中心一楼大厅和办公楼一楼104室；带着一卡通按提示操作就可以缴费了。第二就是在飞书APP上点开南开微应用，选择“网络账户业务”，选择圈存金额后输入一卡通的密码就可以存网费了。第二种方法显然更加快速便捷，第一种就是当飞书上的网络圈存系统发生故障、正在维护或升级时，应急使用的。</p>
<p>​    <em>这里我要说一下一些游戏玩家需要了解的事情。早年的NKUWLAN在Steam上下载游戏是不走流量的，但是自从升级了以后就会消耗你的流量，建议一个寝室或者几个喜欢玩游戏的伙计共同办一个inankai，垃圾归垃圾，但是不限量，晚上挂着下载大件文件还是爽</em></p>
<h5 id="7-三张很重要的卡"><a href="#7-三张很重要的卡" class="headerlink" title="7.三张很重要的卡"></a>7.三张很重要的卡</h5><p>​    （1）一卡通（学子卡）：大学里的“求助万票”“寻卡启示”“捡到请奶茶”的，大多是一卡通。<br>​    一卡通，吃饭的时候刷、洗澡的时候刷、进宿舍的时候刷、圈存网费也刷，甚至开通相关功能后可以当做公交卡，一卡在手，说走就走。<br>​    如果一卡通不慎丢失，请带好身份证去以下地点补办：津南校区师生服务大厅（综合业务西楼里，8:00-12:00或12:30-16:00）八里台校区在办公楼里，携带身份证可以自助办理。请注意以下两点：1.补卡费30元。如果一卡通遗失时余额已不足30元，需要提前在飞书APP上南开微应用中进行充值，补卡费将直接从一卡通中扣除；2.如果一卡通开通了交通模块的功能（就是乘坐公交可以直接刷一卡通付费的那种），注意交通模块的“交通费”与吃饭洗浴的钱是不互通的，补卡的话，交通费，就没了——30块钱也是从吃饭洗浴的钱里扣，交通费直接就没了！！！所以要慎重！！！比如丢卡时，一卡通中还剩45元（吃饭洗浴等）+交通费50元，那么补卡之后，还剩15元（吃饭洗浴等）+交通费0元（清零，回不来了）因为支付宝里有那种电子乘车码，上车后可以直接刷，所以没必要非得开通一卡通的交通模块，否则丢卡后肠子都悔青了！</p>
<p>​    （2）水卡：这个只有津南的同学才有啦，八里台都是支付宝付款出水噢。<br>​    注意，水卡不记名，说白了谁捡了都能用，所以如果丢失的话，尽快去学5B和5C宿舍之间的门洞里，在5B楼的侧面，有一个小楼梯，一楼，就是补办水卡和给水卡充值的地方。入学的新生也需要去那里领取、开通一下水卡。</p>
<p>​    （3）太平洋学子卡（交通银行卡）：交通银行太平洋学子卡是一张银行卡，每年随录取通知书寄给新生。它与校园卡绑定，可以直接给饭卡充钱，另外学校扣学费、住宿费等等也通过它，所以十分重要。如果不慎遗失，请先咨询辅导员后到如下地点办理：津南校区师生服务大厅，问一下前台是几号窗口；八里台校区在办公楼，同问前台具体在哪个房间办公。</p>
<h5 id="8-住宿费和学费的缴纳"><a href="#8-住宿费和学费的缴纳" class="headerlink" title="8.住宿费和学费的缴纳"></a>8.住宿费和学费的缴纳</h5><p>​    每年都会有五六种缴费方法提供给你，这个在缴费前一定要和辅导员确认，切记！在你开学前，所有的缴费通知一定只能相信你辅导员发给你的！！！在联系到你的辅导员之前，什么钱都不要交！！！2019级入学的这一届开始都是学分制收费了，简单地说就是要看你一年修了多少学分，决定这一年要交多少钱，具体的可以看看群里的学分制收费宣传手册。这样的话，学费是在学期末交了，所以开学前只需要缴纳教材费和下一学年的住宿费。具体缴费方法，辅导员会发通知，有详细介绍，这里介绍一种最简单最省心的——在指定日期前，将足够的钱存到学校下发的太平洋学子卡（交通银行卡）中，例如，住宿费一年是1200元，教材费是1000元，预计扣费日期是8.29-8.30，那么只要在这个期间，“系统检测到你还没有缴费”且“你的太平洋学子卡中的余额大于2200元”，则代表你同意校方授权交通银行代理扣缴住宿费和教材费。也就是说，学校会直接把2200元划走，之后你的网上银行会有交易通知和记录，家长会收到缴费的短信通知，这样就完成了缴费。具体缴费方式请以辅导员转发的财务处通知为准。</p>
<h5 id="9-开学的注册报道（摘自2019年的通知，详情请以最新通知为准）"><a href="#9-开学的注册报道（摘自2019年的通知，详情请以最新通知为准）" class="headerlink" title="9.开学的注册报道（摘自2019年的通知，详情请以最新通知为准）"></a>9.开学的注册报道（摘自2019年的通知，详情请以最新通知为准）</h5><p>​    （1）注册时间：八里台校区8:30-12:00；14:00-16:30津南校区9:00-12:00；14:00-16:30</p>
<p>​    （2）注册方式：自助注册学生缴纳学费、住宿费后，持校园一卡通在校园圈存机，根据提示自助完成注册。学生在校园圈存机完成注册后，到所在学院加盖注册印章。（指学生证盖章，每年学院会统一收取，不盖的话假期买火车票高铁票不能减免）</p>
<p>​    （3）注册地点：校园圈存机、各学院校内圈存机安装地点：①八里台校区学一食堂一楼大厅②八里台校区学二食堂一楼楼梯间、二楼楼梯间③八里台校区学三食堂一楼门口④八里台校区主楼一楼大厅⑤八里台校区二主楼一楼大厅⑥八里台校区学生活动中心一楼大厅⑦八里台校区办公楼一楼104室⑧津南校区综合业务西楼一楼师生服务大厅⑨津南校区文科、理科食堂</p>
<p>​    （4）注意：①学生须在学校规定的注册之日起两周内完成注册，未在校园圈存机自助注册的学生不能选课，考试成绩不予认定;未在所在学院加盖注册印章的学生，不能享受寒、暑假火车票半价优惠。②学生校园一卡通丢失或损坏的，请尽快去信息化办公室进行补办，补办后及时完成注册。③学生交通银行太平洋学子卡丢失的，请尽快到校内交通银行网点补办，补办后在校园圈存机上重新绑定新卡号及时完成注册。</p>
<p>​    （5）交通银行校内网点：八里台校区北村25楼一楼，八里台校区西南村市场东侧，津南校区理科商业街</p>
<p>​    （6）财务处收费科办公地点：八里台校区学生活动中心一楼111室，津南校区综合业务西楼一楼财务处报账大厅</p>
<h3 id="二：新生入学物品清单"><a href="#二：新生入学物品清单" class="headerlink" title="二：新生入学物品清单"></a>二：新生入学物品清单</h3><blockquote>
<p>本文使用ABC对不同物品进行分类</p>
<p>其中A类物品是建议在家中购买后带来/邮寄过来，B类物品是建议网购，C类物品是建议校园内购买</p>
</blockquote>
<h4 id="1：新生入学需要上交的纸质材料"><a href="#1：新生入学需要上交的纸质材料" class="headerlink" title="1：新生入学需要上交的纸质材料"></a>1：新生入学需要上交的纸质材料</h4><p>​    <strong>这一条是根据往年的要求总结的，具体请以今年辅导员的通知为准。</strong></p>
<p>​    1.身份证及其复印件</p>
<p>​    2.户口本及其复印件</p>
<p>​    3.南开大学录取通知书</p>
<p>​    4.高考准考证</p>
<p>​    5.组织关系证明：如果是团员，应由团籍所在学校团委在团员证上填写转至高校团委并加盖公章；如是党员，则需要所在学校组织开具转出证明。此外，还要携带好自己的相关组织关系档案。</p>
<p>​    6.个人档案袋（密封好的，不能撕开封条）：有的高中直接邮给大学，不发到学生手中，大家问清楚，保证这个档案袋能到南开大学就行。</p>
<p>​    7.户口迁移证：这个是针对要把户口转到天津的同学来说的，户口迁移证，一张近期免冠一寸照片（要求身份证标准照，贴在录取通知书姓名旁空白处）。具体内容参见录取通知书上的要求。</p>
<p>​    8.南开大学新生报到信息表：网上报道之后打印再一张A4纸上带来</p>
<p>​    9.家庭财产收入证明：想要申请助学金、贫困专项贷款和其他助学贷款的同学记得带好。</p>
<p>​    10：若干张近期免冠一寸、小二寸照片（红蓝白底都准备一些）：证件照应留存电子版，会有要求交电子版的时候。照得好一点，用到的地方很多，不然追悔莫及</p>
<h4 id="2：生活用品"><a href="#2：生活用品" class="headerlink" title="2：生活用品"></a>2：生活用品</h4><h5 id="1：日化用品"><a href="#1：日化用品" class="headerlink" title="1：日化用品"></a>1：日化用品</h5><h6 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h6><p>背包，眼镜布，伞，吹风机，保温杯，护肤品</p>
<h6 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h6><p>牙膏牙刷，毛巾浴巾，干发帽，洗衣液，洗洁精，晾衣架晾袜架，搓澡巾，纸巾，漱口杯，水杯，洗手液，黏贴胶，身体乳，洗发露，护发素，沐浴露</p>
<h6 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h6><p>抹布，香皂肥皂（内衣皂），皂盒，浴桶，小刷子，大小盆，暖瓶</p>
<h5 id="2：衣服鞋子"><a href="#2：衣服鞋子" class="headerlink" title="2：衣服鞋子"></a>2：衣服鞋子</h5><h6 id="A类-1"><a href="#A类-1" class="headerlink" title="A类"></a>A类</h6><p>​    <strong>T恤、裤子、裙子、袜子、内衣裤、鞋、帽</strong>：九月份天津还是挺热的，穿短袖来就可以，可以再带少量的长袖，十一回家的时候再拿冬装。</p>
<p>​    夏秋衣物多带一些，冬季温度没那么冷，零下十度左右最低了，但是风非常非常地刺骨，所以<strong>围脖、帽子、手套</strong>等必不可少。（<strong>真受不了，东北人也顶不住</strong>）(<em>我见过有人手机被吹飞的，还是小心点好</em>)</p>
<p>​    <strong>睡衣</strong>，不要买那种棉质的很厚的，冬天有暖气，室内怎么也有20多度，太厚根本受不了；薄的长袖长裤睡衣足够了。（我，宿舍里短袖大裤衩过冬）(<em>说实话，真的有短袖吗</em>)</p>
<p>​    <strong>正装</strong>。只要你有参加任何一个学生组织或社团的想法，请准备好正装，一定会用到。搭配正装的，<strong>领带、皮制腰带、皮鞋</strong>。尽量别去津南校区理科商业街二楼的那家服装店定正装，用户评价极差，质量贼次。</p>
<p>​    <strong>针线包</strong>，有的时候衣服裤子破了个洞，缝缝补补一下总还是需要的。不会做针线活怎么破，就去求助于心灵手巧的室友啊！楼下的阿姨也都很和蔼可亲，针线活也都很过硬的。</p>
<p>​    <strong>拖鞋</strong>，宿舍穿着舒服。<strong>运动鞋、凉鞋</strong>等其他鞋子酌情购买，冬天请不要买东北最厚的大棉鞋，用不到，<strong>二棉鞋</strong>足够（怕冷的，根据个人情况准备）。准备<strong>一双小白鞋</strong>，一条不带花纹或花纹不明显的<strong>黑色长裤</strong>，一件<strong>白色短袖</strong>和<strong>长袖衬衫</strong>。这些是参加集体活动可能会要求的。</p>
<p>​    <strong>内衣、内裤、袜子</strong></p>
<p>​    <strong>热水袋</strong>（酌情准备，秋入冬的前几天可能暖气还没来，有身边的同学会觉得宿舍有点冷）</p>
<h6 id="B类-1"><a href="#B类-1" class="headerlink" title="B类"></a>B类</h6><p>​    想网购就网购吧</p>
<h5 id="3：实用工具"><a href="#3：实用工具" class="headerlink" title="3：实用工具"></a>3：实用工具</h5><h6 id="A类-2"><a href="#A类-2" class="headerlink" title="A类"></a>A类</h6><p>床单，被罩，被子，枕头，枕套，枕巾，褥子(校内也有，见仁见智)</p>
<blockquote>
<p>把床垫单列出来，注意以下几点：</p>
<p>1.津南校区的标准床铺规格为191cm×90cm，八里台校区请参照录取通知书上给出的床铺规格。学生宿舍的床为光板床，没有床垫，床垫可以自备或到校购买</p>
<p>2.自备床垫的厚度不得超过50mm</p>
<p>3.学校买的床垫保证厚度合格，60元/个，质量也一般，不过褥子买好一点，铺得厚一点完全不影响睡眠</p>
<p>4.两校区的部分宿舍设有“加长床”，专门给个子高的同学准备的，如果身高在185cm以上可以主动向辅导员申请分配“加长床”。注意津南校区加长床的规格为212cm×90cm（八里台校区请咨询辅导员）,购置床垫和褥子时注意长度的问题。</p>
</blockquote>
<h6 id="B类-2"><a href="#B类-2" class="headerlink" title="B类"></a>B类</h6><p>台灯，指甲刀，挖耳勺，收纳箱，梳子，镜子，耳塞，眼罩，粘钩，筷子，勺子，碗，垃圾袋，保鲜（食品）袋，<del>牌类</del>，床帘</p>
<h6 id="C类-1"><a href="#C类-1" class="headerlink" title="C类"></a>C类</h6><p>小锁，插排，剪刀，水果刀，扫除工具，垃圾桶，水桶</p>
<h5 id="4：学习用品"><a href="#4：学习用品" class="headerlink" title="4：学习用品"></a>4：学习用品</h5><h6 id="B类-3"><a href="#B类-3" class="headerlink" title="B类"></a>B类</h6><p>笔（黑色签字笔、铅笔、涂卡笔）</p>
<p>尺子、橡皮、圆规</p>
<p>笔袋</p>
<p>文件袋、文件夹若干（一定会用到）</p>
<p>订书机、订书钉（资源共享）</p>
<p>书</p>
<h5 id="5：高科技类"><a href="#5：高科技类" class="headerlink" title="5：高科技类"></a>5：高科技类</h5><h6 id="A类-3"><a href="#A类-3" class="headerlink" title="A类"></a>A类</h6><p>手机、手机充电器</p>
<p>平板（非必需，可以平板上放着老师的PPT边听课边批注做笔记）</p>
<p>充电宝（建议15000或20000mA）</p>
<p>U盘（硬盘就没必要了，除非有大规模存储的需要）</p>
<p>耳机（保证质量，不然损伤耳朵）</p>
<p>笔记本电脑</p>
<p>鼠标垫</p>
<blockquote>
<p>特别说明：作为一名网络空间安全学院的标准程序猿，真的跟你们讲，如果你不打游戏的话，完全没必要买上万块钱的游戏本。本科阶段的代码上不了千行，要啥配置，我用2015年买的Dell还能跑着呢。主要是游戏本太沉了，多则重达七八斤，天天提着这个到处跑麒麟臂都练出来了。绝大多数时候，我们无非用用office或WPS、刷刷剧、聊聊天、用用PS、PR和AE之类的，真的不用到顶配。当然，如果你是个游戏玩家，当我没说。（好好学习！！！不许沉迷打游戏！！！）很多人提着七八斤的笔记本在校园里跑了两年，无奈地感慨道：“轻薄才是本命”。</p>
</blockquote>
<h5 id="6：药"><a href="#6：药" class="headerlink" title="6：药"></a>6：药</h5><h6 id="A类-4"><a href="#A类-4" class="headerlink" title="A类"></a>A类</h6><p>创可贴</p>
<p>跌打损伤类（云南白药喷剂等）</p>
<p>中暑药（藿香正气水等）</p>
<p>感冒药（四季感冒片、维C银翘片等）</p>
<p>消炎药（阿司匹林、头孢、罗红霉素等）【消炎药必备！天津市消炎药开药受限，没有医院证明不给开，所以一般感冒发烧的话，如果没有自备消炎药，还要去医院挂号看个病才能开】</p>
<p>退烧药（布洛芬等）</p>
<p>肠胃药（吗丁啉、多酶片等）</p>
<p>缓解咽炎、声带疲劳的药（如金嗓子喉片）</p>
<p>碘酒棉签（打篮球踢足球的男生常用，当然我希望你们不常用）</p>
<h6 id="B类-4"><a href="#B类-4" class="headerlink" title="B类"></a>B类</h6><p>花露水、宝宝金水（防蚊！！！军训期间晚训的时候不喷会很惨）</p>
<h5 id="7：其他"><a href="#7：其他" class="headerlink" title="7：其他"></a>7：其他</h5><p><strong>能用的大脑</strong></p>
<h3 id="三：军训"><a href="#三：军训" class="headerlink" title="三：军训"></a>三：军训</h3><h4 id="1：军训穿什么"><a href="#1：军训穿什么" class="headerlink" title="1：军训穿什么"></a>1：军训穿什么</h4><p>​    军训期间基本上只能穿军装，根据往年经验，南开大学的军训服包括迷彩的<strong>帽子、外套、t恤、裤子、鞋子</strong>。需要注意的是军装的尺码是否合适，是否有破损，可以考虑自己带上针线布料以防万一。遇到下雨天的时候和清晨出早操的时候需要在里面加衣服，预防感冒。帽子、衣服、裤子、袜子和鞋子都是统一要求的，每天出门前穿着整齐即可，多备几双透气的黑色袜子是极好的，肩章、帽徽<strong>最好缝在衣服和帽子上</strong>，因为它们真的是太不结实了，</p>
<h4 id="2：军训的鞋子"><a href="#2：军训的鞋子" class="headerlink" title="2：军训的鞋子"></a>2：军训的鞋子</h4><p>​    军训的鞋子是统一发的老式胶鞋，训练时间要一直穿，院内活动时听指导员安排。鞋子质量不太好，鞋底比较薄且不平，因此可以采取各种方式增厚鞋垫、增加弹性。去年有同学在网上买了那种运动鞋垫，效果很好。姨妈巾的效果并不好，同学们就不要听信谣言了。另外在发鞋子的时候最好试一试，确保合适舒服，如果需要垫鞋垫记得留好一定的空间。</p>
<p>​    <em>如果你的脚超过46码，物资里就没有你能穿的鞋了，你就可以快乐的穿自个的鞋了</em></p>
<h4 id="3：军训的仪容"><a href="#3：军训的仪容" class="headerlink" title="3：军训的仪容"></a>3：军训的仪容</h4><p>​    不允许配搭首饰，化妆（当然不包括防晒霜啦）和涂染指甲，而且指甲要求不能露出白边。男生的头发高度不能超过一指宽(<em><del>当年我上当了，建议不要轻信，拖不了了再说</del></em>)，校内有理发的地方。女生要把头发盘成丸子头，塞进帽子里。原则上不允许染发烫发，到时候会有专人检查，是蒙混不过去的。一旦真的追究起来，非常麻烦，所以别逾矩。</p>
<p>​    服装上要佩戴帽花、领花、肩章，鞋带要成一字型，到时候排长是都会教的。学校要求一定要穿黑色袜子，系黑色腰带，可以提前准备，也可到校后购买。</p>
<h4 id="4：内务的要求"><a href="#4：内务的要求" class="headerlink" title="4：内务的要求"></a>4：内务的要求</h4><p>​    军训期间会不定时检查内务。具体要求教官会进宿舍讲解，基本上就是桌子上等地方不能摆东西，柜子锁上的话不会有人检查。枕头、洗漱用品、水壶、垃圾桶等有摆放位置的要求。军训被子要叠成豆腐块。而且军训是不能挂蚊帐的（至少白天不能挂），大家要做好防蚊准备。（想当年，我晚上睡觉盖毛巾被，然后把一个棉被叠成豆腐块，晚上拿到桌子上，白天再拿到床上去，毛巾被收到柜子里）</p>
<p>​    军训期间对宿舍卫生和整洁度有很高的要求，每个宿舍的情况关乎到班级及各院荣誉，所以同学们最好能够提前和室友商量好每日的起床时间，留下充足的时间整理宿舍。关于宿舍卫生的评分细则就不赘述了，军训开始会下达明确的规定，什么不能在墙上贴东西啦，不能挂蚊帐啦，总之十分琐碎。</p>
<h4 id="5：军训的活动"><a href="#5：军训的活动" class="headerlink" title="5：军训的活动"></a>5：军训的活动</h4><p>​    会有集体观影活动，但是要写观后感、征文之类的东西。</p>
<p>​    期间还有会各种讲座，有关于安全的、心理的，还有校史介绍。应该在每个校区会邀请一位将军进行讲座（16年八里台邀请的是徐光裕少将，津南邀请的是尹卓少将）</p>
<p>​    院级团委学生组织在军训期间纳新，一般是在迎新晚会时宣讲，面试时间也一般是在晚上。</p>
<p>​    百团大战和校级学生组织纳新（后面详细介绍）是在军训结束之后。晚训的时候会在操场上拉歌，不像白天那么严厉，比较欢乐。19级当年还举行了合唱比赛。</p>
<h4 id="6：军训生活"><a href="#6：军训生活" class="headerlink" title="6：军训生活"></a>6：军训生活</h4><p>​    在津南的同学们可以安心了，宿舍每层楼都有浴室，基本上不用排队，而且宿舍里都有空调，晚上可以睡个好觉了。</p>
<p>​    八里台的空调也已经安装完成，开学之后同学们就可以去租，军训之后纳个凉吧。</p>
<p>​    军训期间多喝水的重要性就不赘述了，记得买个大的密水壶，不要嫌重，等到休息时，就会知道它的重要性了。晚饭一定要节制一点，早饭和午饭一定要吃饱，避免吃太咸或太辣的刺激性食物，因为它会引起肌肤色素沉着和胃痛。容易饿的同学可以多带几颗糖，切忌因为贪食吃撑。在此特别提醒想要借军训之机减肥的女同学们，减肥的机会多得是，千万不要急在这一时，高强度的训练+刻意控制饮食=身体垮掉！</p>
<p>​    在训练期间，如果身体难受的话一定要和教官说，关系到身体健康的问题不要强撑着也不要不好意思，教官都会允许休息一下的。</p>
<h4 id="7：防护措施"><a href="#7：防护措施" class="headerlink" title="7：防护措施"></a>7：防护措施</h4><p>​    建议每位同学都准备防中暑，治感冒，保护胃，促排便的药物，因为水土不服这种东西真的是说来就来，病来如山倒可不是吓人的，生病请假丢了军训分数的事儿小，搞垮自己的身子可就事儿大了。喝不惯藿香正气水的同学记得一定要准备藿香正气片。</p>
<p>​    除了以上这些身体异样时必备的药品，平时的一些保健品同学们也可以预备着，尤其是素日缺乏锻炼的同学，维生素C片、钙片必不可少。当然喝些水溶C也是极好的（很严肃，并没有打广告）</p>
<p>​    要在每次出门前20-30分钟涂抹防晒哦，千万不能刚涂上立马GOGOGO！不要觉得只涂脸部就可以，耳后包括耳朵，脖子尤其是后脖颈才是关键。想要更加完美，最好将防晒霜随身携带，每逢休息时刻就开始涂抹。防晒霜买30倍以上的，效果更好，在此特别提醒，具有防晒功能的BBCCDD霜是不能替代防晒霜的。</p>
<p>​    防护很重要，修复更重要，每天训练完成后一定要修复措施，晒后修复不要贪图便宜，俗话说便宜没好货好货不便宜，一瓶好的晒后修复可以事半功倍。芦荟胶的效果也很不错。军训期间主推补水面膜，面膜的效果因人而异，选择适合自己的才最重要，对于累了一天只想睡觉的同学来说，睡眠面膜也是不错的选择。需要注意的是修复这件事是个长期工程，军训结束后大家也要继续努力哦。</p>
<p>​    大家一定要做好防护和修复着两个步骤，毕竟防晒这件事对大部分人而言，都是防晒伤而不是防晒黑（天然晒不黑的请自动忽略）</p>
<p>​    每年因为蚊虫叮咬导致四肢肿胀的同学不在少数，花露水风油精都是必备的，同学们还可以根据个人的实际情况，准备一些对自己有效的驱蚊药水，电蚊香也是不错的选择，毕竟我开晚上不断电。</p>
<p>​    每天晚上临睡前将自己的腿抬高，使脚悬空，这样加快脚腕血液循环，减少伤病几率。</p>
<p>​    最重要的是——</p>
<p>​    <strong>一定要保管好自己的一！卡！通！军训期间如果丢卡后果不堪设想，你也没有时间去补办！！！毕竟吃穿用都离不开这张亲爱的卡，一定要好好守护它！</strong></p>
<h3 id="四：学习"><a href="#四：学习" class="headerlink" title="四：学习"></a>四：学习</h3><p>​    因为学习这一块儿实在没有能力和精力给每个专业具体的学习建议，所以就以问答的形式展现给大家，只是一些几乎适用于所有人的、比较笼统的建议和经验，大家酌情阅读和参考。</p>
<h4 id="1：基本知识"><a href="#1：基本知识" class="headerlink" title="1：基本知识"></a>1：基本知识</h4><p>​    南开大学的课程分为五类</p>
<h6 id="A类课：通识必修课程"><a href="#A类课：通识必修课程" class="headerlink" title="A类课：通识必修课程"></a>A类课：通识必修课程</h6><p>​    简单说，无论你是哪个学院的，都得上的课，就是A类课。例如：大学语文、大学英语、高数、思修、马原、毛概、史纲、体育等。</p>
<h6 id="B类课：大类基础课程"><a href="#B类课：大类基础课程" class="headerlink" title="B类课：大类基础课程"></a>B类课：大类基础课程</h6><p>​    当然也是必修。就是相同大类的同学都需要修读的课程。以计算机类为例，B类课包含：线性代数、大学物理、高级语言程序设计、数字逻辑等。</p>
<h6 id="C类课：专业必修课"><a href="#C类课：专业必修课" class="headerlink" title="C类课：专业必修课"></a>C类课：专业必修课</h6><p>​    这是某一个专业的必修课，例如计算机科学与技术专业的C类课包含：数据库系统、离散数学等</p>
<h6 id="D类课：专业选修课"><a href="#D类课：专业选修课" class="headerlink" title="D类课：专业选修课"></a>D类课：专业选修课</h6><p>​    这是指某一个专业的选修课，也就是说并不是所有的D类课都要修，修满相应的学分即可毕业——例如2018级物联网工程专业的选修课要求学分为30.5，所有D类课的总学分为150。物联网工程专业的选修课包括汇编语言、JAVA语言与应用、概率论与数理统计、互联网数据库开发等。</p>
<h6 id="E类课：通识选修课程"><a href="#E类课：通识选修课程" class="headerlink" title="E类课：通识选修课程"></a>E类课：通识选修课程</h6><p>​    所有专业都可以选的选修课，一般毕业只要求13-16学分；E类课的选择是最为广泛的，很多课程设置也非常有趣，例如：合唱与指挥、3D打印及应用、西方音乐史、古典诗词的格律与创作、进阶摄影与实践、话剧表演与剧本写作入门、电子游戏与哲学等。每学期选课的时候教务处都会有相应的通知，会发放电子版的选课手册，这里就不详细介绍选课的事情了。有一点需要说明一下，就是如果选课系统中某学院的C或D类课存在“计划外”名额，那就说明可供其他学院选修——例如周恩来政府管理学院的“社会心理学”课程，是社会学相关专业的一个D类课，但有5个计划外名额，那么网络空间安全学院的我就可以选修这门课，只要通过了考试，成绩合格，就能拿到学分。当然，这个学分不可能算作我的D类课学分，而是归到E类课学分当中。所以如果大家对别的学院开设的一些课程感兴趣的话，即使这门课在选课手册中不作为“E类课”出现，你也还是有机会可以修读的哟！</p>
<h4 id="2：六十分万岁？"><a href="#2：六十分万岁？" class="headerlink" title="2：六十分万岁？"></a>2：六十分万岁？</h4><p>​    对于任何一门课程，达到60分（及格）代表着这门课不会对你产生负面影响，因为一旦有挂科，当年的奖学金、评优、转专业、双辅修、双修，以及研究生的推免（保研）肯定就是没有资格了。只要保证课程及格，肯定不耽误你拿毕业证和学位证。60分，可以是你不喜欢、不擅长的、对你不重要的科目要求的最低限度，既然是最低，那就表示不能每科都60分。有一两科打了60多分也正常，课程评分的过程中有一些不可避免的因素，<strong>但如果你门门都是60多分，那基本说明你上了这个大学，也没学会啥。</strong></p>
<h4 id="3：排名什么程度能拿到推免（保研）资格？"><a href="#3：排名什么程度能拿到推免（保研）资格？" class="headerlink" title="3：排名什么程度能拿到推免（保研）资格？"></a>3：排名什么程度能拿到推免（保研）资格？</h4><p>​    南开大学的平均保研率为22%-24%。一般学分绩90分以上都能保研。大多数学生的学分绩都在75-90之间。</p>
<h4 id="4：伯苓班、特色班建议每个同学都报考吗？"><a href="#4：伯苓班、特色班建议每个同学都报考吗？" class="headerlink" title="4：伯苓班、特色班建议每个同学都报考吗？"></a>4：伯苓班、特色班建议每个同学都报考吗？</h4><p>​    不是。</p>
<p>​    对于大多数同学，选择试一试总是没有负面影响的，考上了皆大欢喜，考不上也没什么太遗憾的。（本来就都是几百个中招三四十个，考上肯定有难度）</p>
<p>​    但是，如果对所学专业不是很了解、不知道自己究竟喜欢与否的同学，别报，否则你的大学生活可能会痛不欲生。以伯苓班为例，课程进度极快、难度极大、内容深度广度均远超同专业普通系别，伯苓班致力于培养学术研究型人才，那是需要你真正喜欢，而且坐得住板凳的。比如你被数理科学与大数据试验班录取，理想的专业是“统计”（偏应用的数学类专业），那你就别报考伯苓班，不是伯苓班不好，而是学术研究和你的（应用）目标差得还是很多的，报了你也不喜欢，进去了很痛苦，那就得不偿失了。</p>
<p>​    特色班同理，资源（师资、保研率等等）相比于普通专业肯定是更好，但同样如果你不感兴趣，还是会很痛苦。</p>
<p>​    所以，这一点，不要盲目听从家长的话，<strong>你的未来，你自己决定。</strong></p>
<h4 id="5：我在高考中实际上是超常发挥考进南开的，进来之后会不会学习什么的跟不上啊？"><a href="#5：我在高考中实际上是超常发挥考进南开的，进来之后会不会学习什么的跟不上啊？" class="headerlink" title="5：我在高考中实际上是超常发挥考进南开的，进来之后会不会学习什么的跟不上啊？"></a>5：我在高考中实际上是超常发挥考进南开的，进来之后会不会学习什么的跟不上啊？</h4><p>​    这个问题，首先在前言中我就已经写过，你们当中，“亦不乏‘超常发挥’、欣喜若狂，其实是努力终有回报而顺利考入南开的。”考都考上了，你是有这个能力的，也许你觉得考上南开是幸运，即使有运气的成分在，那也是你日积月累努力的一个爆发的结果。</p>
<h4 id="6：有人说上了大学就轻松了，有人说大学上得比高三还累，我到底信谁的？"><a href="#6：有人说上了大学就轻松了，有人说大学上得比高三还累，我到底信谁的？" class="headerlink" title="6：有人说上了大学就轻松了，有人说大学上得比高三还累，我到底信谁的？"></a>6：有人说上了大学就轻松了，有人说大学上得比高三还累，我到底信谁的？</h4><p>​    <strong>信你自己的生活。</strong></p>
<p>​    首先，“上大学就轻松了”？这个现在看来已经是不可能的了。大学生越来越多，中国人口越来越多，就业压力越来越大，如果你真的放挺了，被人甩到身后去了，那么到时候，你一定会饱尝生活的艰辛。</p>
<p>​    那么，真的比高三还累吗？这是一个赚足了噱头的说法，但我不知道除了唬人以外还有什么意义。首先在你本科的前两年，一定不比高三累，学长帮你们验证过了。你完全不需要每天天不亮就起床去早读，完全不需要吃饭还要跑着去狼吞虎咽，完全不需要每天刷夜挑灯夜战。的确，大学不是那么轻松，但怎么说它和高三也不是一回事。更多的人累，并不是说学习压力更大了，而是需要考虑的事情多了——随着年龄的增长，很多人都觉得生活越来越不易。但其实生活没怎么变，这才是生活本来的面目，只是在此之前，有人（对于绝大多数人，是父母）替你拦下了生活的艰难。从你踏入大学的那一刻起，你才算刚刚走入了生活。所以，大家不必对此恐惧，人如果想得太远，反而容易迷茫。很多事情如果你去焦虑、恐慌，其实没有什么意义，大多是过去了之后，回头再看，不过如此。</p>
<p>​    <strong>但行好事，莫问前程。</strong></p>
<h4 id="7：我到底是该闷头努力学习，还是该让大学生活过得多姿多彩？"><a href="#7：我到底是该闷头努力学习，还是该让大学生活过得多姿多彩？" class="headerlink" title="7：我到底是该闷头努力学习，还是该让大学生活过得多姿多彩？"></a>7：我到底是该闷头努力学习，还是该让大学生活过得多姿多彩？</h4><p>​    这个问题在新生指南的最后讨论。    </p>
<h3 id="五：社团"><a href="#五：社团" class="headerlink" title="五：社团"></a>五：社团</h3><p><em>由于他给的pdf实在难以把图片扒拉下来，详细数据就去他的公众号看吧</em></p>
<h6 id="1：根据什么决定参加什么社团"><a href="#1：根据什么决定参加什么社团" class="headerlink" title="1：根据什么决定参加什么社团"></a>1：根据什么决定参加什么社团</h6><p>​    兴趣</p>
<h6 id="2：我可以报很多社团吗"><a href="#2：我可以报很多社团吗" class="headerlink" title="2：我可以报很多社团吗"></a>2：我可以报很多社团吗</h6><p>​    政策上允许，但没有意义。以一个正常人的承受能力，兼顾学习且没有参加任何学生组织的情况下，最多五个。</p>
<h6 id="3：社团的详细介绍哪里看？"><a href="#3：社团的详细介绍哪里看？" class="headerlink" title="3：社团的详细介绍哪里看？"></a>3：社团的详细介绍哪里看？</h6><p>​    每年军训结束后不久，都会召开“百团大战”——社团秋季纳新会。那时各个社团会在校园指定位置摆摊，在那之前“南开大学团委”公众号将会发布各个社团介绍的推送，也一定要去“百团大战”现场走一走瞧一瞧，到指定摊位去了解各个社团的基本情况。</p>
<h6 id="4：进入社团需要交钱吗？"><a href="#4：进入社团需要交钱吗？" class="headerlink" title="4：进入社团需要交钱吗？"></a>4：进入社团需要交钱吗？</h6><p>​    南开大学进入社团的基本费用是20元，少数社团因活动开展的经费需要，可能多一些，目前笔者已知最贵的入会费为120元。</p>
<h6 id="5：如何留任社长或部长？"><a href="#5：如何留任社长或部长？" class="headerlink" title="5：如何留任社长或部长？"></a>5：如何留任社长或部长？</h6><p>​    你在社团表现得积极一些，上一任的社长和部长就会主动问你知否要留任了。毕竟每年愿意留任的人还是少数。</p>
<h6 id="6：参加社团对评优和奖学金有帮助吗？"><a href="#6：参加社团对评优和奖学金有帮助吗？" class="headerlink" title="6：参加社团对评优和奖学金有帮助吗？"></a>6：参加社团对评优和奖学金有帮助吗？</h6><p>​    没有。说有的都是在骗你。笔者参与过学院的奖学金评定，也研读了20余篇校级、市级以及其他奖学金的评选规则，没有发现参加任何社团会对任何评奖评优有任何帮助。所以说，加入社团，全看你的兴趣。</p>
<h3 id="六：建议大家假期可以自学的知识和技能"><a href="#六：建议大家假期可以自学的知识和技能" class="headerlink" title="六：建议大家假期可以自学的知识和技能"></a>六：建议大家假期可以自学的知识和技能</h3><p><strong>注：以下所列内容均可在B站搜索到教程，没必要花钱请老师辅导。而且B站上点击量高点赞数多的教程大概率比你请的老师教得还好</strong></p>
<h6 id="高数"><a href="#高数" class="headerlink" title="高数"></a>高数</h6><p>​    这个其实不用提前学。高数没那么难，它相当于是大学数学基础这类的课程，如果真的要提前看看的话，微信搜索公众号“高数叔”，那里的课程对新生比较友好。</p>
<h6 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h6><p>​    所有专业都可以学的是python，去B站搜索点击量播放量高的教程。这个语言全球通用且相比于经典的高级语言（如C、C++），对程序员更友好了，也就是学起来难度更小了，所以现在使用得也更为广泛。学会了之后用程序处理一些数据（excel表格）等会更加方便、快捷。</p>
<p>​    再学的话就是C++了，高级编程语言中的经典语言，推荐一个B站up主叫“大胖嗷子”(<em>?</em>)，他录了一些C++的基础教程，对初学者，尤其是之前完全没接触过编程的同学们非常的友好。不过由于个人原因，只更新了一部分，预计九月初能够恢复更新。（你猜为啥我知道的这么详细）</p>
<p>​    有些专业（如医学、法学等）开学后会在python、VB(VisualBasic)中二选一（有的是加上Access数据库三选一）进行修读，从实用性角度来看，选择的优先级为python&gt;Access&gt;VB。</p>
<h6 id="骑自行车"><a href="#骑自行车" class="headerlink" title="骑自行车"></a>骑自行车</h6><p>​    学吧，不然校园里满地的共享单车（津南是共享电动车），看着别人骑车带妹你只能干瞪眼。(<del>会骑了也不一定有妹</del>)</p>
<blockquote>
<p>“你想坐我的自行车吗？”“你就不能加个宝贝吗？”“你想坐我的宝贝自行车吗？”    </p>
</blockquote>
<h6 id="PS-PR-AE"><a href="#PS-PR-AE" class="headerlink" title="PS,PR,AE"></a>PS,PR,AE</h6><p>​    PS（AdobePhotoshop），修图神器；</p>
<p>​    PR（Adobepremiere）、AE（AdobeAfterEffects），图形视频处理软件。学会了他们，你一定会在某个不经意的瞬间，于某项选拔或竞赛中脱颖而出。</p>
<h6 id="Office-WPS（能用Office别用WPS，WPS真的烂）"><a href="#Office-WPS（能用Office别用WPS，WPS真的烂）" class="headerlink" title="Office/WPS（能用Office别用WPS，WPS真的烂）"></a>Office/WPS（能用Office别用WPS，WPS真的烂）</h6><p>​    办公必备，早晚都要用上的，包括PPT制作，上了大学之后会有很多需要制作PPT展示的课程和活动，可以提前学一些技巧、攒一些模板。</p>
<p>​    <em>这里我自吹一波，我的PPT水平应该算比较高的了，感兴趣的可以在博客置顶文章中找到我的联系方式，向我咨询哦</em></p>
<h6 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h6><p>​    这个属于上了大学也一直“药不能停”的科目。直接上干货：安利一些APP：</p>
<p>​    单词：扇贝单词、百词斩</p>
<p>​    听力：朗易思听、BBC英语</p>
<p>​    口语：英语流利说</p>
<p>​    阅读：扇贝阅读</p>
<p>​    还有网易公开课的TED演讲，以及近五年的四六级真题。</p>
<h6 id="吃好玩好。"><a href="#吃好玩好。" class="headerlink" title="吃好玩好。"></a>吃好玩好。</h6><p>​    相信大家无师自通</p>
<h3 id="七：写在最后"><a href="#七：写在最后" class="headerlink" title="七：写在最后"></a>七：写在最后</h3><p>​    回顾我和嘉皮同学在前言中写下的一段话：</p>
<p>​    “我们知道，这其中不乏高考发挥失常，与理想的高校失之交臂的；亦不乏‘超常发挥’、欣喜若狂，其实是努力终有回报而顺利考入南开的。也有一些学弟学妹——本就带着‘学长，想好了，还是选南开！非常希望成为南开再度崛起的见证者，更荣幸即将成为这一过程的建设者！’的愿望和理想，来到了南开。”</p>
<p>​    可能在此之前，你觉得高考就是人生的头等大事——也的确，那个时候，我们可以只顾着学习，就是为了在高考这一关键时刻，拿到一个更理想的分数。不过，不管你是失利还是“超常”，大学读过一两年，你会发现高考结束，并不代表一切就结束了，或者说你的人生并不会因此定性。高考的结果，只能代表高中三年以来你的努力程度以及你在高考时的运气和命数，以后的路还很长，要一直加油。“<strong>你的价值不会因为高考的意外而崩盘，只会因为处事散漫而折损。即使侥幸有短暂的溢价，也迟早会还回去。总有一天，价格会回归到某个足以匹配你的价值。所以不用过度在意这个关卡，一切都是你付出后所应得的</strong>。”</p>
<p>​    那么就出现了这个非常现实、几乎每个准大学生都会关注和好奇的问题，这个问题的答案很可能会影响我们接下来人生的走向，而且，关于这个问题的任何答案，总是带有强烈的主观性和一点玄学的东西在里面。这个问题就是：</p>
<p>​    <strong>上了大学以后，最重要的事情是什么，还是学习吗？</strong></p>
<p>​    也许你从百度、贴吧、知乎甚至微博上，以及从联系到的学长学姐、家长亲戚、师长朋友的口中，可以获得无数的答案，那些答案，个个有理有据，每个都比我的文笔更具吸引力，更能够打动你。</p>
<p>​    但是，到底该听信哪种建议呢？</p>
<p>​    在写下我的分析之前，请大家思考一个问题：</p>
<p>​    <strong>为什么人的袜子经常只丢一只？</strong></p>
<p>​    我曾看到过一个回答很有意思——<strong>因为两只都丢了的话，你不容易发现。</strong></p>
<p>​    2018年全国Ⅱ卷高考作文题目，相信大家肯定见过、练过：</p>
<p>​    “二战”期间，为了加强对战机的防护，英美军方调查了作战后幸存飞机上弹痕的分布，决定哪里弹痕多就加强哪里，然而统计学家沃德力排众议，指出更应该注意弹痕少的部位，因为这些部位受到重创的战机，很难有机会返航，而这部分数据被忽略了。事实证明，沃德是正确的。</p>
<p>​    ”经常刷抖音、朋友圈的朋友，你们可能会觉得买名牌包、吃豪餐、开豪车、买名牌球鞋、境外旅游疯狂消费已经是中国常态。但其实呢，在你朋友圈炫耀的同学，可能明天就让你帮他砍一刀拼多多。</p>
<p>​    所以身边、包括市面上的成功案例，其实很多都是那些带着弹孔但幸免于难成功返航了的飞机，他们指着身上的弹孔，教我们如何进攻，如何躲避，如何防御。</p>
<p>​    何况，更多人还会藏起一些弹孔，不让人发现。</p>
<p>​    那么，当我们去飞的时候，还回得来吗？</p>
<p>​    所以回到那个问题，到底该听信哪种建议呢？</p>
<p>​    笔者认为，<strong>不要完全听从任何人的建议，路要自己走。</strong></p>
<p>​    基于笔者的这个想法，在新生指南的最后一段话中，笔者将不会给出任何实质性的建议，但会根据自己的经验以及对数位来自全国各地、就读于不同学院不同专业的同学的采访和咨询，对一些做法和选择的优劣进行分析，并将分析的结果呈现给大家。</p>
<p>​    上了大学以后，最重要的事情还是学习吗？</p>
<p>​    在这里，笔者只是陈述一些事实。</p>
<p>​    奖学金听说过吧？按什么评定的？主要是学分绩，你可以简单理解为课程的总评成绩。有没有加分？有，以学分绩为基础分，如果满足加分的条件，评定时可以加分。举个例子，A的学分绩是86.4，B的学分绩是86.3，但是B在大一做了一年班长，可以获得0.4分的加分，所以评定奖学金时A的分数是86.4，而B的分数就是86.7，则B排名在A之前。虽然存在加分，但只有当你获得国家级认证竞赛一二等奖或在SCI级别的期刊上发表了论文，才有超过1分的加分。也就是说，加分还是微乎其微的，基础仍是学分绩——就是学习成绩。</p>
<p>​    保研——毫无疑问就是跟学习成绩有关了，如果你的学分绩排名不到全系的前20%，保研的希望就比较渺茫了。当然，应征入伍两年也可以保研，不过这条路就不是谁都能走得了的了。</p>
<p>​    申请各种评优，几乎都有对成绩的要求（基本前50%）。成为社团学生干部（主席、部长等）的要求是学分绩在全系前50%（2019年起施行的新规定）</p>
<p>​    这些对你们来说很直观，我也不必再多说，所以，学习很重要。</p>
<p>​    那么，是不是学好了本科这些知识，就可以高枕无忧了呢？</p>
<p>​    以计算机类专业为例，可能大学四年，你学过6，7种编程语言——C、C++、JAVA、PHP、汇编……最后写的毕业论文是关于python的，而python可能只是你在B站和github上自学的一种语言，但它相对简单，反而写论文更容易。这是很现实的问题。而且，上了大学，你以为终于可以学一些以后能够用到的东西了吗！其实，不好说！还是有很多东西就业之后完全用不上的！</p>
<p>​    那么既然用不上，是不是就没用呢？</p>
<p>​    首先，很多课程是基础，就像“数字逻辑”和“模拟电子技术基础”这两门看似和计算机毫无关系的课程，却对“计算机组成原理”这门课的深入理解起到至关重要的作用。同时，从功利性的角度，我们学习这些课程，拿到不错的成绩，证明了在一个相对统一的标准下，我们的学习能力是非常不错的——这是你去考研究生、出国、保研、奖学金以及以后就业的一个敲门砖啊。</p>
<p>​    而你当初打下的基础，不止是大学本科阶段，小学、初中、高中，包括你读过的书，一切你认为学了对你以后的工作没有任何用处的知识，在潜移默化中对你产生的影响，终有一天会爆发出来，让你成为发光的金子，让你成为脱颖而出的一员。</p>
<p>​    那么大学最重要的事情就是学习了吗？其他事情呢？</p>
<p>​    南开给你们提供了无数机会，能够让你的大学生活变得多姿多彩，那么究竟哪些机会值得我们去把握呢？</p>
<p>​    社团要不要参加呢？</p>
<p>​    南开社团有上百个供你选择。中国的高考制度相对公平，但残酷。是不是曾几何时，你的兴趣已被完全抹杀？那种单纯的快乐有多久没有体验过了？大学，这些东西又回到你面前，你心动了吗？和有着相同兴趣的朋友们一起度过快乐的时光，真的很珍贵，很美好。但这个时候你非要煞风景地问一句“这对我的保研、奖学金和学分绩有帮助吗？”，那我也只能直白地回答你：“没有。”</p>
<p>​    学生组织要不要参加？</p>
<p>​    想清楚你参加学生组织的目的是什么。我见过的无非是以下几种：</p>
<p>​    第一是想要<strong>锻炼自己、提升能力</strong>的，这一点是很对的，我们现在很多都是独生子女，在上大学前，除了学习，你考虑过其他什么事情吗？有很多觉得自己高中时代人际关系复杂，失去了一个朋友就觉得天都要塌下来了，这个或许到了大学，在生活面前都不值一提。太多人，不懂得如何与人交往和相处了，这一点，在你做了至少一年的学生干部后，会有很大的改观——甚至会刷新你的人生观（这句话，在年少轻狂的时代，并不一定是贬义）。</p>
<p>​    第二种就是<strong>想认识、结交更多的人，发展更广的“人脉”。</strong>做学生干部肯定有这方面的好处和意义，这一点毋庸置疑，不过要明白人以群分，物以类聚，唯有志同道合的人才算得上是人脉，而就以现在年轻人的包容度，找一个志同道合的人是真难。当然，自己要足够优秀，那么就又需要你努力学习了，因为真金找的起码是白银，臭鱼找的大多是烂虾，这一条应该时刻铭记，并以此来判断，你要投入多少精力在这个“人脉”上。</p>
<p>​    第三种，非常现实地期待做<strong>学生干部对自己的未来起到一个直接的助力作用</strong>。比如，期待评奖学金的时候能加分，期待（例如应聘面试选拔时）在笔试成绩相差无几的情况下，自己能够凭借做学生干部的经历，力压对手，获得胜利。但这个要分情况的，可能对于公共管理类专业，这方面的经历会加很多分，但对于计算机类的专业来说，做学生工作的经历就大概率不会成为让HR眼前一亮的事情。而且，对于奖学金加分来说，以某学院的奖学金评定细则来看，做一年班长，评奖学金的时候有0.4分的加分，而校运动会某单项比赛取得第一名，就有0.8的加分。所以，如果就是非常功利地想要凭借学生工作来“加分”，实话跟你讲，意义不大，慎重。</p>
<p>​    第四种——现在的绝大多数人无法想象，<strong>有的人生来就是带有那么强的责任感，有的人就是为中华之崛起而读书，有的人做学生干部是为了给南开的复兴添砖加瓦</strong>。这样的格局不是所有人都能理解的，并会被很多人暗地里称为虚伪和愚蠢。这里，我就不多介绍了，你当然可以不选择将这作为人生的信条，但每个理想都值得赞扬、尊重和敬佩。</p>
<p>​    其实，不要把学习和社团、活动以及学生工作分得那么清，因为“学习”远不该单单只指专业知识的学习，为人处事、同学关系、师生关系、恋爱关系的处理等等，同样重要，谁也不能说哪个最重要，因为它们<strong>都可能帮助你发展，也都可能阻碍你发展</strong>。</p>
<p>​    我亲戚家的孩子，本科是吉林大学，大学拿了四年奖学金，考研成功考入同济（车辆工程），现在在上海某科研所任职，铁饭碗。</p>
<p>​    我某亲戚同事家的孩子，大学期间成绩排名前三，当年稳妥选择进入体制内，后经过改革，经历了岗位调动，由于性格极其不讨喜，职位不升反降，好在薪水还维持在那个城市的平均水平，贷款买了一个小房子，并靠着自己的努力供房。</p>
<p>​    另一个身边的学姐，南京大学，当年全系成绩倒数前十，但幸遇伯乐识才，现在年底薪80万，公司的年终奖比底薪还高。</p>
<p>​    我不是在给你灌毒鸡汤，你不是问我学习是不是最重要的吗？我为什么不说“学习就是最重要的，你只顾着学好习就行了”这种话，因为时代变了。你真的不能只顾着好好学习那点专业知识，就完事儿了。你也看到这几个例子了，大学努力学习，可能带给你的也只是普通的人生，那难道你就不学了吗？我说过我们这一代大多是独生子女，从小你要什么，可能家里都会满足你，到了大学，想要一切按照你预期的去发展，太难了。我再直白点说，你想要的东西，你不可能全部得到。人外有人，要认清自己，要学会知足常乐，不要和任何人攀比，要和过去的自己比——只要你在进步，你的人生就会勇往直前。</p>
<p>​    利弊基本都说清楚了，每个人的时间和精力都是有限的，具体怎么选择，看你们自己的想法了。</p>
<p>​    在最后这段话中，我没有给出任何实质性的建议，而是将一些经验和情况叙述出来，供大家参考。我还是那个观点：路，你自己选；自己选的路，自己走，不后悔。</p>
<p>​    最后的最后，谈一谈<strong>“喜欢”</strong>和<strong>“幸福”</strong>。</p>
<p>​    根据我的观察和感受，以及不太科学的抽样调查，上了大学后，身边更多的人在生活上幸福感较强，也就是说他们在南开大学的生活，大多时候还挺快乐的。但是，在学习方面，更多人并不快乐。</p>
<p>​    你回想一下你报志愿的时候，你填报专业的顺序，真的是按照你的喜好顺序填的吗？是不是绝大多数人都把金融放在第一志愿了？为什么呀？因为金融往年的分最高，这个专业最火。那你喜欢金融吗？你不知道，或者可能根本就不喜欢，不想学。</p>
<p>​    这就是大多数人选择专业的真实现状。其实真的，到大学学了几年之后，你会发现<strong>其实身边有很多人只是盲目地选择了某个专业</strong>，也不知道自己喜不喜欢，就是凑热闹报一些往年分数段高、比较“热”的专业，然后就来了。学了一段时间后，发现自己其实也不喜欢这个专业，想调整，放下课业等客观因素的考虑，调整到哪儿？还是不知道。因为稀里糊涂地也不知道自己究竟喜欢啥。有多少人，一辈子，都不知道自己究竟喜欢什么。所以，<strong>如果你知道、确信你喜欢一样东西、一个专业、一个城市、一个人，一定要去努力、勇敢地追寻</strong>，否则你一定会在某一天后悔——因为你大概率是不快乐的。当然，不是说你选择了喜欢的专业，就一定能够人生得意、一帆风顺，没有谁的生活能够一直顺风顺水，但因为你在做你喜欢的事情，你在追求自己的梦想和理想，所以即使有的时候很困难，你也是快乐的。这些事情，也许现在你不太能理解，你的家长更不能理解，而当你能理解的那天——就像现在的我，再想去追求自己最初的梦想，沉没成本已经太高了，迫于现实，迫于压力，考虑到种种因素，相比于填报志愿或早两年时就作出正确选择，已经是很难很难了。做喜欢的事情就会开心，这一点，不难理解吧？人活着谁还不是为了图个开心？中考高考的残酷制度，已经让你丧失了很多珍贵的东西，终于有了可以追寻自己喜欢的东西的机会，不要错过！！！</p>
<p>​    或许还会有很多人问，南开没落了吗？</p>
<p>​    也许相比于西南联大的时代，南开排名仅次于清华北大的历史已远去，但真就不复返了吗？2019年初，南开的发展得到了更进一步的支持，2018年新成立的人工智能专业，已经能够排到全国前五的水平；计算机类的评级迅速提升两个档次；南开没有忘本，化学、数学、历史等自南开建校以来就存在的专业经久不衰，金融、经济专业在985高校中名列前茅，工科专业也在飞速进步……南开的实力是不及当年，但南开没有沉沦！没有没落！南开的发展和复苏肉眼可见，只是我们比较低调，我们也没有什么文工团之类的专门去宣扬这些，而只有当你进来南开学习、生活了，你就能真切地感受到我说的一切。</p>
<p>​    我在招生组做志愿者的时候，对学弟学妹们说的最多的一段话就是，进了南开以后，的确有因为自己的专业选得不那么合适，而后悔的；但我身边，没见过有人因为选择了南开大学这所学校而后悔。</p>
<p>​    南开大学完美吗？不可能。我也对南开失望过，在我心里南开还能更好，当然，她也真的在变得越来越好。</p>
<p>​    <strong>在南开学习是一件幸福的事情，</strong>即使我学的专业，我自己其实并不怎么喜欢，但在南开的生活，已经让我非常地快乐。</p>
<p>​    可能现在的你有了自己的另一半，或是还在找寻另一半的路上，恋爱这个事情，宁缺毋滥——看人要看他的人格品格，<strong>两个人在一起的话至少要三观一致，并达到1+1&gt;2的效果。同时也要记得，一切要以自己能够变得更好更优秀、生活开心为核心，因为只有自己活得漂亮才能走得更远。</strong></p>
<p>​    如果假期出去玩的话，切记要合理规划行程，保护好自己的安全！</p>
<p>​    最后的最后的最后，记得<strong>感恩</strong>，感恩朋友的陪伴，感恩父母的养育，感恩母校的培养，感恩爱你的、你爱的一切，感恩伟大的祖国。</p>
<p>​    愿学弟学妹们：健康幸福，平安喜乐，生活顺意；</p>
<p>​    付出总有回报，念念不忘的皆有回响。</p>
<p>​    最最最最最后，期待在金秋时节的南开园，与新鲜的、满怀希望和憧憬的你们相遇！</p>
<div style="text-align: right"> 大胖嗷子，嘉皮  </div>

<div style="text-align: right"> 2020/08/10  </div>

<p><img src="https://i.loli.net/2020/08/17/IUwSDysWbfXTCZn.jpg" alt="嘻嘻嘻.jpg"></p>
]]></content>
      <tags>
        <tag>恶魔的轻语闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Android：布局，TextView和Button</title>
    <url>/2020/08/09/Android%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%8CTextView%E5%92%8CButton/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Android：UI组件-1"><a href="#Android：UI组件-1" class="headerlink" title="Android：UI组件(1)"></a>Android：UI组件(1)</h1><p>承接上一篇的内容，我们所写的Hello Android程序其实很大一部分是默认生成的，而我们想要写一个自己的程序的话，那么这些东西我们一定需要了解：布局，TextView(文本框)和Button(按钮)。下面，我们就依次对这些东西进行介绍。</p>
<a id="more"></a>

<h2 id="布局：线性与相对"><a href="#布局：线性与相对" class="headerlink" title="布局：线性与相对"></a>布局：线性与相对</h2><p>Android中最常见的两种布局形式分别是线性布局<strong>LinearLayout</strong>和相对布局<strong>RelativeLayout</strong>，我们分别来讲一下他们的常用属性及用法。</p>
<h3 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h3><p>线性布局LinearLayout的常用属性包括</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">	android:id		</span><br><span class="line">	android:layout_width		</span><br><span class="line">	android:layout_height		</span><br><span class="line">	android:background</span><br><span class="line">	android:layout_margin					</span><br><span class="line">	android:padding				 </span><br><span class="line">	android:orientation	&gt;</span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>需要使用线性布局时，在app/src/main/res/layout目录下的activity_main.xml中将原先的androidx.constraintlayout.widget.ConstrainLayout替换为LinearLayout。</p>
<p>我们在根布局下创建一个新的线性布局来说明上面几个属性的使用方法，在根布局中添加以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;ll_1&quot;					&#x2F;&#x2F;起一个名字，方便使用</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;		&#x2F;&#x2F;宽度 匹配父节点</span><br><span class="line">        android:layout_height&#x3D;&quot;500dp&quot;			&#x2F;&#x2F;高度 200dp</span><br><span class="line">        android:layout_margin&#x3D;&quot;20px&quot;			&#x2F;&#x2F;外边距 20px</span><br><span class="line">        android:padding&#x3D;&quot;20px&quot;					&#x2F;&#x2F;内边距 20px</span><br><span class="line">        android:background&#x3D;&quot;#7E0C6E&quot;			&#x2F;&#x2F;背景颜色 7E0C6E</span><br><span class="line">        android:orientation&#x3D;&quot;horzontal&quot;&gt;		&#x2F;&#x2F;布局方向 水平</span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>其中layout_width和layout_height具有三种选项：match_parent(匹配父节点)，wrap_content(匹配内容)和自定义长度，在上面例子中分别使用了match_parent和自定义长度两种。orientation是线性布局中必须的属性，他指明了布局的方向，有两个值：vertical(垂直布局)和horizontal(水平布局)</p>
<p>再在这个ll_1的布局下添加代码，往该布局中添加两个view，预览和代码如下，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;v_1&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;175dp&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_marginRight&#x3D;&quot;50px&quot;		&#x2F;&#x2F;右外边距 50px</span><br><span class="line">    android:layout_marginTop&#x3D;&quot;50px&quot; &gt;		&#x2F;&#x2F;上外边距 50px</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;view</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;v_2&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;175dp&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;	</span><br><span class="line">    android:layout_marginLeft&#x3D;&quot;50px&quot;		&#x2F;&#x2F;左外边距 50px</span><br><span class="line">    android:layout_marginBottom&#x3D;&quot;50px&quot;&gt;		&#x2F;&#x2F;下外边距 50px</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/08/09/8E7YSk4OGN6HeUy.png" alt="LL1.png"></p>
<p>值得一提的是LinearLayout中还有这些比较常用的属性，在下面进行列举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 布局居中 布局水平居中 布局垂直居中</span><br><span class="line">android:gravity &#x3D; &quot;center|center_horizontal|center_vertical&quot;</span><br><span class="line">&#x2F;&#x2F; 权重分配，在布局的子元素中添加这些元素，自动按照权中排版</span><br><span class="line">android:layout_weight &#x3D; &quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a><strong>RelativeLayout</strong></h3><p>同样的相对布局RelativeLayout除了线性布局中的高度宽度等，还有一些特有的属性，列举在下面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;RelativeLayout</span><br><span class="line">	android:layout_toLeftOf					&#x2F;&#x2F;在谁左边</span><br><span class="line">	android:layout_toRightOf				&#x2F;&#x2F;在谁右边</span><br><span class="line">	android:layout_alignBottom				&#x2F;&#x2F;和谁底部对齐</span><br><span class="line">	android:layout_alignParentBottom		&#x2F;&#x2F;和父空间底部对齐</span><br><span class="line">	android:layout_below 					&#x2F;&#x2F;在谁下面	&gt;</span><br><span class="line">&lt;&#x2F;RelativeLayout&gt;</span><br></pre></td></tr></table></figure>

<p>添加下面这段代码，就能很直观的看出用法了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;初始默认 红色</span><br><span class="line">&lt;TextView</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;v_1&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:background&#x3D;&quot;#FF0000&quot;&gt;</span><br><span class="line">   &lt;&#x2F;TextView&gt;</span><br><span class="line">&#x2F;&#x2F;第二个 在第一个的右边 蓝色</span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;v_2&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:background&#x3D;&quot;#0000FF&quot;</span><br><span class="line">       android:layout_toRightOf&#x3D;&quot;@+id&#x2F;v_1&quot;</span><br><span class="line">       android:layout_marginLeft&#x3D;&quot;20px&quot;&gt;</span><br><span class="line">   &lt;&#x2F;TextView&gt;</span><br><span class="line">&#x2F;&#x2F;第三个 在第一个的上层，和第二个底部对齐 黑色</span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;v_3&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;50dp&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;50dp&quot;</span><br><span class="line">       android:background&#x3D;&quot;#000000&quot;</span><br><span class="line">       android:layout_alignBottom&#x3D;&quot;@+id&#x2F;v_2&quot;&#x2F;&#x2F;底部对齐</span><br><span class="line">       android:layout_marginLeft&#x3D;&quot;20px&quot;&gt;</span><br><span class="line">   &lt;&#x2F;TextView&gt;</span><br><span class="line">&#x2F;&#x2F;第四个 在第一个下面 青色</span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;v_4&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;50dp&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;50dp&quot;</span><br><span class="line">       android:background&#x3D;&quot;#69C4DA&quot;</span><br><span class="line">       android:layout_below&#x3D;&quot;@+id&#x2F;v_1&quot;</span><br><span class="line">       android:layout_marginTop&#x3D;&quot;50px&quot;&gt;</span><br><span class="line">   &lt;&#x2F;TextView&gt;</span><br><span class="line">&#x2F;&#x2F;第五个 和父空间底部对齐 紫色</span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;v_5&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:background&#x3D;&quot;#7E0C6E&quot;</span><br><span class="line">       android:layout_alignParentBottom&#x3D;&quot;true&quot;&gt;</span><br><span class="line">   &lt;&#x2F;TextView&gt;</span><br></pre></td></tr></table></figure>

<p>他的预览结果如下(最外层的黑框是截图时没有截好，不碍事)</p>
<p><img src="https://i.loli.net/2020/08/11/FTqL8XrYWw6jMoN.png" alt="RL1.png"></p>
<h2 id="内容：文本和按钮"><a href="#内容：文本和按钮" class="headerlink" title="内容：文本和按钮"></a>内容：文本和按钮</h2><p>有了布局以后，我们需要一些容器来存放我们的内容。这时我们就需要这样两个元素：TextView和Button。因为篇幅实在长而且代码其实不多。就在下面用代码块的形式给大家列举吧。(<del>偷懒了你能怎么着反正我马上考科四我有理由我理直气壮</del>)</p>
<h3 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;文字大小</span><br><span class="line">	android:textSize &#x3D; &quot;&quot;</span><br><span class="line">&#x2F;&#x2F;文字颜色</span><br><span class="line">	android:textColor &#x3D; &quot;&quot;</span><br><span class="line">&#x2F;&#x2F;显示不全用...代替</span><br><span class="line">	android:ellipsize &#x3D; &quot;end&quot;</span><br><span class="line">&#x2F;&#x2F;文字＋图标 要先把需要的图标放在&#x2F;res&#x2F;drawable下,right可以换成其他方向</span><br><span class="line">	android:drawableRight &#x3D; &quot;@drawable&#x2F;图标&quot;</span><br><span class="line">&#x2F;&#x2F;循环 比较多</span><br><span class="line">    android:singleLine &#x3D; &quot;true&quot; 					&#x2F;&#x2F;不换行</span><br><span class="line">    android:ellipsize &#x3D; &quot;marquee&quot;					&#x2F;&#x2F;循环</span><br><span class="line">    android:marqueeRepeatLimit &#x3D; &quot;marquee_forever&quot;	&#x2F;&#x2F;循环次数</span><br><span class="line">    android:focusable &#x3D; &quot;true&quot;						&#x2F;&#x2F;可以聚焦</span><br><span class="line">    android:focusableInTouchMode &#x3D; &quot;true&quot;			&#x2F;&#x2F;聚焦时生效</span><br></pre></td></tr></table></figure>

<p>中划线和下划线比较特殊 ，需要在java中改而不是xml中，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; activity_main.xml</span><br><span class="line">    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">    &lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;t1&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:text&#x3D;&quot;WCH is Handsome&quot;</span><br><span class="line">            android:textSize&#x3D;&quot;30sp&quot;</span><br><span class="line">            android:textColor&#x3D;&quot;#000000&quot;&gt;</span><br><span class="line">        &lt;&#x2F;TextView&gt;</span><br><span class="line">    &lt;&#x2F;LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MainActivity.java</span><br><span class="line">    public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">        private TextView t;&#x2F;&#x2F;声明控件</span><br><span class="line">        @Override</span><br><span class="line">        protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">            super.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line">            t &#x3D; (TextView) findViewById(R.id.t1);</span><br><span class="line">            t.getPaint().setFlags(Paint.STRIKE_THRU_TEXT_FLAG);&#x2F;&#x2F;中划线</span><br><span class="line">            t.getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG);&#x2F;&#x2F;下划线</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;文字大小 颜色 背景颜色 和文本中一样</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;背景形状 圆角 在&#x2F;res&#x2F;drawable下添加shape文件 以btn.xml为例</span><br><span class="line">    &#x2F;&#x2F;btn.xml</span><br><span class="line">        &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">        &lt;shape xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">            android:shape&#x3D;&quot;rectangle&quot;&gt;</span><br><span class="line">            &lt;corners</span><br><span class="line">                android:radius&#x3D;&quot;5dp&quot;&#x2F;&gt;</span><br><span class="line">    	&lt;&#x2F;shape&gt;</span><br><span class="line">    &#x2F;&#x2F;activity_main.xml</span><br><span class="line">    	android:background &#x3D; &quot;@drawable&#x2F;btn&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按压效果 在&#x2F;res&#x2F;drawable下添加selector文件 以btn2.xml为例 使用方法同上</span><br><span class="line">    &#x2F;&#x2F;btn2.xml</span><br><span class="line">        &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">        &lt;selector xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">            &lt;item android:state_pressed&#x3D;&quot;true&quot;&gt; &#x2F;&#x2F;按压时紫色</span><br><span class="line">                &lt;shape&gt;</span><br><span class="line">                    &lt;solid android:color&#x3D;&quot;#7E0C6E&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;shape&gt;</span><br><span class="line">            &lt;&#x2F;item&gt;</span><br><span class="line">            &lt;item android:state_pressed&#x3D;&quot;false&quot;&gt; &#x2F;&#x2F;不按压时黑色</span><br><span class="line">                &lt;shape&gt;</span><br><span class="line">                    &lt;solid android:color&#x3D;&quot;#000000&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;shape&gt;</span><br><span class="line">            &lt;&#x2F;item&gt;</span><br><span class="line">        &lt;&#x2F;selector&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;事件 需要在java中添加内容</span><br><span class="line">	&#x2F;&#x2F;activity_main.xml</span><br><span class="line">		android:onClick &#x3D; &quot;showToast&quot;</span><br><span class="line">	&#x2F;&#x2F;MainActivity.java</span><br><span class="line">		pubilc void showToast(View view)</span><br><span class="line">		&#123;</span><br><span class="line">			Toast.makeText(this, &quot;WCH is Handsome&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>飙马野郎，末代侠客--Arthur·Morgan</title>
    <url>/2020/08/04/%E9%A3%99%E9%A9%AC%E9%87%8E%E9%83%8E%EF%BC%8C%E6%9C%AB%E4%BB%A3%E4%BE%A0%E5%AE%A2-Arthur%C2%B7Morgan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="飙马野郎，末代侠客–Arthur·Morgan"><a href="#飙马野郎，末代侠客–Arthur·Morgan" class="headerlink" title="飙马野郎，末代侠客–Arthur·Morgan"></a>飙马野郎，末代侠客–Arthur·Morgan</h1><blockquote>
<p>有个没有鼻子的人正在追你，不要睡得太沉，否则他就会追上你</p>
</blockquote>
<p>《荒野大镖客2：救赎》是R星在18年发布的一款关于美国西部拓荒时期的牛仔的游戏，剧情上是其在10年发布的《荒野大镖客》的前传，聚焦于主角亚瑟·摩根，讲述了他传奇而悲剧的一生。</p>
<p>游戏的游戏性和画面无须我来赘述，随便去任何一个论坛都能看到如潮般的好评，独特的设定和细节，宏大的世界地图和丰富的游戏元素带给人的是无比真实的沉浸体验，也因此让玩家被剧情所吸引，因其喜而喜，因其悲而悲。</p>
<p>我就是这么一个被他吸引的玩家，在我们的主角亚瑟·摩根迎来了他人生的结局之时，在为他感到悲痛和惋惜之余，我也想写一点东西，纪念这位西部的飙马野郎，这位复杂的善良黑帮，这位豁达的末代侠客，这位我游戏人生10余年以来印象最深的一位人物。</p>
<a id="more"></a>

<h2 id="温情黑帮"><a href="#温情黑帮" class="headerlink" title="温情黑帮"></a>温情黑帮</h2><p>亚瑟·摩根是西部最臭名昭著的范德林德帮的成员，按资历来算，是帮派内的三把手。他从小便父母双亡，被范德林德帮的老大达奇·范德林德和二把手何西阿·马修斯收养。然而亚瑟并没有成为一名毫无底线的犯罪分子。细心的玩家可以在一系列的追债任务中发现这样一个细节：在亚瑟去讨债时，他会故意将自己的声音压的很低，以此来扮演一个恶人的形象。而在平时在帮派成员和陌生人面前，他只是一个可靠而热心的傻大个。</p>
<p>我个人在沙盒游戏中不是一个爱好胡作非为的人，因此我一直努力让亚瑟的荣誉值保持在很高的水平(拉满)，在每一个支线和陌生人的任务里，我都尽力不违背我的道德水准去做，这也导致了当我控制着亚瑟骑着马在城镇与荒野中漫步时，总是能受到其他人的尊敬和善意。说老实话，比起在洛圣都(《GTAV》的舞台)挥金如土，在西部的荒野听到的一声声问候和感谢更让我心旷神怡。在修女系列任务中解救非法奴隶，在唐斯太太系列任务中完成对过往的救赎，在真爱之路系列任务帮助西部版的”罗密欧与朱丽叶“，在印第安人任务帮助部落争取他们的权益，我们的帮派打手兼熟练劫匪亚瑟似乎不知道怎么去拒绝他人，总是热心的帮助需要帮助的人。而当他们说”谢谢你，摩根先生，你是个好心人“的时候，我们的主角总是微笑地说”No,I’m sure I’m not“，挥手离开。</p>
<p>就像在印第安人线的一个任务中偶遇的修女说的那样，亚瑟对自己善良的本性所知甚少，他或许过着奔狼的生活，但是他的梦中总是有呦呦的鹿鸣，即便在最后一战之后，恶化的肺结核让他奄奄一息的倒在山顶上迎接生命的最后时刻时，也有美丽的雄鹿与他作伴。</p>
<blockquote>
<p>在游戏中如果人物的荣誉值高，在剧情任务结束和睡觉做梦时会梦见平和的日光以及鹿</p>
<p>如果你为非作歹无恶不作的话，在剧情任务结束和睡觉做梦时则会梦见电闪雷鸣以及狼</p>
</blockquote>
<h2 id="叛逆忠臣"><a href="#叛逆忠臣" class="headerlink" title="叛逆忠臣"></a>叛逆忠臣</h2><p>无论是从一开始的黑水镇银行劫案，还是到后来的圣丹尼斯银行劫案，亚瑟从来没有想过要背叛帮派。就算达奇逐渐偏离了他的原则–不杀妇孺，就算达奇对身处险境的其他成员和亚瑟自己见死不救，就算达奇选择相信告密者迈卡·贝尔而不是视其为家人的亚瑟，亚瑟也从来没有想过要反抗达奇。</p>
<p>但是，亚瑟在帮派里极好的名声让达奇对他感到恐惧，亚瑟的坚守原则也让他们的分歧越来越多，即使亚瑟每次到最后都选择服从，依然没有办法填补达奇的恐惧。</p>
<p>亚瑟也同样认识到了这一点，但他没有选择背叛。他只是尽力去保护帮派的成员，劝说自己的好友趁机脱离这样动荡的生活。他的肺结核让他成为了最需要休息和安宁的那个人，而他所做的却是用他的最大努力去帮助其他人获得安宁。</p>
<p>从被达奇收养的那一刻开始，直到范德林德帮的覆灭，亚瑟从未有过背叛的念头，比达奇在帮派上投入了更多的心血，直到他死前，还在想着让他的好兄弟约翰·马斯顿逃出升天。也正是因此，当数年过去，过上安稳日子的帮派成员相遇时，依旧会想起亚瑟的好，会想帮亚瑟报仇雪恨，不过我想这不是亚瑟所愿的，他应该只想要他们平安。</p>
<h2 id="末代侠客"><a href="#末代侠客" class="headerlink" title="末代侠客"></a>末代侠客</h2><p>纵使亚瑟身强力壮，百步穿杨，但是他这样的人是不被时代所容忍的。当时的美国正是西部拓荒时期，整个西部在不可逆的大势驱动下，脱离野蛮，走向文明。而对于亚瑟这种人而言，纵马骋天涯才是他的归属。况且，就算他平时与人为善，声誉很高，但是他毕竟是一个黑帮，是政府悬赏通缉的对象，不管是好的亡命徒还是坏的亡命徒，他们的结局大多相似。</p>
<p>随着游戏的推进，主角一行人也不断地在更变根据地，从西部的雪山到南部的乡村，再到东部的城市，他们逃亡的路线和文明前行的方向是一样的，不论他们怎么逃，往哪儿逃，最后都逃不出被淘汰的命运。英雄在时势面前也显得渺小，更何况只是一个平凡人的亚瑟·摩根。</p>
<p>侠以武犯禁，故为世所不容。只是摩根必须要为犯下的错误承受被追捕的代价，这样一想，或许病死山顶对他是最好的归属。</p>
<p>如果生在不同的时代，我相信亚瑟会过上富有名望的一生，如果没有被范德林德帮收养，我相信亚瑟会成为一个不折不扣的正派人。但是没有如果，我这种他人生的旁观者只能畅想其他种种可能，只能希望在他漫长的梦境中，有烈马好酒，鸟啼鹿鸣。</p>
]]></content>
      <tags>
        <tag>爱玩游戏的WCH的存档</tag>
      </tags>
  </entry>
  <entry>
    <title>Android：概述与工具</title>
    <url>/2020/08/03/Android%EF%BC%9A%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Android：概述与工具"><a href="#Android：概述与工具" class="headerlink" title="Android：概述与工具"></a>Android：概述与工具</h1><h2 id="Part-1：Android工具准备"><a href="#Part-1：Android工具准备" class="headerlink" title="Part 1：Android工具准备"></a>Part 1：Android工具准备</h2><p>从今天开始，我所参与的创新项目就要正式开工了。我们打算开发一个Android程序，但是组里没有一个人有过开发经验，就很烦。因此开始一个新的系列–Android开发，用这一系列的blog记录我的开发过程和学习过程。话不多说，进入下一P。</p>
<p>Android是由Google开发的一种基于Linux系统的操作系统，是一种开发移动应用的表现形式。目前最常用的开发工具是 <strong>Android Studio</strong>。</p>
<a id="more"></a>

<p>为了进行Android的开发，我们首先要安装一个JDK，因为Android开发的语言是Java语言，可以参考<a href="https://blog.csdn.net/pu329289309/article/details/104883458/" target="_blank" rel="noopener">这个网址</a>进行JDK的安装，这里不作为重点介绍。</p>
<p>另外一个工具就是我们所说的Android Studio，可以在<a href="http://www.android-studio.org/" target="_blank" rel="noopener">AS中文社区</a>中找到其安装包并进行下载，下载好了之后就可以进行安装了，安装过程中没有什么好说的，一路next就可以轻松搞定。</p>
<p><strong>But</strong>，事情并没有这么简单，安装了之后我们还要对其进行配置，话不多说，先Start Android Studio，然后点击Finish完成安装。</p>
<p>初次打开AS时，会弹出这样的一个界面</p>
<p><img src="https://i.loli.net/2020/08/03/Q8fbGRL1ydEz94j.png" alt="A1.png"></p>
<p>选择第二个，然后会弹出下图。这是因为这个安装包并不包括他要使用的SDK，我们先不管他，点击Cancel进入下一步。</p>
<p><img src="https://i.loli.net/2020/08/03/AIryEHYs2D4ntml.png" alt="A2.png"></p>
<p>之后会进入一个主题选择界面，这些就用它默认的，一路点击Next进入下面这个界面</p>
<p><img src="https://i.loli.net/2020/08/03/HR59fEFYho6jdZe.png" alt="A3.png"></p>
<p>注意到这下面会给你列出来许多你需要使用的SDK，点击Finish开始下载，等待下载完毕后，就可以进入到这样一个欢迎界面了，这代表着我们的AS安装圆满完成了(撒花)</p>
<p>说来惭愧，我还没学过Java(<del>Python是世界上最好的语言</del>)，先写个简单的程序了解一下基本的语法</p>
<h2 id="Part-2：Android应用初体验"><a href="#Part-2：Android应用初体验" class="headerlink" title="Part 2：Android应用初体验"></a>Part 2：Android应用初体验</h2><blockquote>
<p>编程界认为刚接触一门新语言时，如果首先用它来偏写一个在屏幕上显示hello world的程序，将给你带来好运。</p>
</blockquote>
<p>那我们就编写一个Hello Android吧。新建一个Android项目，乱七八糟的设定全部先不管，直接新建一个空的项目。进去以后得到这样一个目录</p>
<p><img src="https://i.loli.net/2020/08/04/HGIqL5c4F3OSfVJ.png" alt="AC1.png"></p>
<p>打开app/res/layout/activity_main.xml，可以看到如下的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    tools:context&#x3D;&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;Hello World!&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>

<p>将TextView中的 android:text = “Hello World”修改为”Hello Android”,按理来说应该就可以运行了，但是却不是这样。这是因为缺少两样东西– <strong>gradle</strong> 和 <strong>AVD</strong></p>
<p>gradle在第一次打开项目的时候会下载，但是他下载的实在是太慢，可以先打开项目目录中的gradle/wrapper/gradle-wrapper.properties，看到这样一行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">distributionUrl&#x3D;https:&#x2F;&#x2F;services.gradle.org&#x2F;distributions&#x2F;gradle-X.X.X-all.zip</span><br></pre></td></tr></table></figure>

<p>他告诉了我们需要什么版本的gradle，然后我们可以打开<a href="https://services.gradle.org/distributions/" target="_blank" rel="noopener">这个网址</a>找到对应的网址下载一个zip文件之后，将其放在C:\Users\username.gradle\wrapper\dists目录下，对应的文件夹的子文件夹下。比如我这个文件用到的是gradle-6.1.1-all，然后在这个目录下会有一个随机生成的字符串命名的文件夹，删除掉里面的所有内容，把下载的文件放到这个目录下，比如我的就是</p>
<blockquote>
<p>C:\Users\49393.gradle\wrapper\dists\gradle-6.1.1-all\cfmwm155h49vnt3hynmlrsdst</p>
</blockquote>
<p>这样这个项目需要的gradle就配置完成了，下一步就是我们需要的AVD了。AVD好弄，只要在编译器的上面运行键的左边第一个边框中选择Open AVD Manager，之后随便选择一个型号安装就ok</p>
<p><img src="https://i.loli.net/2020/08/04/OzlD3HUKf4xrqhw.png" alt="AC2.png"></p>
<p>之后点击运行，就可以看到预览效果了,我们的AS开发初体验也到此告一段落</p>
<p><img src="https://i.loli.net/2020/08/04/BuEcxDT86oSX2Am.png" alt="AC3.png"></p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学：哈希算法MD5</title>
    <url>/2020/07/31/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9A%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95MD5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="现代密码学：哈希算法MD5"><a href="#现代密码学：哈希算法MD5" class="headerlink" title="现代密码学：哈希算法MD5"></a>现代密码学：哈希算法MD5</h1><h2 id="Part-1：什么是Hash"><a href="#Part-1：什么是Hash" class="headerlink" title="Part 1：什么是Hash"></a>Part 1：什么是Hash</h2><p>如果和搞信息安全的人聊算法，最容易听见的一个词就是<strong>Hash</strong>，那么<strong>Hash</strong>到底是什么呢？实际上<strong>Hash函数</strong>是对一类函数的总称，这一类函数可以将输入的任意长度的数字串转化为一个较短的定长数字串输出，这个输出值被称为<strong>Hash值</strong>。</p>
<p>既然Hash在信息安全中是一个很常见的词，很容易就会想到Hash函数一定具备一些安全性的要求和特点。Hash的特点如下：</p>
<ul>
<li><strong>快速性</strong>：对于一个输入值X，Hash函数可以容易地计算Hash值Y   //可以快速计算</li>
<li><strong>单向性</strong>：对于一个输出值Y，反向推出输入值X是计算上不可能的  //只能从X到Y</li>
<li><strong>无碰撞性</strong>：无碰撞性有强弱两种，一个好的Hash函数需要满足强无碰撞性。强无碰撞性是指：找到两个任意的不同的数字串x<sub>1</sub>和x<sub>2</sub>使对s应的Hash值y<sub>1</sub>和y<sub>2</sub>满足y<sub>1</sub> = y<sub>2</sub>是不可能的。顺带一提，弱无碰撞性是指对于给定的属于A的x<sub>1</sub>找属于B的x<sub>2</sub>使对s应的Hash值y<sub>1</sub>和y<sub>2</sub>满足y<sub>1</sub> = y<sub>2</sub>是不可能的</li>
</ul>
<p>满足以上三个特性的Hash函数被称为<strong>安全保密的Hash函数</strong>,也是我们推荐去使用的Hash函数。这种Hash函数除了枚举破解以外不可能其他的破解方法。</p>
<p>Hash函数是一种很泛用的工具，可用于数字签名、消息的完整性检验。消息的来源认证检测等，现在常用的Hash算法有<strong>MD5</strong>、<strong>SHA－1</strong>等。下面从MD5入手来介绍Hash算法的实现机制</p>
<a id="more"></a>

<h2 id="Part-2：MD和MD5"><a href="#Part-2：MD和MD5" class="headerlink" title="Part 2：MD和MD5"></a>Part 2：MD和MD5</h2><p>MD系列单向Hash函数是由Ron Rivest设计的，MD5算法对任意长度的输入值处理后产生128位的Hash值。MD5算法的实现步骤如下：</p>
<p><img src="https://i.loli.net/2020/08/01/6zxUKLcBDW8Nwif.png" alt="MD1.png"></p>
<p><img src="https://i.loli.net/2020/08/01/pbgCXNrVaKLMklz.png" alt="MD1.1.png"></p>
<p>在MD5算法中，首先需要对信息进行填充，使其字节长度与448模512同余，<strong>需要注意的是这一步是<em>必须的</em>，即便长度刚好是448，也要加上512比特</strong>，即信息的字节长度扩展至488+512n，n为一个正整数。填充的方法如下：在信息的后面填充第一位为1，其余各位均为0，直到满足上面的条件时才停止用0对信息的填充。然后，再在这个结果后面附加一个以64位二进制表示的填充前信息长度。经过这两步的处理，现在的信息字节长度为，即长度恰好是512的整数倍，这样做的目的是为了满足后面处理中对信息长度的要求。</p>
<p>同时，MD5中有A、B、C、D，4个32位被称为链接变量的整数参数，它们的初始值分别为：</p>
<blockquote>
<p> A<sub>0</sub>＝0x01234567，B<sub>0</sub>＝0x89abcdef,    C<sub>0</sub>=0xfedcba98,    D<sub>0</sub>=0x76543210</p>
</blockquote>
<p>当设置好这4个链接变量之后，就可以进入算法的4轮循环。循环的次数是信息中的512位信息分组数目。接下来的算法里面，首先把四个初始值复制到A,B,C,D当中，以备后面进行处理。</p>
<p>之后进入真正的循环(主循环)，主循环共4轮，并且具有相似的结构。第一轮进行16次操作，每次操作对A,B,C,D中的三个进行一次非线性函数运算，并将所得结果加上第四个变量，文本的一个子分组(32位)和一个常数。之后再将所得结果向左循环移动S位，并加上A,B,C,D其中之一，最后用该结果取代A,B,C,D其中之一。四个轮函数如下：</p>
<blockquote>
<p><img src="https://i.loli.net/2020/08/01/dPNwpHQtAieWEBy.png" alt="MD2.png"></p>
<p><img src="https://i.loli.net/2020/08/01/vH6lixVduDYoWCq.png" alt="MD3.png"></p>
<p><img src="https://i.loli.net/2020/08/01/pqX65AfcNntQDOh.png" alt="MD4.png"></p>
<p><img src="https://i.loli.net/2020/08/01/miRfPl4JdSYpUk1.png" alt="MD5.png"></p>
</blockquote>
<p>每轮处理过程还需加上常数表T中四分之的个元素，分别为T[1..16], T[17..32], T[33..48], T[49..64]。常数表T共64个元素，下面是常数表的具体内容</p>
<p><img src="https://i.loli.net/2020/08/01/HykgPMCYa98rJdn.png" alt="MD6.png"></p>
<p>所有这些操作完成之后，将A，B，C，D分别加上 A<sub>0</sub>，B<sub>0</sub>,    C<sub>0</sub>,    D<sub>0</sub>。然后用下一分组数据继续进行运算，最后得到一组A，B，C，D。把这组数据级联起来，即得到128比特的Hash结果。</p>
<h2 id="Part-3：MD5的破解"><a href="#Part-3：MD5的破解" class="headerlink" title="Part 3：MD5的破解"></a>Part 3：MD5的破解</h2><p>虽然MD5是一个很常用的Hash函数，但是我国山东大学的王小云教授在Crypto2004国际密码学大会上发现了一种找到MD5散列函数碰撞的方法，这一发现意味着采用MD5算法的数字签名、完整性检验等信息安全应用系统将不在安全了，这就促使信息安全系统的设计者尽快去寻找和探索新的Hash算法。</p>
<p>好了，以上就是本次我们要讲的内容了。</p>
<p>老规矩，想要我的代码吗？去Star吧！我把它放在<em><a href="https://github.com/TequilaWch/Cipher" target="_blank" rel="noopener">https://github.com/TequilaWch/Cipher</a></em>了</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学：公钥密码RSA</title>
    <url>/2020/07/29/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9A%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81RSA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="现代密码学：公钥密码RSA"><a href="#现代密码学：公钥密码RSA" class="headerlink" title="现代密码学：公钥密码RSA"></a>现代密码学：公钥密码RSA</h1><h2 id="Part-1：何为公钥密码"><a href="#Part-1：何为公钥密码" class="headerlink" title="Part 1：何为公钥密码"></a>Part 1：何为公钥密码</h2><p>在之前我们学习过的序列密码和分组密码算法都要求通信双方通过交换密钥实现使用同一个密钥，这在密钥的管理、发布和安全性方面存在很多问题，而公钥密码算法解决了这个问题。</p>
<p>公钥密码算法是指一个加密系统的加密密钥和解密密钥是不同的，或者说不能用其中一个推导出另一个。在公钥密码算法的两个密钥中，一个是用于加密的密钥，它是可以公开的，称为公钥；另一个是用于解密的密钥，是保密的，称为私钥。公钥密码算法解决了对称密码体制中密钥管理的难题，并提供了对信息发送人的身份进行验证的手段，是现代密码学最重要的发明。</p>
<p>RSA密码体制是目前为止最成功的公钥密码算法，它是在1977年由Rivest、Shamir和Adleman提出的第一个比较完善的公钥密码算法。它的安全性是建立在“大数分解和素性检测”这个数论难题的基础上，即将两个大素数相乘在计算上容易实现，而将该乘积分解为两个大素数因子的计算量相当大。虽然它的安全性还未能得到理论证明，但经过20多年的密码分析和攻击，迄今仍然被实践证明是安全的。</p>
<a id="more"></a>

<p>虽然看着很厉害，但其实RSA算法很简单，在下面一个Part我将为你详细介绍他的具体算法，相信你看完之后和我会有同样的感受</p>
<h2 id="Part-2：RSA算法描述"><a href="#Part-2：RSA算法描述" class="headerlink" title="Part 2：RSA算法描述"></a>Part 2：RSA算法描述</h2><h3 id="一：公钥与私钥"><a href="#一：公钥与私钥" class="headerlink" title="一：公钥与私钥"></a>一：公钥与私钥</h3><p>既然是公钥密码，那么肯定是得有<strong>公钥</strong>的(<del>废话</del>)，在RSA算法中，我们首先选着俩<strong>大素数</strong>p和q，计算n = pq，φ(n)是n的欧拉函数，因为n是两个素数p和q的乘积，所以φ(n)可以表示为(p-1)(q-1)。再随机选取一个正整数e，这个正整数的唯一要求就是与φ(n)<strong>互素</strong>(当然，越大越安全)。得到这个e之后，就可以把(e,n)作为公钥来使用。</p>
<p>既然有公钥，那么在使用时肯定会有对应的<strong>私钥</strong>，RSA算法中的私钥规定为(d,n)。其中d需要满足条件e*d ≡ 1 mod φ(n)。将公钥发布用于发方的加密，私钥保留用于收方的解密</p>
<h3 id="二：加密和解密"><a href="#二：加密和解密" class="headerlink" title="二：加密和解密"></a>二：加密和解密</h3><p>说实话，这玩意儿的加密和解密比求公钥私钥还简单，就俩同余运算。过程如下</p>
<blockquote>
<p>加密过程：对于明文m，通过 c ≡ m<sup>e</sup> mod n 可以求得密文c</p>
<p>解密过程：对于密文c，通过 m ≡ c<sup>d</sup> mod n 可以求得明文m</p>
</blockquote>
<h3 id="三：安全性依赖"><a href="#三：安全性依赖" class="headerlink" title="三：安全性依赖"></a>三：安全性依赖</h3><p> 为什么说这个东西安全，因为对于不怀好意的攻击者，他能获得的有效信息只有<strong>n</strong>,<strong>e</strong>和<strong>c</strong>,想要破解出明文m必须要计算出私钥<strong>d</strong>。这意味着他需要分解n。然而在目前使用的长度为1024比特及以上的n的RSA算法中，这是计算上不可能的。虽然因式分解的技术在不断的发展，但是目前在商业应用中使用1024比特的足以满足，而在更高级的场合要求使用2048长度n，在平时的普通使用中，512比特也绰绰有余。</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>《法国民法典》的意义及其借鉴价值</title>
    <url>/2020/07/28/%E3%80%8A%E6%B3%95%E5%9B%BD%E6%B0%91%E6%B3%95%E5%85%B8%E3%80%8B%E7%9A%84%E6%84%8F%E4%B9%89%E5%8F%8A%E5%85%B6%E5%80%9F%E9%89%B4%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="《法国民法典》的意义及其借鉴价值"><a href="#《法国民法典》的意义及其借鉴价值" class="headerlink" title="《法国民法典》的意义及其借鉴价值"></a>《法国民法典》的意义及其借鉴价值</h1><h2 id="零：引言"><a href="#零：引言" class="headerlink" title="零：引言"></a>零：引言</h2><p>​    在我对外国法律的学习中，法国的法律一直如同炬火一般，吸引着我去揭开它的神秘面纱。有人说，18世纪的欧洲是法国的欧洲，这一点我再认同不过。而在启蒙运动中涌现的一批批奇才的影响下，法国的法律也以他自己的独特方式，生长成西方法律中一朵独特的奇葩，成为无论是哪种法律的研究者都无法绕开的重要存在。这其中以其《民法典》最为出众。</p>
<p>​    主持编篡《法国民法典》的拿破仑在自己的最后时刻曾这样说过：“我真正的光荣，并非是一生四十余次的胜仗，这些微不足道的战绩早就被滑铁卢的失利一笔勾销。我真正的光荣是不会被人忘记的，永垂不朽的，它就是我的《民法典》”。这位极具军事谋略才能的天才将领即便遭到了惨重的失败，他却没有丢掉自己超人的洞察力，即便在他的尸体化为尘土后，我们仍然记得他主持编篡的《法国民法典》，不仅承认他崇高的地位，更是会尊敬的将其称之为“拿破仑法典”。</p>
<p>​    “世界上有两种东西最有力量，那便是刀剑和思想。从长远来看，刀剑终是要被思想征服”一生崇尚征服的拿破仑把自己的宝压在了这部《民法典》上，而确实，从《法国民法典》衍生而来的大陆法系，也是这位将军一生最伟大的成就。因此，我想将对《法国民法典》的思考与探讨作为本文的核心，在此基础上构思本文。</p>
<p>​    而说巧也巧，在我构思这篇文章的时候，我国的民法典也正式表决通过。因此本文将从法国民法典的编纂和影响，以及与我国民法典进行比较。考察在相距200年，10000公里的两个国家，拥有如何异同的一部民法典。正如古人曾言：“他山之石，可以攻玉”。相信经此一番对比，我们必能从中获得宝贵的经验与知识。</p>
<a id="more"></a>

<h2 id="一：《法国民法典》的前世今生"><a href="#一：《法国民法典》的前世今生" class="headerlink" title="一：《法国民法典》的前世今生"></a>一：《法国民法典》的前世今生</h2><p>​    19世纪有一场轰动全球法律界的事件，那便是法国的法典编篡运动，而我们现在要谈到的《法国民法典》，便是这场运动中最亮眼的一颗明珠。《法国民法典》的出现，使以资本主义生产为基础的各种财产关系在法律上有了成文的条例，更是以迅雷不及掩耳之势，统一了法国的其余法律，对世界其他地区和国家的法律也有重大的影响力。某位德国法学家曾赞誉到：“德国需要一部《民法典》，一部如同《法国民法典》一般的，属于德国的《民法典》”，《法国民法典》的重要性和影响力，由此可见一斑。</p>
<p>​    《法国民法典》诞生于自由资本主义时期，因此其法律条文无处不体现着当时的时代精神，也即“个人有最大的自由，法律做最小的干预”。同时，在启蒙运动的天赋人权思想的影响下，其中的基本原则也确立下来，即：全体公民民事权利平等，所有权的绝对性，契约自由还有过失责任原则。《法国民法典》当中最重要也最鲜明的一个特点，就是私权至上和所有权绝对。</p>
<p>​    源于罗马法，结合了习惯法和1789年革命以来历届政府颁布的法律法令的《法国民法典》在立法上有一个非常亮眼的进步。它一改以往法典的晦涩难懂与咬文嚼字，使用了更通俗易懂的语言，力图使普通人也能毫不费力的理解。这一举措带来的影响就是让《法国民法典》在基层人民中也能快速的传播，使其影响力扩大到很远的范围，也更好的促进了资本主义社会的生产和发展。</p>
<p>​    要解释《法国民法典》在世界范围内拥有如此大的影响力，光有上面的内容还不够。《法国民法典》能成为典型的，代表资产阶级的法典，是因为它用通俗易懂的语言，以成文条令的形式，充分保障了资本主义的权利，完美契合了资本主义的发展需要。受到启蒙运动思想和理性自然法影响的《法国民法典》的第一任务，便是保障资本主义的发展，因此它首先力图构建一个基于理性的社会生活秩序。通过其对财产继承，生前赠与和身后遗嘱，债务的相关规定，契约的规定，夫妻之间的财产制度，留置与抵押的相应规章和诉讼时效等七个方面的规定，使资产阶级生活中的各个方面有了可考的条文。同时它保护了每个人的财产不受封建势力的侵犯，否定了封建特权。从这个角度来看，这部法典是资本主义国家最早的一部，破除了封建传统及其立法原则的一部民法法典，成为资本主义国家立法的榜样和标杆。</p>
<h2 id="二：《法国民法典》与孟德斯鸠的法律精神"><a href="#二：《法国民法典》与孟德斯鸠的法律精神" class="headerlink" title="二：《法国民法典》与孟德斯鸠的法律精神"></a>二：《法国民法典》与孟德斯鸠的法律精神</h2><p>​    我曾深受孟德斯鸠与其《论法的精神》的影响，因此我内心中始终存有这样一个观念：判断一部法律，当从其法律条文中所内涵的法律精神入手。因此我想在这一条目中，对《法国民法典》之中蕴涵的法律精神进行一定的剖析探讨。</p>
<p>​    孟德斯鸠认为“法的精神存在于法与各种事物可能发生的关系之中”，而对于某一个民族而言，由于“气候，宗教，法律，传统，习俗，礼仪”等因素的影响，会生成这个民族的“一般精神”，他告诫立法者在“不违背政体的限度内”要尊重这种民族精神，因为“当我们依照自然秉性行事时做得最好”。虽然相较于法兰西，英格兰受孟德斯鸠影响更多。然而在民法典的制定时，立法者却不由自主的采取了孟德斯鸠的建议，结合了法兰西民族的“一般精神”，制定了这样一部具有深远历史意义的法典。</p>
<p>​    在经历了多次革命和复辟之后，在共和与帝国之间摇摆不定并深受其害的法国人民尤其是法国的资产阶级无比渴求一个稳定的政体和一部能保护自己权利的法律。在当时的社会与当时的时期，他们民族的精神便是发展，希望用一切资源保证发展。而法兰西的立法者很好的理解了这种精神，并将其融于法律条文之中。使《法国民法典》拥有了如今的超然地位。</p>
<p>​    孟德斯鸠还秉持着一个法律观点，也就是“法的本质是关系”这一论点。《法国民法典》也很巧妙地暗合了孟德斯鸠的这一思想。《法国民法典》中蕴含的法律条文，我们可以对其进行剖析。细细考量之后，我们可以发现它的条文大多聚焦在这么几个关系之上，即继承人和被继承人的关系，赠予人与被赠予人的关系，债权人和欠债人的关系，契约签订双方的关系，夫妻间的关系，抵押人和受押人的关系，诉讼人与被诉讼人的关系。《法国民法典》中所定义的法律，实际上就是对这些关系的阐述和解释，正是孟德斯鸠的“法的本质是关系”论的有力体现。</p>
<p>​    同时，《法国民法典》还开创了一些具有划时代意义的法律原则：法律统一原则，法不溯及既往原则，法官不得拒绝裁判原则，立法司法分离原则，不得破坏公序良俗原则以及公私法相互独立原则。在这里，我想单独列出其中几条原则，加以自己的见解，进行一定的论述。首先是法不溯及既往原则。我认为这个原则是真正的，可以从封建主义中保护资产阶级的法律。在以往，法律可以追溯到过往的行为，那只要封建领主找到一些陈年往事，甚至是找出莫须有的借口，就可以肆意侵占资产阶级的利益与财产，特别是在经历了多次革命之后，大部分的人都会有一些可以追查的陈年往事，这条原则就断了所有人的后顾之忧，让资产阶级能够安心的发展与成长，为法国的资本主义化提供了有力的保障。其次就是法官不得拒绝裁判原则，这个原则在现在的人眼里看起来很莫名其妙，让人摸不着头脑，然而在当时这却是一个非常重要的原则。它通过断绝了法官拖延拒绝裁判的可能性，让人们的权利能得到及时的保障，也增强了法律的权威性，是不可忽视的一条原则。还有一条，至今为止都举足轻重的原则，就是立法司法分离原则。只要稍微了解资本主义世界的法律的人，不会不知道孟德斯鸠最著名的“三权分立”原则。虽然这其中只规定了立法权与司法权的分离，存在一定的局限性。但是瑕不掩瑜，小小的疏忽不影响它保证法律不被滥用的力量。可以说，如果没有这样的一条原则，《法国民法典》就远远达不到如今的极高地位。</p>
<p>​    《法国民法典》还有另外一条意义重大的内容：一切法国人都享有相同的民事权利。正是这一条内容，把所有法国人置于一个平等的地位上。这个条例不仅让法国人能够平等，暗合了“天赋人权”的启蒙思想，更是在世界范围内开创了先例，使平等与自由逐渐出现在其他国家的法典之中，使启蒙运动中的伟大思想随着法律条文传播开来。</p>
<p>​    《法国民法典》更是近代财产法的基础。作为最具代表性的资产阶级的法典，《法国民法典》对资产阶级最关心的财产的规定更是成为了其他资产阶级的标杆。他规定的所有权绝对和契约自由原则到现在也不曾过时，对于普通的个人，更是把个人私有财产放到了和公有国家财产相当的地位，保障每个人的神圣权利。而对于侵害他人权利的人，《法国民法典》中的个人责任原则也有相应的处罚条令，而个人责任原则也随着时间的发展，成为了大陆法系中不可缺少的一环—侵权法的基础。</p>
<p>​    从上面的条文中，我们不难看出来，《法国民法典》之所以能对当时的社会产生如此巨大的影响，是因为《法国民法典》当中所蕴含的法律精神不仅十分契合法兰西民族的“一般精神”，更是与当时社会潮流的“社会精神”和时代背景下的“时代精神”有着紧密不可分的关系。我们中国有句古话“时势造英雄”，也就是说要“顺应时势“而为的人，才能成为”英雄“。对于《法国民法典》而言，它既顺应了时代精神的”天时“，又满足了人民需求的一般精神的”人和“，还有着足够让资本主义发展的”地利“，因此《法国民法典》能成为这样一部在世界法律史上举足轻重的法律法典，是可想而知的，情理之中的事情。</p>
<h2 id="三：《法国民法典》的借鉴意义和中国的《民法典》"><a href="#三：《法国民法典》的借鉴意义和中国的《民法典》" class="headerlink" title="三：《法国民法典》的借鉴意义和中国的《民法典》"></a>三：《法国民法典》的借鉴意义和中国的《民法典》</h2><p>​    《法国民法典》固然是一本具有重大历史意义的法典，但不论怎么说，毕竟是几百年前的法律，也是为资本主义量身打造的法律，可能有人就会问了，那我们劳心费神地学习《法国民法典》到底是为了什么。必须要指出的是，不光是学习《法国民法典》，学习任何一门法律对我们都是有重要意义的，这意义就处于我上一文段中所提及的，孟德斯鸠所倡导的“法的精神”之中。没有任何一部法律能够完全适合任何两个国家，不同的国家也不可能有完全一样的社会因素，因此我们在学习法律的时候从来都不只是单纯的照搬法律条文，也不是单单学一个法而已，我们学习法律的时候，一定要从法律所属的国家的各种因素入手，这些因素包括但不限于“气候，环境，宗教，习俗，时代”等。正是这些因素的差异构成了不同国家的差异，也构成了不同法律的差异。鲁迅先生在《拿来主义》一文中曾描述过这样的拿来主义者：“他占有，挑选。看见鱼翅，并不就抛在路上以显其“平民化”，只要有养料，也和朋友们像萝卜白菜一样的吃掉，只不用它来宴大宾；看见鸦片，也不当众摔在茅厕里，以见其彻底革命，只送到药房里去，以供治病之用，却不弄“出售存膏，售完即止”的玄虚。“，我们在学习外国的法律时，便是要秉持这样的拿来主义，不论好坏，都先拿来，学习一遍，从中挑出那些好的法律精神，当作我们学习的榜样，将那些不好的法律精神，当作我们惊醒的经验，再用我们学来的那些优秀的法律精神引导我们的学习与立法。如果我们想要相对轻松的制定一部良法，他山之石是我们最好的助力。</p>
<p>​    近日出台的中国《民法典》是新中国成立以来，第一部用“法典”二字命名的法律。这个“典”字，是民事法律质量飞跃的标志，是民事法律制度成熟完备的象征。就像《法国民法典》是为了资本主义的利益需要一样，中国《民法典》的编篡也是为了维护最广大人民的根本利益。以人民为中心，不光是《民法典》的法律精神，也是我们党的精神，我们国家的精神。《民法典》的编篡，便是结合了我们中华民族的“一般精神”和中国特色社会主义新阶段的“时代精神”的一次成功的法典编纂。</p>
<p>​    而同时，中国《民法典》还具有鲜明的中国特色，对中国文化中的优点进行了传承与发扬。这说明，中国的《民法典》是包含有中国的传统思想在内的，更便于我们中国人的理解和认同，同时也便于向世界宣传与推广我们的中华文化。《民法典》的编篡是一项中华文明创造性的转化和创新性的发展的活动，我们可以通过《民法典》看到我国优秀的传统文化和法律文明成果之间的相互交融。</p>
<p>​    更者，《民法典》的编篡还有助于更好的推进法治社会的建设，依靠良法来促进善治。这样一部优秀的法典的颁布，能为国家治理体系提供有力的保障，是推行法治社会的重要支撑。其中的种种条例，都是实打实的为老百姓考虑，在避免原来各个民事单行法协调不足等弊端的同时，还建立健全了一系列新型民事权利或制度，大大提升了民法自身的内在品质。就拿前些年非常严重的“碰瓷”现象来说，如果不加以制止，只会让越来越多的热心人被恶人所害，凉了人心。而《民法典》中就有这么一个条令：因自愿实施紧急救助行为造成受助人损害的，救助人不承担民事责任。短短一行字，为无数潜在的英雄做了保证-不用怕，放心救。这只是一个很小的方面，而《民法典》中有无数个小方面，从而涵盖了生活的方方面面。</p>
<p>​    就像《法国民法典》推动了法国资本主义的发展一样，我们完全可以相信这部集民族精神之大成的《民法典》可以推动我们的中国特色社会主义更快更好的发展。当然，我们不否认这部《民法典》中可能存在的问题，然而就像我们从废墟中建立起新中国一样，只要方向对了，就不怕遇到错误和曲折。</p>
<h2 id="四：结语"><a href="#四：结语" class="headerlink" title="四：结语"></a>四：结语</h2><p>​    人治不如法治，劣法不如良法。不论是对《法国民法典》的学习，还是对中国《民法典》的探讨，都是基于我们心中的一个最初始的梦想：建立一个更美好的中国。希望我们在学习的过程中，不忘初心，即使学海无涯，但只要方向对了，就一定能到岸。</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>从《论法的精神》解读孟德斯鸠的法与精神</title>
    <url>/2020/07/28/%E4%BB%8E%E3%80%8A%E8%AE%BA%E6%B3%95%E7%9A%84%E7%B2%BE%E7%A5%9E%E3%80%8B%E8%A7%A3%E8%AF%BB%E5%AD%9F%E5%BE%B7%E6%96%AF%E9%B8%A0%E7%9A%84%E6%B3%95%E4%B8%8E%E7%B2%BE%E7%A5%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="从《论法的精神》解读孟德斯鸠的法与精神"><a href="#从《论法的精神》解读孟德斯鸠的法与精神" class="headerlink" title="从《论法的精神》解读孟德斯鸠的法与精神"></a>从《论法的精神》解读孟德斯鸠的法与精神</h1><h2 id="零：引言"><a href="#零：引言" class="headerlink" title="零：引言"></a>零：引言</h2><p>​    无论是研究西方社会，西方政治或者西方法律都绕不开孟德斯鸠的经典著作《论法的精神》。产生于启蒙运动中的《论法的精神》具有独到的见解和思想，这也使得即使过了漫长的岁月直到如今，对它的研究和评论依然层出不穷。</p>
<p>​    然而当我们读到《论法的精神》和其在不同时期的研究文献时，总会有一种熟悉而又陌生的感觉，这是因为在不同的时期的研究者，往往受到时代的思想所干扰，在其中添加了许多属于所处时代的主观思想。正如英国哲学家科林伍德所说“一切历史都是思想史”，因此从后世从当下的角度来研究孟德斯鸠的《论法的精神》总会有所偏颇。</p>
<p>​    虽然在西方早就有对孟德斯鸠的相关研究与学习，然而东方直到清代维新时期才有进步人士关注并倡导。维新变法中所倡议的三权分立制度，修立宪法，开设议会等改革便是受到孟德斯鸠的思想的影响。在20世纪之初，由梁启超编撰的《法理学大家孟德斯鸠之学说》是中国第一本系统介绍孟德斯鸠的思想的著作，同时期，孟德斯鸠的《论法的精神》也被引入中国。</p>
<p>​    在孟德斯鸠的作品被引入中国后，他的名字便与启蒙的大旗牢牢绑定，与“分权”，“理性”等观念一样深入人心。他在《论法的精神》中所讨论的，关于法律和各种环境因素之间的关系和对中国的传统政治体系的优劣至今仍然不断引发国人的争论和思考。</p>
<p>​    写作本文是由于对孟德斯鸠《论法的精神》的阅读和思考，试图从书为管，一窥孟德斯鸠所代表的一类西方法律思想，且尽量避免带入过多的主观意识，力图通过客观的语境分析，文本分析和历史分析，还原在西方法律思想史上留下浓墨重彩的孟氏思想。</p>
<a id="more"></a>

<h2 id="一：启蒙的曙光—启蒙运动之中的孟德斯鸠"><a href="#一：启蒙的曙光—启蒙运动之中的孟德斯鸠" class="headerlink" title="一：启蒙的曙光—启蒙运动之中的孟德斯鸠"></a>一：启蒙的曙光—启蒙运动之中的孟德斯鸠</h2><p>​    纵观全球历史，18世纪的法国可以说是拥有无限的风光。18世纪又被称作“启蒙时代（Siècle des Lumières）”，是个毋庸置疑的伟大的时代。时势造英雄，而孟德斯鸠就是那个时代最耀眼的英雄。启蒙时代为“理性”和“自然”的探讨提供了一片沃土，而培育出的孟德斯鸠这样的人才也使得这片厚土更加肥沃。在那个时代，思想家们抱有这样一个坚定的信念：人类能够根据自身的理性来建构社会，而这种社会以模仿自然作为基础来建构。这样的世界是一种“自然法”的世界。</p>
<p>​    虽然法兰西是启蒙世纪里的头号主角，但是主流认为启蒙运动开始的主要标志是英格兰的光荣革命（Glorious Revolution）（1688-1689）。在英格兰通过那部具有重大意义的《权利法案》之前的二十多天前，启蒙世纪的男主角孟德斯鸠出生，仿佛冥冥之中昭示着启蒙浪潮之中最耀眼的新星诞生。</p>
<p>​    孟德斯鸠和所有故事的主角一样，拥有传奇的一生。出身贵族的他从小被父母教导要“永远记住对穷苦人民所负有的义务”，这种思想伴随他伟大的一生。他不但撰写大量经典书籍为世人带去启蒙，还在工作中（孟德斯鸠曾任波尔多高等法院庭长）以民为本，多次为民请命，从未辜负他父母的期望。这种思想同样受到其他人的认可，法兰西学术院，伦敦皇家学会和普鲁士皇家科学院先后都曾吸纳他，希望他能成为其成员。</p>
<p>​    在他著成《论法的精神》之前，他的才华就已经得到了一定的显现。著名的作品有《西塞罗赞》，《波斯人信札》，《罗马盛衰原因论》等。此前阅读这些作品，不过觉得是一个有点才华的年轻人的文章，可当《论法的精神》问世以后再看，便会惊讶的发现孟德斯鸠的风格，思想和观念早在先前的文章中得到了鲜明的展现。这意味着《论法的精神》于孟德斯鸠并非是多年闭关得来的惊世之作，而是其早期思想沉淀积蕴而成的香浓陈酒。</p>
<p>​    就如同任何一位先驱者，《论法的精神》这部划时代巨作也给孟德斯鸠带来了大量的麻烦。他既要在学术上与各种各样的反对者论战，又要面对不怀好意的政府和教会的警告和威胁。各种各样的部门借由不同名义对这本书进行审查，翻译这本书的启蒙思想家瓦斯科伯爵和历史学家詹农受到了意大利当局的迫害。更有甚者，连无意中流露出自己“熟悉孟德斯鸠和他的《论法的精神》”都是极度危险的。在此书出版三年后，罗马教廷将其列为禁书，阻止其在欧洲大陆的传播。孟德斯鸠虽然曾匿名为自己的作品辩护，却如同石沉大海，没有作用。</p>
<p>​    但是金子总是会发光，纵使遭到迫害和打压，纵使被部分人批评和指责，《论法的精神》依旧传承着孟德斯鸠不朽的精神直到如今。</p>
<p>​    为了保护自己，孟德斯鸠将那些“非正统的观点”隐藏起来，以防当权者的恶意报复。他将那些与当时社会不一致的重要真理进行了处理，力图使“让会痛恨这些话的人无法理解真实含义，却又能让理解这些话的智者不会莫名其妙”。《论法的精神》是给聪明而正直的人读的，那些隐晦的思想和学说要从细节之处入手才能掌握整体的原则。在《论法的精神》的序言中，孟德斯鸠也有提及“此书是我深思熟虑规划而成的作品，读者不要仅仅翻阅寥寥数页就对这部著作妄下断言。想要探明作者的意图，必须要读完整部著作才能发现”。</p>
<p>​    然而正如伏尔泰的评论，《论法的精神》确实具有很严重的结构上的问题，“犹如迷宫”。这种问题是有多方面的原因的：长达二十余年的写作周期让文章的结构变得不那么有序，而孟德斯鸠的思想却又是非常跳脱，不拘一格的非线性思维，还为了预防可能会招来的报复而做的模糊处理。这些原因都使得这部作品的结构很复杂很混乱，这也正是孟德斯鸠的思想的特点所在：不是系统化的建构，而是理性的思维；不用法学的形而上学推演，而是在贴近生活的地方性因素中寻找法的精神。</p>
<p>​    孟德斯鸠在为自己的著作辩护时反击道：“如果我们要评论鸿篇巨著，不能光凭热情，还要有智慧，如果上天没有赐予你这样的天赋，那你就要用自我怀疑，精确表达，下苦工和反思来将其弥补”。虽然这没有阻止批评的蔓延，因为在那个“把每种公众情感都乔装打扮成哲学”的浮躁时代，在那个被戏称为“文人共和国（Republic of Letters）”的岁月中，孟德斯鸠和他的伟大作品注定无法平静。</p>
<p>​    1755年2月10日，这颗伟大的新星因病离世，在他身后，启蒙的时代依然躁动。</p>
<h2 id="二：成功的范例—兴盛的英格兰和他的宪法"><a href="#二：成功的范例—兴盛的英格兰和他的宪法" class="headerlink" title="二：成功的范例—兴盛的英格兰和他的宪法"></a>二：成功的范例—兴盛的英格兰和他的宪法</h2><h3 id="1：孟德斯鸠的政体类型学建构"><a href="#1：孟德斯鸠的政体类型学建构" class="headerlink" title="1：孟德斯鸠的政体类型学建构"></a>1：孟德斯鸠的政体类型学建构</h3><p>​    法国社会学家埃米尔·杜尔凯姆（Émile Durkheim）提出过这样一个观点：科学不能描述个体，只能描述类型。也就是说如果人类社会不能被准确科学的分类，就必然无法得到科学的描述。而社会科学的先驱孟德斯鸠凭借其在《论法的精神》中提出的独到的政体类型学，将人类社会进行了科学的分类，从而使社会学上升到了社会科学的境地。而这种独特的政体类型学正是他的“法精神”理论的具体展开。</p>
<p>​    孟德斯鸠在研究中采取了与古希腊哲学家亚里士多德的理想型的建构方式不同的经验型建构，将一些表面上“毫无关联”的各种资料进行整合处理，将与政体相关联的多重自然事实进行细致的要素提炼，并且根据这些要素归纳出了不同的，清晰易懂的政体类型。在孟德斯鸠理论中的君主政体，贵族共和政体，民主共和政体和专制政体等，在现实生活中都可以找到相印证的实体：比如共和政体之于雅典，君主政体之于英格兰，专制政体之于波斯。</p>
<p>​    孟德斯鸠甚至观察了一些文明程度较低的社会，如未开化的人（savages）和野蛮人（barbarians）的社会。未开化人的社会是分散的不联合的小民族，以狩猎为生；而野蛮人可以联合，通常以游牧为主业。虽然这些民族的文明程度较低，但其实这些社会本质上是一种低级的民主社会，并且可能是君主制社会的渊源。孟德斯鸠的研究发现，未开化人或者野蛮人一旦离开原先的环境，就有可能演化成其他的政体模式。比如原先是野蛮人的日耳曼民族征服欧洲之后，日耳曼尼亚的日耳曼人和在新土地上定居的日耳曼人就演化出了具有相当差别的政体，虽然这些政体由于地方性因素而具有不同，但是因为其有日耳曼人的本质内核也即“一般精神”，在相当一部分领域中仍然保持着类似的法律。</p>
<p>​    孟德斯鸠和孔德，马克思这样的社会学家不同，他的理论不是以“改变现有社会，创造更进步的社会”为目标，而是建立在对事实的审视之上。从孟德斯鸠的论述中可以找到社会变迁的深层的原因，那就是社会所属的“一般精神”的变迁。每个民族每种社会都有其“一般精神”，也有对这种精神作用“相对较强”的因素，因此在“一般精神”的变迁过程中也会有“线索”和“方向”可寻。所以，深入考察一个民族的“一般精神”非常重要，这也是改善现实中法制与宪制的唯一途径。我们可以通过对不同民族的法和各种环境因素的对比，探寻“法”和法的“一般精神”的内在关联。</p>
<p>​    孟德斯鸠在建构其政体类型学时，为政体类型的存在寻找了一些课比较的环境因素，并称之为政体的性质，原则与目标。在孟德斯鸠笔下，每一类政体类型都拥有独特的性质，原则和目标，并且这些独特的要素与政体所处的“法精神”有紧密的联系。某一类社会采用某一种政体的原因，是因为这个社会中的“一般精神”是培育这种政体的厚土，从中形成了相应的“法”。如同自然界中的有机存在一样，政体也会发生腐化，而预防这种腐化的方法便是保持“一般精神”的性质不发生改变。</p>
<p>​    在《论法的精神》中，孟德斯鸠主张“法精神”的多样性存在，这种多样性存在便是某种意义上的法律多元主义。他尽可能客观而公正的描述各种政体和其存在的合理性，并认为立法者需要尊重与政体相适应的“一般精神”而不能改变其民族的习俗与风尚，否则就会引发巨大的变革和暴动。</p>
<p>​    即使是孟德斯鸠，却也无法保证绝对的公正。在《论法的精神》一书中，孟德斯鸠对他所挚爱的法兰西穷尽赞美之词，并且希望法兰西的政体不发生可怕的腐化。因此他在书中着重笔墨刻画被他理想化的英格兰宪制，竭力通过这种迂回的方式来告诫他所爱的法兰西。见一以明理，我们便对孟德斯鸠理想中的英格兰宪制进行剖析。</p>
<h3 id="2：自由，法律，分权，宪制和英格兰"><a href="#2：自由，法律，分权，宪制和英格兰" class="headerlink" title="2：自由，法律，分权，宪制和英格兰"></a>2：自由，法律，分权，宪制和英格兰</h3><p>​    孟德斯鸠是公认的自由主义代表人物，其理论也被封为自由主义的法哲学代表理论。这里的自由不是无法无天的自由，而是适度的，依据事物的“自然秉性”的自由。因此他在详细论证英格兰宪制和政治自由，论证英格兰的政体和法与英格兰民族的习俗风尚的关系时，又认为英格兰的自由是其他民族无法模仿和移植的。其他国家如果想学习英格兰，只能从自己民族的“一般精神”出发，依据自己民族的“自然秉性”，以自己的道路去向政治的自由靠拢，探寻更适合自己的“适度自由”。为此我们可以这样认为：论述英格兰宪制是孟德斯鸠对于法兰西未来的走向的思考。既然英格兰的宪制是最适合英格兰“一般精神”的宪制，那么对于法兰西的“一般精神”，什么才是最适合的道路呢？孟德斯鸠的字里行间无不充斥着对这个问题的思考。</p>
<p>​    从这个目的出发，孟德斯鸠开始了他对以“政治自由”为目标的英格兰君主政体，他对英格兰宪制的推崇到了一个无与伦比的地步，即便在英格兰也被认为是“无法撼动的权威之论”。孟德斯鸠宣扬了一种“将英格兰的制度作为实现政治自由的标杆”的理念，更在宣传的过程中论证了他“法精神”理论的正确性。这种正确性体现在：英格兰的核心在于“自由”，这种“自由”被英格兰的“法律”所确认，而这种“法律”的保障来源于“分权”的政体，“分权”的思想被“宪制”所约束。</p>
<p>​    孟德斯鸠认为“如果君主政体不向政治自由靠近，就会腐化成专制政体”。这也是对于君主政体和政治自由的基本定位。英格兰的宪制以政治自由作为其根本目标，同时也为其他民族和国家提供了远离专制，建立自由政体树立了标杆。由于自由和专制是两个互不相容的存在，那么一切有害于专制的存在，那就是有利于自由，从这个角度出发，孟德斯鸠对法兰西打击封建领主的司法权和宗教权而建立绝对主义国家提出了直接的批评。</p>
<p>​    孟德斯鸠笔下的自由是在一个“有法可依”的社会之中，人们拥有做“想要做的事”和不被强迫做“不想要做的事”的权利，这种自由是居于法律之下的自由，是不会影响法律的。孟德斯鸠将权力和自由区分开来，只有权力未被滥用时，才有政治自由可言。但由于人类本身的性质，拥有权力的人都倾向于滥用权力，所以这个时候需要设定一种制度，用另外一种权力来制约一种权力，这便是分权思想的由来。</p>
<p>​    英国哲学家约翰·洛克（John Locke）曾将权力分为立法权和执法权，并且说“如果有人拥有全部立法和执法的权力，那就不存在裁判者”。而孟德斯鸠基于洛克的分权思想，将权力划分为三种，即立法权，执法权和司法权。立法权归属于君主或者执政者，是能够制定或着废除法律的权力；执行权又叫行政权，归属于国家对外行政者，是关于对其他国家的政治权力；司法权属于对内行政者，是用于裁决私人争执的权力。如果这三种权力归于同一个人或者同一个利益集团，那么公民的自由和安全将不复存在。</p>
<p>​    即便是三种权力的的其中两种集中在一个人或一个利益集团身上也会是无比可怕的灾难：譬如立法权和行政权在一个人身上时，那么就可能会出现制定荒唐无道的法律被人执行；而如果是立法权和司法权集中时，那么公民的生命和自由全由法官说了算；如果司法权和行政权集中时，那么法官就不再是公正的判决者，而是专断的压迫者。在土耳其，在意大利，三种权力归属于同一个人，因此产生了可怕的专制。即便是表面上分为三权的威尼斯，实质上也被同一个政治集团掌握，这也导致了骇人听闻的专制。</p>
<p>​    更何况，每一种权力的拥有者都倾向于和其他权力的拥有者相联合以谋求更大的利益。为防止这个令人胆寒的可能性，孟德斯鸠认为应当确保“没有一个常设机构拥有司法权，司法权的执行者应该来自民众；法院的构成虽然不固定，但却应该有同样的判决”，这便是英格兰宪制中的陪审团制度，而对于立法权和行政权，则可以赋予一些官员或者常设机构，但要接受人民的监督，不违背人民的利益。而关于权力的制约则体现在“拥有行政权的君主只能通过否决权参与立法，而不能提议创立新的法律；同时君主因受到拥有司法权的法院监督，以确保不做出违背人民利益的事；而法院所参考的法律，法条只能通过拥有立法权的机构来创立和修改”。</p>
<p>​    虽然孟德斯鸠在对英格兰宪制的深入描述中表现出了无比的推崇，但是实际上他推崇的并不是君主制或者民主制。相反，他认为任何一种政体都不比另外一种政体更优越，只有符合在“特定的时空条件”下的人民所追求的政府形式才是好的政体。因此与其说他是推崇英格兰宪制，不如说他是推崇与英格兰的“一般精神”十分契合的英格兰宪制，倘若将英格兰宪制拿给缺乏那种“一般精神”的民族，那边如同给脚带手套一般可笑了。</p>
<p>​    虽然我们知道孟德斯鸠推崇英格兰宪制是为了找寻适合法兰西的道路，然而18世纪的法国却更钟情于卢梭的共和主义，反而是在北美有了深远的影响。美国宪法将孟德斯鸠的分权原则作为新政体的基础，建立了一个现代的混合政体国家。孟德斯鸠的思想在隔洋相望的另一块大陆生根发芽，在另一块大陆更为适宜的地理性因素和那片土地上培养出来的“一般精神”的影响下，构建成了一个自由的美利坚宪制，又一次印证了孟德斯鸠关于“法”和“法精神”的理论。</p>
<h2 id="三：法律的精神—法律所应具有的“法精神”"><a href="#三：法律的精神—法律所应具有的“法精神”" class="headerlink" title="三：法律的精神—法律所应具有的“法精神”"></a>三：法律的精神—法律所应具有的“法精神”</h2><p>​    孟德斯鸠早在《论法的精神》的第一段就借用《变形记》中的一句话为自己的法律观下了一个定义“无母而生的孩子”。他的作品没有先承，也与其他当代作品不同；虽然以法律为主题，核心法律观却隐藏在层层迷雾之下；他的虽然将法律与自然法相连接，然而却自有一派的自然法观念；他讨论看似毫无关联的地理环境因素和社会因素，最后却话锋一转说这其中的关系才是“法”和“法的精神”。我们在此对其思想加以论述。</p>
<h3 id="1：What-is-law（法律或是法则）"><a href="#1：What-is-law（法律或是法则）" class="headerlink" title="1：What is law（法律或是法则）"></a>1：What is law（法律或是法则）</h3><p>​    由于语言和翻译者的原因，往往会造成对文章意思的理解出现错误。比如在书中的loi/droit/law在中文中可能是法，法律或者规律，法规。更让人头疼的是这些含义在《论法的精神》中都有存在，因此要想理解孟德斯鸠的法律观，必须先弄清楚这些含义的区分。</p>
<p>​    广义上的法不是指任何一条单一的法规，而是源于事物天生本性的必然的联系，因此只要有存在就有法，一切存在的东西都有自己的法。这里的法包括了物理学，生物学等一系列自然科学遵守的法则，也包括抽象世界中正义与邪恶的定义规则，是一种形态多元的法。在孟德斯鸠的语意中，法不是主观的精神产物，而是客观的必然规律。在他的定义下，法是由“天生的理性（primitive reason）”所衍生出来的事物相互关系。何为天生的理性？这又值得我们细细思考。</p>
<p>​    孟德斯鸠的法思想的超前性首先体现在反对宗教中上帝的“绝对权威”，他认为这种天生的理性是就连上帝也要遵从的，上帝创造世界看似随心所欲，然而却是遵从着不变的法则。这一点可以用一句话论证：如果没有法则，那么世界便不复存在，所以造物主（即上帝）不能无视法则来治理世界。</p>
<p>​    更妙的是虽然孟德斯鸠在全书中不断提及上帝，但这里的上帝和宗教意义中的上帝已经大相径庭，已经失去了“至高智慧”的内涵，更像是避免可能会找上门的宗教势力的幌子。孟德斯鸠借由普鲁塔克（Plutarchus）的名言“法是人和神共同的主宰”，将神或者人的个体意志从法律之中排除，从而为“法的精神”这一概念奠定基础，把法律的观念进一步世俗化。</p>
<p>​    同样具有超前性的是孟德斯鸠的“法的本质是关系”论，此种论点方一问世便遭到他人批判，然而批判不能改变其正确性。“每一种差异都具有同一性，每一种变化都具有一贯性”，孟德斯鸠的法同样具有二元的特殊性和普遍性。其特殊性体现在“对于不同的民族和不同的‘一般精神’”要“量身定做”，而其普遍性体现在每一种现象因为与不同的“关系”相连而存在不同的“法”，这种“法”与“关系”之间的法则是普遍的。</p>
<p>​    就像数学推理需要由公理推出定理，再由定理作出推论一样，在孟德斯鸠的实在法存在前也需要更古早的法，这种法是由前文所提及的“天生的理性”衍生，可以叫做天生的法律。</p>
<p>​    在孟德斯鸠观念中的法具有“不变之秉性”，而这种不变的秉性，正是“法精神”的体现。</p>
<h3 id="2：孟德斯鸠的自然法"><a href="#2：孟德斯鸠的自然法" class="headerlink" title="2：孟德斯鸠的自然法"></a>2：孟德斯鸠的自然法</h3><p>​    先前我们提及孟德斯鸠的法是基于自然法的，然而孟德斯鸠本身却具有和其他自然法学者不同的自然法学观，这导致了孟德斯鸠思想的特殊性。</p>
<p>​    孟德斯鸠的自然法观受到格劳秀斯（Hugo Grotius）和普芬道夫（Pufendorf）的著作影响，希望能将法律和政治世俗化。其他的典型自然法学家如洛克和卢梭等，希望联系自然和社会的桥梁从神变成人的自由意志。洛克认为人生而平等自由，因此在社会中也要保持平等自由，而卢梭认为人要摆脱自由的动物状态而成为理性的社会人，用社会的自由代替自然的自由，但是孟德斯鸠对自然状态，社会契约或者自然权利都不感兴趣，不认为不同国家的法律可以由普适性的道德作为指引，认为人们对于社会学现象可以“观察之”甚至“嘲讽之”，但不能“评判之”。</p>
<p>​    从孟德斯鸠的书中来看，他确实提及了自然法不错，然而他列举自然法的目的是表达人类社会组成之前支配人类行为的“关系”和“方式”。他的自然法更多是作为人的基本法治的描述。在孟德斯鸠眼中，自然与社会只是物质世界和智能世界组成部分的两面而已。孟德斯鸠只写了自然法，却没有和其他的自然法学家一样论述如何使用这些自然法去引导人民。我们可以说对于自然法的理论，他只写了前半部分，后半部分则是他的思想开陈出新的部分。</p>
<p>​    若要说孟德斯鸠和其他自然法学家有什么共识的话，那就是主张法并非源自神。然而就是这样小小的共识，孟德斯鸠也与其他自然法学家有所不同。孟德斯鸠认为社会性是人与生俱来的，自然状态和社会之间的微小差异并不具备政治上的意义。这种社会性使得人和人之间需要一定的规则，而这些规则便形成了法律。同时其他自然法学家的社会契约论，都假设了自然状态和社会在性质上具有明显区别，具有政治上的意义。孟德斯鸠认为人首先面对的不是作为社会意义的人，而是作为自然意义的人，当人把对方也视作与自己一样的人时才产生了社会，而社会的产生导致了战争。</p>
<p>​    这一点很值得讨论，战争不是产生社会的原因，而是社会产生的后果，为了约束这种后果，社会之间的法律也应运而生。这些产生的法律则是人为法。</p>
<p>​    因此在孟德斯鸠的观念中，自然法和人为法构成了一种包含关系。自然法是具有普适性的一般法，是抽取了社会属性之后支配人行为的法则的集合，是所有人都在遵守的法则，而人为法是具有社会属性的民族和人自己的法则，是狭义的特殊法。</p>
<p>​    孟德斯鸠的法是多元的法，不仅各个民族各个国家的法是特殊的，就连法本身也具有多样性。因为不同的法规定了不同的秩序，因此产生了许多种法律，人在不同情况下受到不同的法律的约束。</p>
<p>​    虽然孟德斯鸠强调基于人自然属性的自然法，但他也承认基于人类理性的自然法，即便是差距如天壤之别的社会之中，也会有共同的法律，这种法律就是源于“天生的理性”的天生法，是不需要人来证明其正确性的法，也是孟德斯鸠理念中的普适之法。从这个角度出发，可以说孟德斯鸠抱有这样的一种主张“自然法优于人为法，自然法的不变本性是一种客观存在，自然法的真理在不同社会中都会得到体现”。</p>
<p>​    孟德斯鸠在对自然法和人文法的论述时延续了古希腊将自然（自然法）与人（习俗）两分的传统，也即“立法者是人，是人就会犯错”。习俗本质具有相对性和易变性，自然法却是固定和不可触犯的。孟德斯鸠的二分法同样基于人为的立法可能会产生的错误，他认为立法者只是颁布法律而非产生法律，即便没有立法者，法律依然会存在。立法者是一个具有智能的存在，却也受限于他的智能，因为被“本性所限”，既不始终遵守天生的规则，也不始终遵守自己制定的法律。各个社会的法律原本应由环境因素的关系而存在其特殊的法则，作为立法者需要了解这些关系和法则，从而更好地了解最适合自身的法与政体。</p>
<h3 id="3：法的精神"><a href="#3：法的精神" class="headerlink" title="3：法的精神"></a>3：法的精神</h3><p>​    在《论法的精神》中，孟德斯鸠区分了法和法精神。他认为“法的精神存在于法与各种事物可能发生的关系之中”，而对于某一个民族而言，由于“气候，宗教，法律，传统，习俗，礼仪”等因素的影响，会生成这个民族的“一般精神”，他告诫立法者在“不违背政体的限度内”要尊重这种民族精神因为“当我们依照自然秉性行事时做得最好”。</p>
<p>​    他还讨论了各种环境因素与法律的关系，包括地理环境因素，民族的习俗与礼仪，社会环境因素，贸易，货币，人口，宗教等以及由此产生的“一般精神”。他还探讨了政体，军事与法的关系。此外，他还讨论了实现政治自由之法与宪制和公民的关系。他的写作方法成为了新型的关于政治法律理论叙事的开端，也就是社会科学的政治法律理论叙事。黑格尔对其有这样的评价“孟德斯鸠以伟大的见解考察各种法制，并认为法制，宗教以及一个国家内的一切构成了一个整体”。</p>
<p>​    在当时这些环境因素看似并没有系统逻辑，但到了如今已然在学者之中达成共识且更加深入，比如对于不同的民族，占据支配地位的环境因素也不一样，且对于越高文明程度的民族而言精神性因素有更大的影响力，比如“野蛮人几乎只受大自然和气候的影响，中国人受到礼仪的支配，日本人被所谓‘大义’控制，斯巴达的信条是他们的习俗，而罗马的基调是他们的施政准则”。</p>
<p>​    因此，孟德斯鸠所说的“一般精神”是一种经验，是一种结果，而非是先验性的前提。立法者所发现的“一般精神”并使得立法符合这种精神，立法本身就是寻找某个民族的“自然秉性”，这种法与法精神之间的关系，正是确定法之正当性的法则。出于这种正当性，孟德斯鸠的法不再依赖于形而上学，而是成为了依赖于经验性环境因素的普适法，由此开始，法学出现社会科学研究的雏形。</p>
<h2 id="四．结语"><a href="#四．结语" class="headerlink" title="四．结语"></a>四．结语</h2><p>​    孟德斯鸠和他独特的法精神观使他成为那个风起云涌时代的顶尖人物，《启蒙运动百科全书》对他有这样的一段评价“他是最博学最重要的启蒙思想家之一，他批判了当时法国社会并促进了英国君主立宪思想在欧洲的普及……他在政治理论，历史学，社会学方面留下的遗产无疑是启蒙运动为现代西方文明留下的最重要的成就之一，也是启蒙运动最广为人知的贡献之一。”</p>
<p>​    孟德斯鸠在《论法的精神》中使用的写作方法使得政治理论的写作方式从形而上学转向社会科学，不可不谓是社会科学的先驱，正如他自己的评价，是“一位对以往千百年有着透彻了解的历史学家，一位善于思考的社会学家”。</p>
<p>​    孟德斯鸠理论中的“法”兼具实在法和普遍法的双重意义，这种双重的意义在《论法的精神》中广泛地存在并连接着各个社会的生活世界，是各个社会的生活方式，也是各个社会背后的“一般精神”。按照孟德斯鸠的话来说，我们观察局部是为了对整体做出判断，我们考察原因是为了看清结果，因此我们作为社会中的主体，不仅要去掌握自然世界中的法则，同样要去创造和完善世界本身的规则。</p>
<p>​    虽然如今已然是一个全球化的时代，然而距离法律的全球化尚有很长的路要走，那是因为全球尚未形成一种统一的“一般精神”。为了应对和迎接即将到来的挑战和转型，我们应当学习孟德斯鸠的思想，并将其演化入中国环境中，成为新时期中国寻找中国法的“一般精神”的强力助手。尤其是在民族复兴的关键时期，寻找“一般精神”更具有无比重大的意义，因此我们在此时此地，在此种历史文化环境之中，依旧要沿着孟德斯鸠为我们找到的具有借鉴意义的道路前行，找寻适合我们复兴中的中华民族的“一般精神”。</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>19-20下学期形势与政策</title>
    <url>/2020/07/28/19-20%E4%B8%8B%E5%AD%A6%E6%9C%9F%E5%BD%A2%E5%8A%BF%E4%B8%8E%E6%94%BF%E7%AD%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="大难之际，方显真章"><a href="#大难之际，方显真章" class="headerlink" title="大难之际，方显真章"></a>大难之际，方显真章</h1><p>​    共产主义和社会主义自诞生以来，便长时间受到资本主义世界的针对和打压，中国的特色社会主义更是如此，直至今日，国内国外都有大量的人在鼓吹资本主义的优越性，贬低中国特色社会主义。然而就像俗话说的那样“光说不练假把式”，没有经历过灾难的考验，说谁比谁优越都是不可取的。因此面对这些言论，中国从未急于证明自己，因为他知道，证明自己的机会自然会来到。</p>
<p>​    列宁这样说过：“实践高于（理论的）认识，因为它不但有普遍性的品格，而且还有直接现实性的品格。”在疫情爆发前，可能人们会存在这样一个疑惑：中国特色社会主义和其他的社会主义，和资本主义有什么区别？中国的优越性又在哪？在我们的日常生活中，可能人们并不能直观感受到差距，甚至会觉得中国远不如资本主义国家。但是，实践是检验真理的唯一标准，这次的新冠疫情，便是一次最好的实践机会，一次绝佳的，证明自己的机会。而我们的国家也没有辜负我们的期望，在这次考验中，交出了一份完美的答卷。再和自认优良的资本主义相互一比较，就更体现出中国特色的制度优势。</p>
<a id="more"></a>

<p>​    在中国，通过政府和媒体的努力宣传，就连小孩也知道对于传染性极强的新冠疫情，防控的最基本要求就是自觉戴口罩，少出门，少接触，多消毒，多隔离。在这一层上中国特色社会主义便展示了无与伦比的优越性，而资本主义是散漫惯了的，毫不在乎的无保护出门，导致了如今严重的疫情形式。当中国决定封城时，政府下令禁止出门，在短短两天之内，14亿中国人便在大街上销声匿迹了。相关人员开始进行健康排查，每家每户积极配合配合，竭尽自己所能提供帮助。这是抑制疫情传播的最好方式！而资本主义的人却宣称这是“反人权”，竭尽所能的诋毁中国对疫情防控做出的努力。现在的结果我们也能看到，中国已然开始复苏，重新踏上发展的道路，而美国到现在还在以一个可怕的速度增加新的病人，更可怕的是，他们甚至没有弄清楚到底有多少人患病。说到对患者的排查，又不得不提一下中国政府的努力。</p>
<p>​    同样是面对如此庞大的人口基数，中国为何能够在如此短的时间内排查完毕？为什么自诩先进的美国做不到？因为我们每一个中国人都是非常相信自己的国家和政府的。正是有着这一股凝聚力，让中国在短短几十年之间发展的如此迅速。在这场战役中，我们既是旁观者，但同时也是参与者，我们有一个英明的领导者，全国上上下下有着共同的信念：我们必赢！中国特色社会主义下，人们有强大的凝聚力，能够团结一心，办成一件大事，这是其他制度不具备的，更是中国特色社会主义在实践中证明的优越性。</p>
<p>​    至于疫情爆发的中心，湖北武汉和美国，政府更是交出了截然不同的两份答卷。短短几天，武汉封城，火神山雷神山相继以令人震撼的“中国速度”建成，全国上下在防控疫情的基础上，源源不断的生产医疗物资和生活物资，一架又一架的飞机满载着医生护士，口罩防护服驰援武汉。这种方式是经过多次实践检验的，攻克难关的方法，团结的中国人在一次次的灾难面前证明了他的有效和优秀。从唐山到汶川，从非典到新冠，一方有难举国支援从来都是唯一解。然而反观资本主义的代表，美国。纵使中国珠玉在前，做了良好示范，然而所谓民主自由的美利坚，却无法做出有效的反应，导致到如今拥有世界最多的感染者。有这么个段子“湖北武汉实现新冠6个0，0新增，0确诊，0输入，0疑似，0隔离，0死亡。美国实现新冠6个0，感染人数1000000”虽然是玩笑话，但是依旧体现了中国特色社会主义不可置疑的优越性。如果说西方媒体所谓的“民主自由”是财产优先，群体免疫，老人放弃治疗的话，那我更喜爱的是他们口中“反人权“的全国上下一心，共克难关，不抛弃每一个人，只算生命账的中国。</p>
<p>​    在中国，人的生命永远摆在第一位。即便长时间的停工会给经济带来很大的危害，但是中国的国家政策是“没有确定安全，绝不复工”。这也导致了中国疫情的快速减弱。然而反观美国，政府永远以经济和选票优先，在疫情防止的关键时期，本来应该更严格的禁止出门，然而政府却为了选票和经济，提前要求复工，这也导致了疫情的持续增强。</p>
<p>​    即便在世界范围内，也可以看到中国特色社会主义和资本主义的明显差距。对于在疫情时帮助过中国的国家，无论多少，中国一概涌泉相报。海纳百川，天下为公一直是中国的气度，中国一直都有着承担责任的思想准备，也难怪很多国家愿意寻求中国的帮助，他们知道，谁才会用心帮他们，谁才是真正的君子。反观资本主义国家，无不是自私自利的丑恶。你拦截我的呼吸机，我截停你的防护服，谁也没想过帮助他人，一心想当世界老大的美国，甚至停止了向WHO的供给。真金不怕火来炼，这一场大火烧过，高下立判。</p>
<p>​    如果说经历过这次席卷全球的新冠疫情，还有人不相信中国的制度优越性，认为中国的特色社会主义道路是落后的，我们不应该与他计较，因为他已经失去了辨识真相的能力，无论什么样的证据放在他面前，他也不会改变自己心中的错误思想。和这种人计较是没有好处的，作为新时代的新青年，我们只应该更加自信，对我们的道路，国家，文化的自信。陈腐者让他陈腐，奋进者自当奋进！</p>
<p>​    为什么中国要坚持中国特色社会主义？这个问题的答案非常简单，因为在无数次的实践中，中国特色社会主义都表现出了他独特的优势，中国特色社会主义制度是经过实践检验的优秀制度。只要我们坚定不移的走在中国特色社会主义的道路上，我们的心中自然会充满勇气和信心，因为我们知道，我们的背后是国家的强力保障，我们的脚下是道路的正确方向，我们的前方是未来的光明希望！</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>19-20上学期形势与政策</title>
    <url>/2020/07/28/19-20%E4%B8%8A%E5%AD%A6%E6%9C%9F%E5%BD%A2%E5%8A%BF%E4%B8%8E%E6%94%BF%E7%AD%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="新时代浪潮中的新青年"><a href="#新时代浪潮中的新青年" class="headerlink" title="新时代浪潮中的新青年"></a>新时代浪潮中的新青年</h1><p>​    70年前，在旧中国的废墟上，饱受贫弱的中国青年心中想着同一个问题：之后的路要怎么走？</p>
<p>​    70年后，在新时代的浪潮中，富强中新生的中国青年也想着这一个问题：之后的路要怎么走？</p>
<p>​    比起之前的百废待兴，如今的新时代青年面临的问题是在面对比起当年只乱不稳的世界局势时，要如何用好前人为我们攒下的基础，让中国的实力更上一层楼。而这个问题的答案，或许可以从习近平主席在党的十九大报告中一窥究竟。</p>
<a id="more"></a>

<p>​    首先我们要知道，新时代和过去有什么异同？对内，中国特色社会主义新时代是承前启后，继往开来的时代，是获取中国特色社会主义伟大胜利的新时代，我国发展的历史方位，社会主要矛盾都发生了一定的变化，但是基本国情和党的理论主题没有变化，我们依然高举中国特色社会主义的伟大旗帜。对外，中国成为世界上不可或缺的经济体，中国的科技水平在世界上名列前茅，但是我们是最大的发展中国家这一国际地位并没有改变。改革开放以来的历史经验告诉我们：只有中国特色社会主义能发展中国，中国特色社会主义道路是实现民族复兴的必由之路。因此新时代和过去相比，不同的是我们比以往更富，我们在世界上的地位更重，不变的是我们依然要沿着中国特色社会主义道路继续探索。这便是属于我们新青年的新时代。</p>
<p>​    但是新时代中的我们和过去的那一辈人是不同的，他们的迷茫是该如何从无到有，而我们是要如何用好手上的筹码。中国特色社会主义的新时代，是决胜全面建成小康社会，全面建设社会主义现代化强国的时代，也是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代，既是全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦的时代，又是我国日益走近世界舞台中央、不断为人类作出更大贡献的时代。</p>
<p>​    综合分析国际国内形势和我国发展条件后，共产党做出了“从现在到2020年，决胜全面建成小康社会，从2020年到2035年，基本实现社会主义现代化”的战略安排。为了实现这个战略任务，我们新时代青年必须做好奋斗的准备，不断通过学习和实践充实自己，把自己打磨成一柄所向披靡的利剑，在向前奋斗的路途上披荆斩棘。在科研强国的战场上，如今的中国不缺乏骁勇善战的士兵，缺少的是用兵如神的名将，因此我们要做高精尖的科研人才，而最好的方法就是不断的学习并学以致用，不断的奋斗且夜以继日。</p>
<p>​    而实现全体人民共同富裕则是人民最根本的利益要求，也是中国共产党的最高追求。在新时代中，共享是发展的价值宗旨，因此人民的共同富裕也成了新时代的奋斗目标。而在人民生活水平日渐提升的今天，人民对富裕的定义也在发生变化，比如说更好的教育、更稳定的工作、更满意的收入、更可靠的社会保障、更高水平的医疗卫生服务、更舒适的居住条件、更优美的环境、更丰富的精神文化生活等硬性条件，也包括更好满足人们在民主、法治、公平、正义、安全、环境等方面的美好生活，更好满足人们的参与感、公平感、获得感、幸福感、安全感、尊严感等软性需要。为此我们应当如同校训说的“允公允能”，在提升自身的同时兼顾天下，做到“达则兼济天下”，用自己的所学所得回馈这个社会，让他变得更好。</p>
<p>​    中国自古以来便是一个伟大的国家，鸦片战争虽然揭开了这个国家衰弱的序章，但是如今的我们又迈上了复兴的道路。实现中华民族伟大复兴也成为了这个时代的中国梦。为了让中国梦不再仅仅是“梦”，我们新时代中国青年需要坚定不移的沿着中国特色社会主义道路前进，高举中国特色社会主义旗帜继续奋斗。虽然我们在短短几十年内走完了发达国家几百年走过的路，但我们不应当满足于现状，故步自封，而应该再接再厉，接过前人的接力棒，用更快的姿态向前冲锋。</p>
<p>​    当我们把目光从国内移开，放到世界之上，我们便又有了新的使命。不管是哪个国家的人，总是生活在这个地球之上，要想获得长久的幸福，我们需要为全人类做出更大的贡献。习近平主席指出，“中国共产党是为中国人民谋幸福的政党，也是为人类进步事业而奋斗的政党。”我们党所做的一切，都是为中国人民谋幸福、为中华民族谋复兴、为人类谋和平与发展。为了这个目标，习主席提出“一带一路”倡议，发起创办亚洲基础设施投资银行，推动设立丝路基金，为全球经济发展注入中国动力；为解决世界面临的治理赤字，习近平同志倡导构建人类命运共同体，提出共商共建共享的全球治理观，推动建设相互尊重、公平正义、合作共赢的新型国际关系，为推动国际关系民主化、改革和完善全球治理体系贡献中国方案；为解决世界面临的和平赤字，习近平同志提出对话而不对抗、结伴而不结盟的国家交往观，尊重彼此发展道路和社会制度的制度观，共同、综合、合作、可持续的新安全观，为维护世界和平贡献中国智慧。而我们要做的，就是用我们自己的行动支持这样的政策，为全世界的福祉尽自己的绵薄之力。</p>
<p>​    虽然我们如今的物质生活比过去好了不止一倍，但是我们所面临的挑战却比过去只重不轻。我们新时代的新青年站在时代的风口浪尖，要用自己的力量让中华这条巨龙能够腾飞在世界之东</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学：AES加密算法</title>
    <url>/2020/07/28/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9AAES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="现代密码学：AES加密算法"><a href="#现代密码学：AES加密算法" class="headerlink" title="现代密码学：AES加密算法"></a>现代密码学：AES加密算法</h1><h2 id="Part-1：Rijndael和他的数学基础"><a href="#Part-1：Rijndael和他的数学基础" class="headerlink" title="Part 1：Rijndael和他的数学基础"></a>Part 1：Rijndael和他的数学基础</h2><p><strong>AES</strong>本质上是一种加密标准，我们常说的AES加密其实是<strong>Rijndael加密算法</strong>。对于AES的加密标准不过多赘述，我们详细讲讲Rijndael算法。</p>
<p>Rijndael加密算法建立在一种特殊的数学结构上–有限域GF(2<sup>8</sup>)。在多项式表示中，GF(2<sup>8</sup>)上两个元素的和仍然是一个次数不超过7的多项式，其系数等于两个元素对应系数的模2加(比特异或)。</p>
<p>而如果要计算GF(2<sup>8</sup>)上的乘法，必须先确定一个GF(2)上的8次不可约多项式；GF(2<sup>8</sup>)上两个元素的乘积就是这两个多项式的模乘(以这个8次不可约多项式为模)。而在Rijndael密码中，这个8次不可约多项式确定为m(x) = x<sup>8</sup>+x<sup>4</sup>+x<sup>3</sup>+x+1，十六进制表示为“11B”</p>
<a id="more"></a>

<p>具体的数学知识在这里我们不涉及，接下来讲讲怎样在GF(2<sup>8</sup>)上建立我们的Rijndael加密算法。在GF(2<sup>8</sup>)上我们需要做模乘运算和模加运算。多项式的加法就是对应系数相加；换句话说，多项式的加法就是4字节向量的逐比特异或，这个很简单，应该都明白。多项式的乘法必须要取模n(x) = x<sup>4</sup>+1,这样使得次数小于4的多项式的乘积仍然是一个次数小于4的多项式。用下面这个例子来说明</p>
<p>设a(x) = a<sub>3</sub>x<sup>3</sup>+a<sub>2</sub>x<sup>2</sup>+a<sub>1</sub>x<sup>1</sup>+a<sub>0</sub>,b(x) = b<sub>3</sub>x<sup>3</sup>+b<sub>2</sub>x<sup>2</sup>+b<sub>1</sub>x<sup>1</sup>+b<sub>0</sub>, 则a(x) * b(x) = c(x) = c<sub>3</sub>x<sup>3</sup>+c<sub>2</sub>x<sup>2</sup>+c<sub>1</sub>x<sup>1</sup>+c<sub>0</sub></p>
<p>由于x<sup>j</sup> mod (x<sup>4</sup>+1) = x<sup>j mod4</sup>,所以我们可以通过这样的方式计算c(x)。</p>
<p><img src="https://i.loli.net/2020/07/27/p6x8kdAVf9TbjnK.png" alt="AES1.png"></p>
<p>上面的式子还可以用矩阵表示为</p>
<p><img src="https://i.loli.net/2020/07/27/h7HQ3ncYNCltF59.png" alt="AES2.png"></p>
<h2 id="Part-2：Rijndael的设计思想"><a href="#Part-2：Rijndael的设计思想" class="headerlink" title="Part 2：Rijndael的设计思想"></a>Part 2：Rijndael的设计思想</h2><p>以上就是Rijndael加密算法的数学基础，现在我们来看看他的设计思想，作为一个密码算法，Rijndael的设计力求满足以下三条标准</p>
<ul>
<li>抵抗所有已知的攻击</li>
<li>多平台兼容且快速，编码紧凑</li>
<li>设计简单</li>
</ul>
<p>当前的大多数分组密码，其轮函数是Feistel结构，即将中间状态的部分比特不加改变地简单放置到其它位置。Rijndael没有这种结构，其轮函数是由三个不同的可逆均匀变换组成的，称它们为三个“层”。所谓“均匀变换”是指状态的每个比特都是用类似的方法进行处理的。不同层的特定选择大部分是建立在“宽轨迹策略”的应用基础上的；简单地说，“宽轨迹策略”就是提供抗线性密码分析和差分密码分析能力的一种设计。为实现宽轨迹策略，轮函数三个层中的每一层都有它自己的功能：</p>
<ul>
<li><strong>线性混合</strong>层：确保多轮之上的高度扩散</li>
<li><strong>非线性</strong>层：将具有最优的“最坏情况非线性特性”的S盒并行使用</li>
<li><strong>密钥加</strong>层：单轮子密钥简单地异或到中间状态上，实现一次性掩盖</li>
</ul>
<p>在第一轮之前，用了一个初始密钥加层，其目的是在不知道密钥的情况下，对最后一个密钥加层以后的任一层（或者是当进行已知明文攻击时，对第一个密钥加层以前的任一层）可简单地剥去，因此初始密钥加层对密码的安全性无任何意义。许多密码的设计中都在轮变换之前和之后用了密钥加层，如IDEA、SAFER和Blowfish。</p>
<p>同时，为了使加密算法和解密算法在结构上更加接近，最后一轮的线性混合层与前面各轮的线性混合层不同，这类似于DES的最后一轮不做左右交换一样。可以证明这种设计不以任何方式提高或降低该密码的安全性。</p>
<p>类似于明文分组和密文分组，算法的中间结果也须分组，称算法中间结果的分组为状态，所有的操作都在状态上进行。状态可以用以字节为元素的矩阵阵列表示，该阵列有4行，列数记为N<sub>b</sub>，N<sub>b</sub>等于分组长度除以32。</p>
<p>种子密钥类似地用一个以字节为元素的矩阵阵列表示，该阵列有4行，列数记为N<sub>k</sub>，N<sub>k</sub>等于分组长度除以32。下表是N<sub>b</sub>=6的状态和N<sub>k</sub>=4的种子密钥的矩阵阵列表示。</p>
<p><img src="https://i.loli.net/2020/07/27/TlifR3OpdkFutEG.png" alt="AES3.png"></p>
<p>算法的输入和输出被看成是由8比特字节构成的一维数组，其元素下标的范围是0到4N<sub>b</sub> -1，因此输入和输出以字节为单位的分组长度分别是16、24和32，其元素下标的范围分别是0到15，0到23和0到31。输入的种子密钥也看成是由8比特字节构成的一维数组，其元素下标的范围是0到4N<sub>k</sub> -1，因此种子密钥以字节为单位的分组长度也分别是16、24和32，其元素下标的范围分别是0到15，0到23和0到31。</p>
<p>Rijndael的轮函数以下的四个不同的计算部件组成：<strong>字节代换</strong>（ByteSub），<strong>行移位</strong>（ShiftRow），<strong>列混淆（MixColumn）</strong>和<strong>密钥加</strong>（AddRoundKey）。接下来我们将对其进行分别介绍。</p>
<h3 id="字节代换ByteSub"><a href="#字节代换ByteSub" class="headerlink" title="字节代换ByteSub"></a>字节代换ByteSub</h3><p>字节代换是非线形变换，独立地对状态的每个字节进行。代换表（即S-盒）是可逆的，由以下两个变换的合成得到：</p>
<ol>
<li>将字节看作<em>GF</em>(2<sup>8</sup>)上的元素，映射到自己的乘法逆元，把<strong>00</strong>映射到自己。</li>
<li>对字节做如下的（GF(2)上的，可逆的）仿射变换：</li>
</ol>
<p><img src="https://i.loli.net/2020/07/27/fvAh8QdHXZe4r5m.png" alt="AES4.png"></p>
<p>这个变换过程难以理解的话可以看如下的示意图</p>
<p><img src="https://i.loli.net/2020/07/27/buQdWsyFtamH4M5.png" alt="AES5.png"></p>
<p>ByteSub的逆变换由代换表的逆表做字节代换，可通过如下两步实现，首先进行仿射变换的逆变换，再求每一字节在<em>GF</em>(2<sup>8</sup>)上逆元。</p>
<h3 id="行移位ShiftRow"><a href="#行移位ShiftRow" class="headerlink" title="行移位ShiftRow"></a>行移位ShiftRow</h3><p>行移位是将状态阵列的各行进行循环移位，不同状态行的位移量不同。第0行不移动，第一行循环左移C<sub>1</sub>个字节，第二行循环左移C<sub>2</sub>个字节，第三行循环左移C<sub>3</sub>个字节。位移量C<sub>1</sub>、C<sub>2</sub>、C<sub>3</sub>的取值与N<sub>b</sub>有关，由下表给出。</p>
<p><img src="https://i.loli.net/2020/07/27/TM2kslfnK4owyPI.png" alt="AES6.png"></p>
<p>同样的，我也极其贴心的准备了相应的示意图</p>
<p><img src="https://i.loli.net/2020/07/27/6uCTEdWHNGheZ5V.png" alt="AES7.png"></p>
<p>这个的逆运算不用讲了把，再左移N<sub>b</sub>-偏移量位就ok了</p>
<h3 id="列混淆MixColumn"><a href="#列混淆MixColumn" class="headerlink" title="列混淆MixColumn"></a>列混淆MixColumn</h3><p>在列混合变换中，将状态阵列的每个列视为GF(2<sup>8</sup>)上的多项式，再与一个固定的多项式c(x)进行模<em>x</em><sup>4</sup>+1乘法。当然要求c(x)是模<em>x</em><sup>4</sup>+1可逆的多项式，否则列混合变换就是不可逆的，因而会使不同的输入分组对应的输出分组可能相同。设计者给出的从c(x)为 <strong>03x<sup>3</sup>+01x<sup>2</sup>+01x<sup>1</sup>+02</strong>(系数为16进制)。同样的，列混淆可以写为矩阵乘法如下：</p>
<p><img src="https://i.loli.net/2020/07/27/EaJpm2sxPAOF1r3.png" alt="AES8.png"></p>
<p>示意图如下</p>
<p><img src="https://i.loli.net/2020/07/27/el9pbaNJjk3dimw.png" alt="AES9.png"></p>
<p>这个逆运算是将每一列用一个特定的多项式d(x)来乘，d(x)同样已经给出：<strong>0Bx<sup>3</sup>+0Dx<sup>2</sup>+09x<sup>1</sup>+0E</strong></p>
<h3 id="密钥加AddRoundKey"><a href="#密钥加AddRoundKey" class="headerlink" title="密钥加AddRoundKey"></a>密钥加AddRoundKey</h3><p>密钥加是将轮密钥简单地与状态进行逐比特异或。轮密钥由种子密钥通过密钥编排算法得到，轮密钥长度等于分组长度N<sub>b</sub></p>
<p><img src="https://i.loli.net/2020/07/27/8wTnDvbSk1IAGMX.png" alt="AES10.png"></p>
<p>这里我们注意到一个关键词：<strong>密钥编排</strong>，密钥编排是指从种子密钥得到轮密钥的过程，它由密钥扩展和轮密钥选取两部分组成。其基本原则如下：</p>
<ul>
<li>轮密钥的比特数等于分组长度乘以轮数加1</li>
<li>种子密钥被扩展成为扩展密钥</li>
<li>轮密钥从扩展密钥中取，其中第1轮轮密钥取扩展密钥的前N<sub>b</sub>个字，第2轮轮密钥取接下来N<sub>b</sub>个字，如此下去不断地取</li>
</ul>
<p>其中，扩展密钥是以4字节字为元素的一维阵列，表示为W[N<sub>b </sub>* (N<sub>r</sub>+1)],其中前N<sub>k</sub>个字取为种子密钥，以后每个字按递归方式定义。而其扩展算法在N<sub>k</sub>≤6和N<sub>k</sub>＞6是是不同的</p>
<h4 id="Nk≤6-时的扩展算法"><a href="#Nk≤6-时的扩展算法" class="headerlink" title="Nk≤6 时的扩展算法"></a>N<sub>k</sub>≤6 时的扩展算法</h4><p>其代码如下</p>
<p><img src="https://i.loli.net/2020/07/27/NUa8GVfdkYtEMsC.png" alt="AES11.png"></p>
<p>其中</p>
<p><img src="https://i.loli.net/2020/07/27/gc7bAJ3pGB1SOUu.png" alt="AES12.png"></p>
<p>其流程图如下</p>
<p><img src="https://i.loli.net/2020/07/27/6kujKd5QPTAVmXG.png" alt="AES13.png"></p>
<h4 id="Nk＞6-时的扩展算法"><a href="#Nk＞6-时的扩展算法" class="headerlink" title="Nk＞6 时的扩展算法"></a>N<sub>k</sub>＞6 时的扩展算法</h4><p>其代码如下</p>
<p><img src="https://i.loli.net/2020/07/27/SHpwartezZcNdXJ.png" alt="AES14.png"></p>
<p>其中</p>
<p><img src="https://i.loli.net/2020/07/27/TsFHGOZr7oqD3vV.png" alt="AES15.png"></p>
<p>其流程图为</p>
<p><img src="https://i.loli.net/2020/07/27/qkVHLSYnR52eQ6v.png" alt="AES16.png"></p>
<p>N<sub>k</sub>＞6与N<sub>k</sub>≤6的密钥扩展算法的区别在于：当i为N<sub>k</sub>的4的倍数时，须先将前一个字W[i-1]经过ByteSub变换。</p>
<p>以上两个算法中，Rcon[i/N<sub>k</sub>] 为轮常数，其值与N<sub>k</sub>无关，定义为（字节用16进制表示，同时理解为GF(2<sup>8</sup>)上的元素）： Rcon[i]=(RC[i], ‘00’, ‘00’, ‘00’)</p>
<p>其中RC[<em>i</em>] 是GF(2<sup>8</sup>)中值为<em>x**i</em>-1的元素，因此RC[1] =1(即‘01’),  RC[i]= <em>x</em>(即‘02’),  RC[i-1]= x<sup>i-1</sup></p>
<h4 id="轮密钥选取"><a href="#轮密钥选取" class="headerlink" title="轮密钥选取"></a>轮密钥选取</h4><p>轮密钥 i (即第 i 个轮密钥)由轮密钥缓冲字W[N<sub>b</sub>× i]到 W[N<sub>b</sub>× (i+1)-1]给出，如图所示</p>
<p><img src="https://i.loli.net/2020/07/27/gyMouTONH5X7P2E.png" alt="AES17.png"></p>
<h2 id="Part-3：加解密算法"><a href="#Part-3：加解密算法" class="headerlink" title="Part 3：加解密算法"></a>Part 3：加解密算法</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>加密算法为顺序完成以下操作：初始的密钥加，N<sub>r</sub> -1轮迭代，一个结尾轮，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RijndaelEncode(State,ExpandedKey)</span><br><span class="line">&#123;</span><br><span class="line">	AddRoundKey(State,ExpandedKey);&#x2F;&#x2F;初始密钥加</span><br><span class="line">	For(i&#x3D;1;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Round(State,ExpandedKey+Nb*i);&#x2F;&#x2F;迭代</span><br><span class="line">	&#125;</span><br><span class="line">	FinalRound(State,ExpandedKey+Nb*Nr);&#x2F;&#x2F;结尾轮</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Round函数和FinalRound函数的定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Round(State,RoundKey)</span><br><span class="line">&#123;</span><br><span class="line">	ByteSub(State);					&#x2F;&#x2F;字节代换</span><br><span class="line">	ShiftRow(State);				&#x2F;&#x2F;行移位</span><br><span class="line">	MixColumn(State);				&#x2F;&#x2F;列混淆</span><br><span class="line">	AddRoundKey(State,RoundKey);	&#x2F;&#x2F;密钥加</span><br><span class="line">&#125;</span><br><span class="line">FinalRound(State,RoundKey)</span><br><span class="line">&#123;</span><br><span class="line">	ByteSub(State);					&#x2F;&#x2F;字节代换</span><br><span class="line">	ShiftRow(State);				&#x2F;&#x2F;行移位</span><br><span class="line">	AddRoundKey(State,RoundKey);	&#x2F;&#x2F;密钥加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解密算法"><a href="#解密算法" class="headerlink" title="解密算法"></a>解密算法</h3><p>在上面对ByteSub，ShiftRow和MixColumn的介绍中我们也提及了这三个部分的逆过程。不妨称之为InvBS，InvSR，InvMC。和DES算法相同，Rijndael的解密过程和加密过程也极其相似，同样包括初始的密钥加，N<sub>r</sub> -1轮迭代和一个结尾轮，有所区别的只有两个轮函数不同，总解密过程和轮函数的定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RijndaelDecode(State,ExpandedKey)</span><br><span class="line">&#123;</span><br><span class="line">	AddRoundKey(State,ExpandedKey);&#x2F;&#x2F;初始密钥加</span><br><span class="line">	For(i&#x3D;1;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		InvRound(State,ExpandedKey+Nb*i);&#x2F;&#x2F;迭代</span><br><span class="line">	&#125;</span><br><span class="line">	InvFinalRound(State,ExpandedKey+Nb*Nr);&#x2F;&#x2F;结尾轮</span><br><span class="line">&#125;</span><br><span class="line">InvRound(State,RoundKey)</span><br><span class="line">&#123;</span><br><span class="line">	InvBS(State);					&#x2F;&#x2F;逆字节代换</span><br><span class="line">	InvSR(State);					&#x2F;&#x2F;逆行移位</span><br><span class="line">	InvMC(State);					&#x2F;&#x2F;逆列混淆</span><br><span class="line">	AddRoundKey(State,RoundKey);	&#x2F;&#x2F;密钥加</span><br><span class="line">&#125;</span><br><span class="line">InvFinalRound(State,RoundKey)</span><br><span class="line">&#123;</span><br><span class="line">	InvBS(State);					&#x2F;&#x2F;逆字节代换</span><br><span class="line">	InvSR(State);					&#x2F;&#x2F;逆行移位</span><br><span class="line">	AddRoundKey(State,RoundKey);	&#x2F;&#x2F;逆密钥加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这就是AES算法我们要介绍的所有内容了，老样子，你可以<em><a href="https://github.com/TequilaWch/Cipher" target="_blank" rel="noopener">https://github.com/TequilaWch/Cipher</a></em>找到相关的Cpp代码，喜欢的话点个Star吧(卑微)。</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学：DES加密算法</title>
    <url>/2020/07/28/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9ADES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="现代密码学：DES加密算法"><a href="#现代密码学：DES加密算法" class="headerlink" title="现代密码学：DES加密算法"></a>现代密码学：DES加密算法</h1><h2 id="Part-1：DES的基本概念"><a href="#Part-1：DES的基本概念" class="headerlink" title="Part 1：DES的基本概念"></a>Part 1：DES的基本概念</h2><p>随着时代的不断变化，之前所提到的凯撒密码和单表置换密码逐渐难以满足人们对于密文安全性的需求，于是一种新的密码体制应运而生——<em>对称密码体制</em> ，而我们本文中要介绍的<strong>DES加密算法</strong>是对称密码体制中，分组密码的一个子类。</p>
<p>在分组密码的发展历史中，出现了许多种优秀的算法，包括IDEA，AES，Safer＋＋和本文的主角<strong>DES</strong>算法。他们都拥有一个共同的特点：在其明文加密和密文解密的过程中，信息按照固定长度分组进行处理。以<strong>DES算法</strong>为例，<strong>DES算法</strong>将明文分成64位大小的众多数据块，即分组长度为64位。同时用56位密钥对64位明文信息加密，最终形成64位的密文。如果明文长度不足64位，即将其用补零的方式扩展为64位。</p>
<a id="more"></a>

<p><strong>DES算法</strong>的具体加密过程为：首先将输入的数据进行初始置换（IP），即将明文M中数据的排列顺序按一定的规则重新排列，生成新的数据序列，以打乱原来的次序。然后将变换后的数据平分成左右两部分，将左边记为L<sub>0</sub>,右边记为R<SUB>0</SUB>。之后对R<SUB>0</SUB>和子密钥K<SUB>1</SUB>输入变换函数f进行一次变换，将得到的结果f(R<SUB>0</SUB>,K<SUB>1</SUB>)与L<sub>0</sub>按位进行异或运算，将结果记为R<sub>1</sub>,把R<sub>0</sub>作为L<sub>1</sub>进行下一轮操作，共进行16轮运算以得到L<sub>16</sub>和R<sub>16</sub>，最后将L<sub>16</sub>和R<sub>16</sub>进行逆初始置换IP<sup>-1</sup>就得到了加密数据。需要注意的是每一轮中的子密钥K<SUB>n</SUB>都是由56位密钥K生成的子密钥。</p>
<p><strong>DES算法</strong>的解密过程与加密过程类似，只不过是子密钥的使用顺序与加密时刚好相反，其加密过程的流程图如下所示：</p>
<p><img src="/images/DES1.jpg" alt="流程图"></p>
<h2 id="Part-2：基本函数介绍"><a href="#Part-2：基本函数介绍" class="headerlink" title="Part 2：基本函数介绍"></a>Part 2：基本函数介绍</h2><p>上一部分中，我们可以得到这样三个关键函数<strong>初始置换IP</strong>，<strong>变换f</strong> 和<strong>逆初始置换IP<sup>－1</sup></strong>。在这一部分，我将对这三个基本函数进行详细介绍。看在我如此辛苦的进行介绍的份上，真的不来<em><a href="https://github.com/TequilaWch/Cipher" target="_blank" rel="noopener">https://github.com/TequilaWch/Cipher</a></em>点一个<strong>star</strong>么？</p>
<h3 id="初始置换IP"><a href="#初始置换IP" class="headerlink" title="初始置换IP"></a>初始置换IP</h3><p>它的作用是把输入的64位数据块的排列顺序打乱，每位数据按照下面的置换规则重新排列，即将第58位换到第一位，第50位换打第2位，…，依次类推。置换后的64位输出分为L0 、R0（左、右）两部分，每部分分别为32位。以下是置换表：</p>
<table>
<thead>
<tr>
<th align="center"><strong>58</strong></th>
<th><strong>50</strong></th>
<th><strong>42</strong></th>
<th><strong>34</strong></th>
<th><strong>26</strong></th>
<th><strong>18</strong></th>
<th><strong>10</strong></th>
<th><strong>2</strong></th>
<th><strong>60</strong></th>
<th><strong>52</strong></th>
<th><strong>44</strong></th>
<th><strong>36</strong></th>
<th><strong>28</strong></th>
<th><strong>20</strong></th>
<th><strong>12</strong></th>
<th><strong>4</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>62</strong></td>
<td><strong>54</strong></td>
<td><strong>46</strong></td>
<td><strong>38</strong></td>
<td><strong>30</strong></td>
<td><strong>22</strong></td>
<td><strong>14</strong></td>
<td><strong>6</strong></td>
<td><strong>64</strong></td>
<td><strong>56</strong></td>
<td><strong>48</strong></td>
<td><strong>40</strong></td>
<td><strong>32</strong></td>
<td><strong>24</strong></td>
<td><strong>16</strong></td>
<td><strong>8</strong></td>
</tr>
<tr>
<td align="center"><strong>57</strong></td>
<td><strong>49</strong></td>
<td><strong>41</strong></td>
<td><strong>33</strong></td>
<td><strong>25</strong></td>
<td><strong>17</strong></td>
<td><strong>9</strong></td>
<td><strong>1</strong></td>
<td><strong>59</strong></td>
<td><strong>51</strong></td>
<td><strong>43</strong></td>
<td><strong>35</strong></td>
<td><strong>27</strong></td>
<td><strong>19</strong></td>
<td><strong>11</strong></td>
<td><strong>3</strong></td>
</tr>
<tr>
<td align="center"><strong>61</strong></td>
<td><strong>53</strong></td>
<td><strong>45</strong></td>
<td><strong>37</strong></td>
<td><strong>29</strong></td>
<td><strong>21</strong></td>
<td><strong>13</strong></td>
<td><strong>5</strong></td>
<td><strong>63</strong></td>
<td><strong>55</strong></td>
<td><strong>47</strong></td>
<td><strong>39</strong></td>
<td><strong>31</strong></td>
<td><strong>23</strong></td>
<td><strong>15</strong></td>
<td><strong>7</strong></td>
</tr>
</tbody></table>
<h3 id="变换函数f"><a href="#变换函数f" class="headerlink" title="变换函数f"></a>变换函数f</h3><p>在讲变换函数f之前，我们要先讲讲子密钥K<SUB>n</SUB>的生成,他的生成过程如下流程图所示。这里的PC-1为选择置换，可以去掉奇偶校验位。PC-2也是选择置换，它是用于从C<sub>i</sub>和D<sub>i</sub>中选取48位作为密钥K<sub>i</sub>。C<sub>0</sub>和D<sub>0</sub>是把密钥中实际的56位分成左右28位，LS<sub>i</sub>是表示对C<sub>i-1</sub>和D<sub>i-1</sub>进行循环左移变换，其中LS<sub>1</sub>,LS<sub>2</sub>,LS<sub>9</sub>,LS<sub>16</sub>是循环左移1位，其余为2位。</p>
<p><img src="/images/DES2.png" alt="子密钥生成"></p>
<p>有没有发现一个问题，我们得到的每个子密钥都是48比特，然而我们输入的R<sub>i</sub>仅仅只有32位,因此我们还需要一个扩展过程将R<sub>i</sub>扩展为48为，这个扩展的基本思想是重复使用其中的16位，具体扩展置换表如下(<em>斜体</em>为重复部分)：</p>
<table>
<thead>
<tr>
<th align="center"><strong><em>32</em></strong></th>
<th align="center"><strong>1</strong></th>
<th align="center"><strong>2</strong></th>
<th align="center"><strong>3</strong></th>
<th align="center"><strong>4</strong></th>
<th align="center"><strong><em>5</em></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong><em>4</em></strong></td>
<td align="center"><strong>5</strong></td>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>7</strong></td>
<td align="center"><strong>8</strong></td>
<td align="center"><strong><em>9</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>8</em></strong></td>
<td align="center"><strong>9</strong></td>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>11</strong></td>
<td align="center"><strong>12</strong></td>
<td align="center"><strong><em>13</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>12</em></strong></td>
<td align="center"><strong>13</strong></td>
<td align="center"><strong>14</strong></td>
<td align="center"><strong>15</strong></td>
<td align="center"><strong>16</strong></td>
<td align="center"><strong><em>17</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>16</em></strong></td>
<td align="center"><strong>17</strong></td>
<td align="center"><strong>18</strong></td>
<td align="center"><strong>19</strong></td>
<td align="center"><strong>20</strong></td>
<td align="center"><strong><em>21</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>20</em></strong></td>
<td align="center"><strong>21</strong></td>
<td align="center"><strong>22</strong></td>
<td align="center"><strong>23</strong></td>
<td align="center"><strong>24</strong></td>
<td align="center"><strong><em>25</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>24</em></strong></td>
<td align="center"><strong>25</strong></td>
<td align="center"><strong>26</strong></td>
<td align="center"><strong>27</strong></td>
<td align="center"><strong>28</strong></td>
<td align="center"><strong><em>29</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>28</em></strong></td>
<td align="center"><strong>29</strong></td>
<td align="center"><strong>30</strong></td>
<td align="center"><strong>31</strong></td>
<td align="center"><strong>32</strong></td>
<td align="center"><strong><em>1</em></strong></td>
</tr>
</tbody></table>
<p>这样，我们就有了一个48位的子密钥和一个扩展后的输入（不妨叫做x），我们把这个x和子密钥进行按位异或，得到一个总的48位结果（就叫y吧），但是我们需要一个32位的输出，直接输出y显然不可行，我们需要将其6位一组分成8组，输入8个s盒之中，每个s盒的输出是4位，这样就得到了32位的输出。具体流程图如下：</p>
<p><img src="/images/DES3.png" alt="变换函数f"></p>
<p>你的下一句话是：这个s盒是什么东西呢？我们用S<sub>1</sub>来举例，相信你一下就懂了。比如前6位是110101，把他输入S<sub>1</sub>后，取出他的第一位和最后一位(先前的重复位)构成行(这里是11即3)，剩下四位构成列(1010即10)，对照S<sub>1</sub>，我们的结果就是3，也就是0011。</p>
<p><img src="/images/DES5.png" alt="S盒1，2"></p>
<p>全部s盒的定义我们也放在下面(虽然不是很清楚)</p>
<p><img src="/images/DES4.png" alt="S盒"></p>
<h3 id="逆初始置换IP－1"><a href="#逆初始置换IP－1" class="headerlink" title="逆初始置换IP－1"></a><strong>逆初始置换IP<sup>－1</sup></strong></h3><p>逆初始置换其实就是初始置换的逆，话不多说，直接上表。</p>
<table>
<thead>
<tr>
<th align="center"><strong>40</strong></th>
<th align="center"><strong>8</strong></th>
<th align="center"><strong>48</strong></th>
<th align="center"><strong>16</strong></th>
<th align="center"><strong>56</strong></th>
<th align="center"><strong>24</strong></th>
<th align="center"><strong>64</strong></th>
<th align="center"><strong>32</strong></th>
<th align="center"><strong>39</strong></th>
<th align="center"><strong>7</strong></th>
<th align="center"><strong>47</strong></th>
<th align="center"><strong>15</strong></th>
<th align="center"><strong>55</strong></th>
<th align="center"><strong>23</strong></th>
<th align="center"><strong>63</strong></th>
<th align="center"><strong>31</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>38</strong></td>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>46</strong></td>
<td align="center"><strong>14</strong></td>
<td align="center"><strong>54</strong></td>
<td align="center"><strong>22</strong></td>
<td align="center"><strong>62</strong></td>
<td align="center"><strong>30</strong></td>
<td align="center"><strong>37</strong></td>
<td align="center"><strong>5</strong></td>
<td align="center"><strong>45</strong></td>
<td align="center"><strong>13</strong></td>
<td align="center"><strong>53</strong></td>
<td align="center"><strong>21</strong></td>
<td align="center"><strong>61</strong></td>
<td align="center"><strong>29</strong></td>
</tr>
<tr>
<td align="center"><strong>36</strong></td>
<td align="center"><strong>4</strong></td>
<td align="center"><strong>44</strong></td>
<td align="center"><strong>12</strong></td>
<td align="center"><strong>52</strong></td>
<td align="center"><strong>20</strong></td>
<td align="center"><strong>60</strong></td>
<td align="center"><strong>28</strong></td>
<td align="center"><strong>35</strong></td>
<td align="center"><strong>3</strong></td>
<td align="center"><strong>43</strong></td>
<td align="center"><strong>11</strong></td>
<td align="center"><strong>51</strong></td>
<td align="center"><strong>19</strong></td>
<td align="center"><strong>59</strong></td>
<td align="center"><strong>27</strong></td>
</tr>
<tr>
<td align="center"><strong>34</strong></td>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>42</strong></td>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>50</strong></td>
<td align="center"><strong>18</strong></td>
<td align="center"><strong>58</strong></td>
<td align="center"><strong>26</strong></td>
<td align="center"><strong>33</strong></td>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>41</strong></td>
<td align="center"><strong>9</strong></td>
<td align="center"><strong>49</strong></td>
<td align="center"><strong>17</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>25</strong></td>
</tr>
</tbody></table>
<h2 id="Part-3：DES的一些其他用法"><a href="#Part-3：DES的一些其他用法" class="headerlink" title="Part 3：DES的一些其他用法"></a>Part 3：DES的一些其他用法</h2><p>自DES算法问世以来，就一直是一种重要的加密方式，为了防止一重DES加密被破解，又衍生出了许多种DES算法的特殊用法，在这里简要提一些。</p>
<h3 id="双重DES"><a href="#双重DES" class="headerlink" title="双重DES"></a>双重DES</h3><p>顾名思义，两个密钥，两次DES，流程图如下</p>
<p><img src="/images/DES6.png" alt="双重DES"></p>
<h3 id="双密钥三重DES"><a href="#双密钥三重DES" class="headerlink" title="双密钥三重DES"></a>双密钥三重DES</h3><p>因为DES的加密算法和解密算法其实过程相同，某些时候也可以把解密算法当作加密算法使用，双密钥三重DES应运而生</p>
<p><img src="/images/DES7.png" alt="双密钥三重DES"></p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学：移位密码和单表置换密码</title>
    <url>/2020/07/28/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9A%E7%A7%BB%E4%BD%8D%E5%AF%86%E7%A0%81%E5%92%8C%E5%8D%95%E8%A1%A8%E7%BD%AE%E6%8D%A2%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="现代密码学：移位密码和单表置换密码"><a href="#现代密码学：移位密码和单表置换密码" class="headerlink" title="现代密码学：移位密码和单表置换密码"></a>现代密码学：移位密码和单表置换密码</h1><h2 id="Part-1：移位密码（以凯撒密码为例）"><a href="#Part-1：移位密码（以凯撒密码为例）" class="headerlink" title="Part 1：移位密码（以凯撒密码为例）"></a>Part 1：移位密码（以凯撒密码为例）</h2><p>古时候，战事频繁，为了在军队之间传递军情而不被敌手破解，密码学应运而生。其中最著名的一种密码便是由尤利乌斯凯撒发明的<em>凯撒密码</em>。</p>
<p>这种密码是一种<em>移位密码</em>，其基本思路就是将英文字母向前或向后移动一个固定位置，只有信息的接收方和发送方知道偏移量，从而起到加密的效果。我们例子中的凯撒密码就是一种偏移量为+3的移位密码（向后偏移三位），其字母对照表如下：</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>原信息</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
<th>J</th>
<th>K</th>
<th>L</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td><strong>密文</strong></td>
<td><strong>D</strong></td>
<td><strong>E</strong></td>
<td><strong>F</strong></td>
<td><strong>G</strong></td>
<td><strong>H</strong></td>
<td><strong>I</strong></td>
<td><strong>J</strong></td>
<td><strong>K</strong></td>
<td><strong>L</strong></td>
<td><strong>M</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>P</strong></td>
</tr>
<tr>
<td><strong>原信息</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>P</strong></td>
<td><strong>Q</strong></td>
<td><strong>R</strong></td>
<td><strong>S</strong></td>
<td><strong>T</strong></td>
<td><strong>U</strong></td>
<td><strong>V</strong></td>
<td><strong>W</strong></td>
<td><strong>X</strong></td>
<td><strong>Y</strong></td>
<td><strong>Z</strong></td>
</tr>
<tr>
<td><strong>密文</strong></td>
<td><strong>Q</strong></td>
<td><strong>R</strong></td>
<td><strong>S</strong></td>
<td><strong>T</strong></td>
<td><strong>U</strong></td>
<td><strong>V</strong></td>
<td><strong>W</strong></td>
<td><strong>X</strong></td>
<td><strong>Y</strong></td>
<td><strong>Z</strong></td>
<td><strong>A</strong></td>
<td><strong>B</strong></td>
<td><strong>C</strong></td>
</tr>
</tbody></table>
<p>例如 明文 <strong>WCH IS HANDSOME</strong> 就会被加密为 <strong>ZFK LV KDQGVRPH</strong></p>
<p>如果把A-Z用0-25编码，明文M = m<sub>0</sub>m<sub>1</sub>……m<sub>n</sub>,  密文C = c<sub>0</sub>c<sub>1</sub>……c<sub>n</sub>,偏移量(密钥)key = +3 ，则上述加密可以表示为 c<sub>i</sub> ≡ m<sub>i</sub>+key mod(26)</p>
<p>在算力尚不发达的古代，这种密码具有很高的安全性，然而在现在一个小孩子依靠电脑也可以轻而易举的破解这种密码，根本原因在于其有效密钥空间太小（仅为25），一台计算机轻轻松松的就可以将其计算出来。有兴趣的读者可以尝试破解以下密文来证明我所言不虚2333</p>
<blockquote>
<p>WKDQNV IRU UHDGLQJ PB EORJ, L GR UHDOOB KRSH BRX KDYH D QLFH GDB! ORYH BRX PB GHDU IULHQG.</p>
<p>LI BRX KDYH EHHQ KHUH , BRX FDQ ILQG PB F SOXV SOXV FRGH DERXW FDHVDU FLSKHU DW WKH DGGUHVV EHORZ,SOHDVH JLYH PH D VWDU DQG IRUN:</p>
<blockquote>
<p>kwwsv://jlwkxe.frp/WhtxlodZfk/Flskhu</p>
</blockquote>
</blockquote>
<h2 id="PART-2：单表置换密码"><a href="#PART-2：单表置换密码" class="headerlink" title="PART 2：单表置换密码"></a>PART 2：单表置换密码</h2><p>单表置换密码是移位密码的一个升级，顾名思义，他不再是简单的将字母前移或者后移，而是建立一些无规律的一一对应关系，例如如下置换：</p>
<table>
<thead>
<tr>
<th>原信息</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
<th>J</th>
<th>K</th>
<th>L</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td><strong>密文</strong></td>
<td><strong>H</strong></td>
<td><strong>K</strong></td>
<td><strong>W</strong></td>
<td><strong>T</strong></td>
<td><strong>X</strong></td>
<td><strong>Y</strong></td>
<td><strong>S</strong></td>
<td><strong>G</strong></td>
<td><strong>B</strong></td>
<td><strong>P</strong></td>
<td><strong>Q</strong></td>
<td><strong>E</strong></td>
<td><strong>J</strong></td>
</tr>
<tr>
<td><strong>原信息</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>P</strong></td>
<td><strong>Q</strong></td>
<td><strong>R</strong></td>
<td><strong>S</strong></td>
<td><strong>T</strong></td>
<td><strong>U</strong></td>
<td><strong>V</strong></td>
<td><strong>W</strong></td>
<td><strong>X</strong></td>
<td><strong>Y</strong></td>
<td><strong>Z</strong></td>
</tr>
<tr>
<td><strong>密文</strong></td>
<td><strong>A</strong></td>
<td><strong>Z</strong></td>
<td><strong>M</strong></td>
<td><strong>L</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>F</strong></td>
<td><strong>C</strong></td>
<td><strong>I</strong></td>
<td><strong>D</strong></td>
<td><strong>V</strong></td>
<td><strong>U</strong></td>
<td><strong>R</strong></td>
</tr>
</tbody></table>
<p>就会把明文<strong>WCH IS HANDSOME</strong> 加密为<strong>DWG BO GHATOZJX</strong>。单表置换密码实现的关键问题是置换表的构造，虽然有很多种途径可以实现，但是考虑到记忆和使用的方便，我们可以选择一个短语或者句子，删除掉其重复的字母，依次填入置换表前面的部分，再把没有用上的字母依次填入置换表的后面部分，还是用<strong>WCH IS HANDSOME</strong>来举例（别骂我<del>我本来就帅</del>）,去掉重复字母后，得到密钥<strong>WCHISANDOME</strong>,剩余的字母为<strong>BFGJKLPQRTUVXYZ</strong>，我们就可以把A-Z的字母依次替换为：</p>
<blockquote>
<blockquote>
<blockquote>
<p><strong>WCHISANDOMEBFGJKLPQRTUVXYZ</strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>单表置换密码相比于移位密码，其强度体现在更大的有效密钥空间，其置换表的字母组合高达26！种，如果再采用穷举密钥的方式来破解实在憨憨，因此对于单表置换密码最有效的攻击方法是利用自然语言的使用频率和语义分析相结合的方法，仅以英文为例。英文具有以下显著特征：</p>
<ol>
<li><p><strong>短单词(small words)</strong>：在英文中只有很少几个非常短的单词。因此，如果在一个加密的文本中可以确定单词的范围，那么就能得出明显的结果。一个字母的单词只有a和I。如果不计单词的缩写，在从电子邮件中选取500k字节的样本中，只有两个字母的单词仅出现35次，而两个字母的所有组合为26×26＝676种。而且，还是在那个样本中，只有三个字母的单词出现196次，而三个字母的所有组合为26×26×26＝17576种。</p>
</li>
<li><p><strong>常用单词(common words)</strong>：再次分析500k字节的样本，总共有5000多个不同的单词出现。在这里，9个最常用的单词出现的总次数占总单词数的21％，20个最常用的单词出现的总次数占总单词数的30％，104个最常用的单词占50％，247个最常用的单词占60％。样本中最常用的9个单词占总词数的百分比为：</p>
<table>
<thead>
<tr>
<th>单词</th>
<th>the</th>
<th>to</th>
<th>of</th>
<th>I</th>
<th>a</th>
<th>and</th>
<th>is</th>
<th>that</th>
<th>in</th>
</tr>
</thead>
<tbody><tr>
<td>频率%</td>
<td>4.65</td>
<td>3.02</td>
<td>2.61</td>
<td>2.2</td>
<td>1.95</td>
<td>1.82</td>
<td>1.68</td>
<td>1.62</td>
<td>1.57</td>
</tr>
</tbody></table>
</li>
<li><p><strong>字母频率(character frequency):</strong>在1M字节旧的电子文本中，对字母”A”到“Z”（忽略大小写）分别进行统计。发现近似频率从高往低排列（以百分比表示）:</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>e</th>
<th>t</th>
<th>o</th>
<th>i</th>
<th>a</th>
<th>n</th>
<th>s</th>
<th>r</th>
<th>h</th>
<th>l</th>
<th>d</th>
<th>u</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>频率</td>
<td>11.67</td>
<td>9.53</td>
<td>8.22</td>
<td>7.81</td>
<td>7.73</td>
<td>6.71</td>
<td>6.55</td>
<td>5.97</td>
<td>4.52</td>
<td>4.3</td>
<td>3.24</td>
<td>3.21</td>
<td>3.06</td>
</tr>
<tr>
<td><strong>字母</strong></td>
<td><strong>m</strong></td>
<td><strong>p</strong></td>
<td><strong>y</strong></td>
<td><strong>f</strong></td>
<td><strong>g</strong></td>
<td><strong>w</strong></td>
<td><strong>b</strong></td>
<td><strong>v</strong></td>
<td><strong>k</strong></td>
<td><strong>x</strong></td>
<td><strong>j</strong></td>
<td><strong>q</strong></td>
<td><strong>z</strong></td>
</tr>
<tr>
<td>频率</td>
<td>2.8</td>
<td>2.34</td>
<td>2.22</td>
<td>2.14</td>
<td>2.00</td>
<td>1.69</td>
<td>1.58</td>
<td>1.03</td>
<td>0.79</td>
<td>0.30</td>
<td>0.23</td>
<td>0.12</td>
<td>0.09</td>
</tr>
</tbody></table>
</li>
</ol>
<p>从该表中可以看出，最常用的单字母英文是e和t，其他字母使用频率相对来说就小得多。这样，攻击一个单表置换密码，首先统计密文中最常出现的字母，并据此猜出两个最常用的字母，并根据英文统计的其他特征（如字母组合等）进行试译。</p>
]]></content>
      <tags>
        <tag>热爱学习的WCH的日志</tag>
      </tags>
  </entry>
</search>
