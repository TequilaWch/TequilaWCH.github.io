<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>刀马WCH的一方净土</title>
    <url>/2020/07/29/%E5%88%80%E9%A9%ACWCH%E7%9A%84%E4%B8%80%E6%96%B9%E5%87%80%E5%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是刀马WCH的个人blog，用来写一些乱七八糟的东西</p>
<p>平时写的论文，学习时的笔记，无聊时的思考都会往上面挂</p>
<p>希望你能喜欢这一片属于我的净土</p>
<p>QQ：493936173  GitHub：TequilaWCH  </p>
<p>随时欢迎加好友唠嗑和讨论</p>
<p>下面这个歌单送给你，Have a nice day！</p>

    <div id="aplayer-jfpYALNz" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="5148296271" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="60px" data-preload="none" data-theme="#228B22"
    ></div>

]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title>Android：布局，TextView和Button</title>
    <url>/2020/08/09/Android%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%8CTextView%E5%92%8CButton/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Android：UI组件-1"><a href="#Android：UI组件-1" class="headerlink" title="Android：UI组件(1)"></a>Android：UI组件(1)</h1><p>承接上一篇的内容，我们所写的Hello Android程序其实很大一部分是默认生成的，而我们想要写一个自己的程序的话，那么这些东西我们一定需要了解：布局，TextView(文本框)和Button(按钮)。下面，我们就依次对这些东西进行介绍。</p>
<a id="more"></a>

<h2 id="布局：线性与相对"><a href="#布局：线性与相对" class="headerlink" title="布局：线性与相对"></a>布局：线性与相对</h2><p>Android中最常见的两种布局形式分别是线性布局<strong>LinearLayout</strong>和相对布局<strong>RelativeLayout</strong>，我们分别来讲一下他们的常用属性及用法。</p>
<h3 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h3><p>线性布局LinearLayout的常用属性包括</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">	android:id		</span><br><span class="line">	android:layout_width		</span><br><span class="line">	android:layout_height		</span><br><span class="line">	android:background</span><br><span class="line">	android:layout_margin					</span><br><span class="line">	android:padding				 </span><br><span class="line">	android:orientation	&gt;</span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>需要使用线性布局时，在app/src/main/res/layout目录下的activity_main.xml中将原先的androidx.constraintlayout.widget.ConstrainLayout替换为LinearLayout。</p>
<p>我们在根布局下创建一个新的线性布局来说明上面几个属性的使用方法，在根布局中添加以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;ll_1&quot;					&#x2F;&#x2F;起一个名字，方便使用</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;		&#x2F;&#x2F;宽度 匹配父节点</span><br><span class="line">        android:layout_height&#x3D;&quot;500dp&quot;			&#x2F;&#x2F;高度 200dp</span><br><span class="line">        android:layout_margin&#x3D;&quot;20px&quot;			&#x2F;&#x2F;外边距 20px</span><br><span class="line">        android:padding&#x3D;&quot;20px&quot;					&#x2F;&#x2F;内边距 20px</span><br><span class="line">        android:background&#x3D;&quot;#7E0C6E&quot;			&#x2F;&#x2F;背景颜色 7E0C6E</span><br><span class="line">        android:orientation&#x3D;&quot;horzontal&quot;&gt;		&#x2F;&#x2F;布局方向 水平</span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>其中layout_width和layout_height具有三种选项：match_parent(匹配父节点)，wrap_content(匹配内容)和自定义长度，在上面例子中分别使用了match_parent和自定义长度两种。orientation是线性布局中必须的属性，他指明了布局的方向，有两个值：vertical(垂直布局)和horizontal(水平布局)</p>
<p>再在这个ll_1的布局下添加代码，往该布局中添加两个view，预览和代码如下，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;v_1&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;175dp&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_marginRight&#x3D;&quot;50px&quot;		&#x2F;&#x2F;右外边距 50px</span><br><span class="line">    android:layout_marginTop&#x3D;&quot;50px&quot; &gt;		&#x2F;&#x2F;上外边距 50px</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;view</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;v_2&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;175dp&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;	</span><br><span class="line">    android:layout_marginLeft&#x3D;&quot;50px&quot;		&#x2F;&#x2F;左外边距 50px</span><br><span class="line">    android:layout_marginBottom&#x3D;&quot;50px&quot;&gt;		&#x2F;&#x2F;下外边距 50px</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/08/09/8E7YSk4OGN6HeUy.png" alt="LL1.png"></p>
<p>值得一提的是LinearLayout中还有这些比较常用的属性，在下面进行列举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 布局居中 布局水平居中 布局垂直居中</span><br><span class="line">android:gravity &#x3D; &quot;center|center_horizontal|center_vertical&quot;</span><br><span class="line">&#x2F;&#x2F; 权重分配，在布局的子元素中添加这些元素，自动按照权中排版</span><br><span class="line">android:layout_weight &#x3D; &quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a><strong>RelativeLayout</strong></h3><p>同样的相对布局RelativeLayout除了线性布局中的高度宽度等，还有一些特有的属性，列举在下面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;RelativeLayout</span><br><span class="line">	android:layout_toLeftOf					&#x2F;&#x2F;在谁左边</span><br><span class="line">	android:layout_toRightOf				&#x2F;&#x2F;在谁右边</span><br><span class="line">	android:layout_alignBottom				&#x2F;&#x2F;和谁底部对齐</span><br><span class="line">	android:layout_alignParentBottom		&#x2F;&#x2F;和父空间底部对齐</span><br><span class="line">	android:layout_below 					&#x2F;&#x2F;在谁下面	&gt;</span><br><span class="line">&lt;&#x2F;RelativeLayout&gt;</span><br></pre></td></tr></table></figure>

<p>添加下面这段代码，就能很直观的看出用法了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;初始默认 红色</span><br><span class="line">&lt;TextView</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;v_1&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:background&#x3D;&quot;#FF0000&quot;&gt;</span><br><span class="line">   &lt;&#x2F;TextView&gt;</span><br><span class="line">&#x2F;&#x2F;第二个 在第一个的右边 蓝色</span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;v_2&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:background&#x3D;&quot;#0000FF&quot;</span><br><span class="line">       android:layout_toRightOf&#x3D;&quot;@+id&#x2F;v_1&quot;</span><br><span class="line">       android:layout_marginLeft&#x3D;&quot;20px&quot;&gt;</span><br><span class="line">   &lt;&#x2F;TextView&gt;</span><br><span class="line">&#x2F;&#x2F;第三个 在第一个的上层，和第二个底部对齐 黑色</span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;v_3&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;50dp&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;50dp&quot;</span><br><span class="line">       android:background&#x3D;&quot;#000000&quot;</span><br><span class="line">       android:layout_alignBottom&#x3D;&quot;@+id&#x2F;v_2&quot;&#x2F;&#x2F;底部对齐</span><br><span class="line">       android:layout_marginLeft&#x3D;&quot;20px&quot;&gt;</span><br><span class="line">   &lt;&#x2F;TextView&gt;</span><br><span class="line">&#x2F;&#x2F;第四个 在第一个下面 青色</span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;v_4&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;50dp&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;50dp&quot;</span><br><span class="line">       android:background&#x3D;&quot;#69C4DA&quot;</span><br><span class="line">       android:layout_below&#x3D;&quot;@+id&#x2F;v_1&quot;</span><br><span class="line">       android:layout_marginTop&#x3D;&quot;50px&quot;&gt;</span><br><span class="line">   &lt;&#x2F;TextView&gt;</span><br><span class="line">&#x2F;&#x2F;第五个 和父空间底部对齐 紫色</span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;v_5&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;150dp&quot;</span><br><span class="line">       android:background&#x3D;&quot;#7E0C6E&quot;</span><br><span class="line">       android:layout_alignParentBottom&#x3D;&quot;true&quot;&gt;</span><br><span class="line">   &lt;&#x2F;TextView&gt;</span><br></pre></td></tr></table></figure>

<p>他的预览结果如下(最外层的黑框是截图时没有截好，不碍事)</p>
<p><img src="https://i.loli.net/2020/08/11/FTqL8XrYWw6jMoN.png" alt="RL1.png"></p>
<h2 id="内容：文本和按钮"><a href="#内容：文本和按钮" class="headerlink" title="内容：文本和按钮"></a>内容：文本和按钮</h2><p>有了布局以后，我们需要一些容器来存放我们的内容。这时我们就需要这样两个元素：TextView和Button。因为篇幅实在长而且代码其实不多。就在下面用代码块的形式给大家列举吧。(<del>偷懒了你能怎么着反正我马上考科四我有理由我理直气壮</del>)</p>
<h3 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;文字大小</span><br><span class="line">	android:textSize &#x3D; &quot;&quot;</span><br><span class="line">&#x2F;&#x2F;文字颜色</span><br><span class="line">	android:textColor &#x3D; &quot;&quot;</span><br><span class="line">&#x2F;&#x2F;显示不全用...代替</span><br><span class="line">	android:ellipsize &#x3D; &quot;end&quot;</span><br><span class="line">&#x2F;&#x2F;文字＋图标 要先把需要的图标放在&#x2F;res&#x2F;drawable下,right可以换成其他方向</span><br><span class="line">	android:drawableRight &#x3D; &quot;@drawable&#x2F;图标&quot;</span><br><span class="line">&#x2F;&#x2F;循环 比较多</span><br><span class="line">    android:singleLine &#x3D; &quot;true&quot; 					&#x2F;&#x2F;不换行</span><br><span class="line">    android:ellipsize &#x3D; &quot;marquee&quot;					&#x2F;&#x2F;循环</span><br><span class="line">    android:marqueeRepeatLimit &#x3D; &quot;marquee_forever&quot;	&#x2F;&#x2F;循环次数</span><br><span class="line">    android:focusable &#x3D; &quot;true&quot;						&#x2F;&#x2F;可以聚焦</span><br><span class="line">    android:focusableInTouchMode &#x3D; &quot;true&quot;			&#x2F;&#x2F;聚焦时生效</span><br></pre></td></tr></table></figure>

<p>中划线和下划线比较特殊 ，需要在java中改而不是xml中，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; activity_main.xml</span><br><span class="line">    &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">    &lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;t1&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:text&#x3D;&quot;WCH is Handsome&quot;</span><br><span class="line">            android:textSize&#x3D;&quot;30sp&quot;</span><br><span class="line">            android:textColor&#x3D;&quot;#000000&quot;&gt;</span><br><span class="line">        &lt;&#x2F;TextView&gt;</span><br><span class="line">    &lt;&#x2F;LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MainActivity.java</span><br><span class="line">    public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">        private TextView t;&#x2F;&#x2F;声明控件</span><br><span class="line">        @Override</span><br><span class="line">        protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">            super.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line">            t &#x3D; (TextView) findViewById(R.id.t1);</span><br><span class="line">            t.getPaint().setFlags(Paint.STRIKE_THRU_TEXT_FLAG);&#x2F;&#x2F;中划线</span><br><span class="line">            t.getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG);&#x2F;&#x2F;下划线</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;文字大小 颜色 背景颜色 和文本中一样</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;背景形状 圆角 在&#x2F;res&#x2F;drawable下添加shape文件 以btn.xml为例</span><br><span class="line">    &#x2F;&#x2F;btn.xml</span><br><span class="line">        &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">        &lt;shape xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">            android:shape&#x3D;&quot;rectangle&quot;&gt;</span><br><span class="line">            &lt;corners</span><br><span class="line">                android:radius&#x3D;&quot;5dp&quot;&#x2F;&gt;</span><br><span class="line">    	&lt;&#x2F;shape&gt;</span><br><span class="line">    &#x2F;&#x2F;activity_main.xml</span><br><span class="line">    	android:background &#x3D; &quot;@drawable&#x2F;btn&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按压效果 在&#x2F;res&#x2F;drawable下添加selector文件 以btn2.xml为例 使用方法同上</span><br><span class="line">    &#x2F;&#x2F;btn2.xml</span><br><span class="line">        &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">        &lt;selector xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">            &lt;item android:state_pressed&#x3D;&quot;true&quot;&gt; &#x2F;&#x2F;按压时紫色</span><br><span class="line">                &lt;shape&gt;</span><br><span class="line">                    &lt;solid android:color&#x3D;&quot;#7E0C6E&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;shape&gt;</span><br><span class="line">            &lt;&#x2F;item&gt;</span><br><span class="line">            &lt;item android:state_pressed&#x3D;&quot;false&quot;&gt; &#x2F;&#x2F;不按压时黑色</span><br><span class="line">                &lt;shape&gt;</span><br><span class="line">                    &lt;solid android:color&#x3D;&quot;#000000&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;shape&gt;</span><br><span class="line">            &lt;&#x2F;item&gt;</span><br><span class="line">        &lt;&#x2F;selector&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;事件 需要在java中添加内容</span><br><span class="line">	&#x2F;&#x2F;activity_main.xml</span><br><span class="line">		android:onClick &#x3D; &quot;showToast&quot;</span><br><span class="line">	&#x2F;&#x2F;MainActivity.java</span><br><span class="line">		pubilc void showToast(View view)</span><br><span class="line">		&#123;</span><br><span class="line">			Toast.makeText(this, &quot;WCH is Handsome&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title>飙马野郎，末代侠客--Arthur·Morgan</title>
    <url>/2020/08/04/%E9%A3%99%E9%A9%AC%E9%87%8E%E9%83%8E%EF%BC%8C%E6%9C%AB%E4%BB%A3%E4%BE%A0%E5%AE%A2-Arthur%C2%B7Morgan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="飙马野郎，末代侠客–Arthur·Morgan"><a href="#飙马野郎，末代侠客–Arthur·Morgan" class="headerlink" title="飙马野郎，末代侠客–Arthur·Morgan"></a>飙马野郎，末代侠客–Arthur·Morgan</h1><blockquote>
<p>有个没有鼻子的人正在追你，不要睡得太沉，否则他就会追上你</p>
</blockquote>
<p>《荒野大镖客2：救赎》是R星在18年发布的一款关于美国西部拓荒时期的牛仔的游戏，剧情上是其在10年发布的《荒野大镖客》的前传，聚焦于主角亚瑟·摩根，讲述了他传奇而悲剧的一生。</p>
<p>游戏的游戏性和画面无须我来赘述，随便去任何一个论坛都能看到如潮般的好评，独特的设定和细节，宏大的世界地图和丰富的游戏元素带给人的是无比真实的沉浸体验，也因此让玩家被剧情所吸引，因其喜而喜，因其悲而悲。</p>
<p>我就是这么一个被他吸引的玩家，在我们的主角亚瑟·摩根迎来了他人生的结局之时，在为他感到悲痛和惋惜之余，我也想写一点东西，纪念这位西部的飙马野郎，这位复杂的善良黑帮，这位豁达的末代侠客，这位我游戏人生10余年以来印象最深的一位人物。</p>
<a id="more"></a>

<h2 id="温情黑帮"><a href="#温情黑帮" class="headerlink" title="温情黑帮"></a>温情黑帮</h2><p>亚瑟·摩根是西部最臭名昭著的范德林德帮的成员，按资历来算，是帮派内的三把手。他从小便父母双亡，被范德林德帮的老大达奇·范德林德和二把手何西阿·马修斯收养。然而亚瑟并没有成为一名毫无底线的犯罪分子。细心的玩家可以在一系列的追债任务中发现这样一个细节：在亚瑟去讨债时，他会故意将自己的声音压的很低，以此来扮演一个恶人的形象。而在平时在帮派成员和陌生人面前，他只是一个可靠而热心的傻大个。</p>
<p>我个人在沙盒游戏中不是一个爱好胡作非为的人，因此我一直努力让亚瑟的荣誉值保持在很高的水平(拉满)，在每一个支线和陌生人的任务里，我都尽力不违背我的道德水准去做，这也导致了当我控制着亚瑟骑着马在城镇与荒野中漫步时，总是能受到其他人的尊敬和善意。说老实话，比起在洛圣都(《GTAV》的舞台)挥金如土，在西部的荒野听到的一声声问候和感谢更让我心旷神怡。在修女系列任务中解救非法奴隶，在唐斯太太系列任务中完成对过往的救赎，在真爱之路系列任务帮助西部版的”罗密欧与朱丽叶“，在印第安人任务帮助部落争取他们的权益，我们的帮派打手兼熟练劫匪亚瑟似乎不知道怎么去拒绝他人，总是热心的帮助需要帮助的人。而当他们说”谢谢你，摩根先生，你是个好心人“的时候，我们的主角总是微笑地说”No,I’m sure I’m not“，挥手离开。</p>
<p>就像在印第安人线的一个任务中偶遇的修女说的那样，亚瑟对自己善良的本性所知甚少，他或许过着奔狼的生活，但是他的梦中总是有呦呦的鹿鸣，即便在最后一战之后，恶化的肺结核让他奄奄一息的倒在山顶上迎接生命的最后时刻时，也有美丽的雄鹿与他作伴。</p>
<blockquote>
<p>在游戏中如果人物的荣誉值高，在剧情任务结束和睡觉做梦时会梦见平和的日光以及鹿</p>
<p>如果你为非作歹无恶不作的话，在剧情任务结束和睡觉做梦时则会梦见电闪雷鸣以及狼</p>
</blockquote>
<h2 id="叛逆忠臣"><a href="#叛逆忠臣" class="headerlink" title="叛逆忠臣"></a>叛逆忠臣</h2><p>无论是从一开始的黑水镇银行劫案，还是到后来的圣丹尼斯银行劫案，亚瑟从来没有想过要背叛帮派。就算达奇逐渐偏离了他的原则–不杀妇孺，就算达奇对身处险境的其他成员和亚瑟自己见死不救，就算达奇选择相信告密者迈卡·贝尔而不是视其为家人的亚瑟，亚瑟也从来没有想过要反抗达奇。</p>
<p>但是，亚瑟在帮派里极好的名声让达奇对他感到恐惧，亚瑟的坚守原则也让他们的分歧越来越多，即使亚瑟每次到最后都选择服从，依然没有办法填补达奇的恐惧。</p>
<p>亚瑟也同样认识到了这一点，但他没有选择背叛。他只是尽力去保护帮派的成员，劝说自己的好友趁机脱离这样动荡的生活。他的肺结核让他成为了最需要休息和安宁的那个人，而他所做的却是用他的最大努力去帮助其他人获得安宁。</p>
<p>从被达奇收养的那一刻开始，直到范德林德帮的覆灭，亚瑟从未有过背叛的念头，比达奇在帮派上投入了更多的心血，直到他死前，还在想着让他的好兄弟约翰·马斯顿逃出升天。也正是因此，当数年过去，过上安稳日子的帮派成员相遇时，依旧会想起亚瑟的好，会想帮亚瑟报仇雪恨，不过我想这不是亚瑟所愿的，他应该只想要他们平安。</p>
<h2 id="末代侠客"><a href="#末代侠客" class="headerlink" title="末代侠客"></a>末代侠客</h2><p>纵使亚瑟身强力壮，百步穿杨，但是他这样的人是不被时代所容忍的。当时的美国正是西部拓荒时期，整个西部在不可逆的大势驱动下，脱离野蛮，走向文明。而对于亚瑟这种人而言，纵马骋天涯才是他的归属。况且，就算他平时与人为善，声誉很高，但是他毕竟是一个黑帮，是政府悬赏通缉的对象，不管是好的亡命徒还是坏的亡命徒，他们的结局大多相似。</p>
<p>随着游戏的推进，主角一行人也不断地在更变根据地，从西部的雪山到南部的乡村，再到东部的城市，他们逃亡的路线和文明前行的方向是一样的，不论他们怎么逃，往哪儿逃，最后都逃不出被淘汰的命运。英雄在时势面前也显得渺小，更何况只是一个平凡人的亚瑟·摩根。</p>
<p>侠以武犯禁，故为世所不容。只是摩根必须要为犯下的错误承受被追捕的代价，这样一想，或许病死山顶对他是最好的归属。</p>
<p>如果生在不同的时代，我相信亚瑟会过上富有名望的一生，如果没有被范德林德帮收养，我相信亚瑟会成为一个不折不扣的正派人。但是没有如果，我这种他人生的旁观者只能畅想其他种种可能，只能希望在他漫长的梦境中，有烈马好酒，鸟啼鹿鸣。</p>
]]></content>
      <tags>
        <tag>人生游乐</tag>
      </tags>
  </entry>
  <entry>
    <title>Android：概述与工具</title>
    <url>/2020/08/03/Android%EF%BC%9A%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Android：概述与工具"><a href="#Android：概述与工具" class="headerlink" title="Android：概述与工具"></a>Android：概述与工具</h1><h2 id="Part-1：Android工具准备"><a href="#Part-1：Android工具准备" class="headerlink" title="Part 1：Android工具准备"></a>Part 1：Android工具准备</h2><p>从今天开始，我所参与的创新项目就要正式开工了。我们打算开发一个Android程序，但是组里没有一个人有过开发经验，就很烦。因此开始一个新的系列–Android开发，用这一系列的blog记录我的开发过程和学习过程。话不多说，进入下一P。</p>
<p>Android是由Google开发的一种基于Linux系统的操作系统，是一种开发移动应用的表现形式。目前最常用的开发工具是 <strong>Android Studio</strong>。</p>
<a id="more"></a>

<p>为了进行Android的开发，我们首先要安装一个JDK，因为Android开发的语言是Java语言，可以参考<a href="https://blog.csdn.net/pu329289309/article/details/104883458/" target="_blank" rel="noopener">这个网址</a>进行JDK的安装，这里不作为重点介绍。</p>
<p>另外一个工具就是我们所说的Android Studio，可以在<a href="http://www.android-studio.org/" target="_blank" rel="noopener">AS中文社区</a>中找到其安装包并进行下载，下载好了之后就可以进行安装了，安装过程中没有什么好说的，一路next就可以轻松搞定。</p>
<p><strong>But</strong>，事情并没有这么简单，安装了之后我们还要对其进行配置，话不多说，先Start Android Studio，然后点击Finish完成安装。</p>
<p>初次打开AS时，会弹出这样的一个界面</p>
<p><img src="https://i.loli.net/2020/08/03/Q8fbGRL1ydEz94j.png" alt="A1.png"></p>
<p>选择第二个，然后会弹出下图。这是因为这个安装包并不包括他要使用的SDK，我们先不管他，点击Cancel进入下一步。</p>
<p><img src="https://i.loli.net/2020/08/03/AIryEHYs2D4ntml.png" alt="A2.png"></p>
<p>之后会进入一个主题选择界面，这些就用它默认的，一路点击Next进入下面这个界面</p>
<p><img src="https://i.loli.net/2020/08/03/HR59fEFYho6jdZe.png" alt="A3.png"></p>
<p>注意到这下面会给你列出来许多你需要使用的SDK，点击Finish开始下载，等待下载完毕后，就可以进入到这样一个欢迎界面了，这代表着我们的AS安装圆满完成了(撒花)</p>
<p>说来惭愧，我还没学过Java(<del>Python是世界上最好的语言</del>)，先写个简单的程序了解一下基本的语法</p>
<h2 id="Part-2：Android应用初体验"><a href="#Part-2：Android应用初体验" class="headerlink" title="Part 2：Android应用初体验"></a>Part 2：Android应用初体验</h2><blockquote>
<p>编程界认为刚接触一门新语言时，如果首先用它来偏写一个在屏幕上显示hello world的程序，将给你带来好运。</p>
</blockquote>
<p>那我们就编写一个Hello Android吧。新建一个Android项目，乱七八糟的设定全部先不管，直接新建一个空的项目。进去以后得到这样一个目录</p>
<p><img src="https://i.loli.net/2020/08/04/HGIqL5c4F3OSfVJ.png" alt="AC1.png"></p>
<p>打开app/res/layout/activity_main.xml，可以看到如下的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    tools:context&#x3D;&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;Hello World!&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>

<p>将TextView中的 android:text = “Hello World”修改为”Hello Android”,按理来说应该就可以运行了，但是却不是这样。这是因为缺少两样东西– <strong>gradle</strong> 和 <strong>AVD</strong></p>
<p>gradle在第一次打开项目的时候会下载，但是他下载的实在是太慢，可以先打开项目目录中的gradle/wrapper/gradle-wrapper.properties，看到这样一行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">distributionUrl&#x3D;https:&#x2F;&#x2F;services.gradle.org&#x2F;distributions&#x2F;gradle-X.X.X-all.zip</span><br></pre></td></tr></table></figure>

<p>他告诉了我们需要什么版本的gradle，然后我们可以打开<a href="https://services.gradle.org/distributions/" target="_blank" rel="noopener">这个网址</a>找到对应的网址下载一个zip文件之后，将其放在C:\Users\username.gradle\wrapper\dists目录下，对应的文件夹的子文件夹下。比如我这个文件用到的是gradle-6.1.1-all，然后在这个目录下会有一个随机生成的字符串命名的文件夹，删除掉里面的所有内容，把下载的文件放到这个目录下，比如我的就是</p>
<blockquote>
<p>C:\Users\49393.gradle\wrapper\dists\gradle-6.1.1-all\cfmwm155h49vnt3hynmlrsdst</p>
</blockquote>
<p>这样这个项目需要的gradle就配置完成了，下一步就是我们需要的AVD了。AVD好弄，只要在编译器的上面运行键的左边第一个边框中选择Open AVD Manager，之后随便选择一个型号安装就ok</p>
<p><img src="https://i.loli.net/2020/08/04/OzlD3HUKf4xrqhw.png" alt="AC2.png"></p>
<p>之后点击运行，就可以看到预览效果了,我们的AS开发初体验也到此告一段落</p>
<p><img src="https://i.loli.net/2020/08/04/BuEcxDT86oSX2Am.png" alt="AC3.png"></p>
]]></content>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学：哈希算法MD5</title>
    <url>/2020/07/31/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9A%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95MD5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="现代密码学：哈希算法MD5"><a href="#现代密码学：哈希算法MD5" class="headerlink" title="现代密码学：哈希算法MD5"></a>现代密码学：哈希算法MD5</h1><h2 id="Part-1：什么是Hash"><a href="#Part-1：什么是Hash" class="headerlink" title="Part 1：什么是Hash"></a>Part 1：什么是Hash</h2><p>如果和搞信息安全的人聊算法，最容易听见的一个词就是<strong>Hash</strong>，那么<strong>Hash</strong>到底是什么呢？实际上<strong>Hash函数</strong>是对一类函数的总称，这一类函数可以将输入的任意长度的数字串转化为一个较短的定长数字串输出，这个输出值被称为<strong>Hash值</strong>。</p>
<p>既然Hash在信息安全中是一个很常见的词，很容易就会想到Hash函数一定具备一些安全性的要求和特点。Hash的特点如下：</p>
<ul>
<li><strong>快速性</strong>：对于一个输入值X，Hash函数可以容易地计算Hash值Y   //可以快速计算</li>
<li><strong>单向性</strong>：对于一个输出值Y，反向推出输入值X是计算上不可能的  //只能从X到Y</li>
<li><strong>无碰撞性</strong>：无碰撞性有强弱两种，一个好的Hash函数需要满足强无碰撞性。强无碰撞性是指：找到两个任意的不同的数字串x<sub>1</sub>和x<sub>2</sub>使对s应的Hash值y<sub>1</sub>和y<sub>2</sub>满足y<sub>1</sub> = y<sub>2</sub>是不可能的。顺带一提，弱无碰撞性是指对于给定的属于A的x<sub>1</sub>找属于B的x<sub>2</sub>使对s应的Hash值y<sub>1</sub>和y<sub>2</sub>满足y<sub>1</sub> = y<sub>2</sub>是不可能的</li>
</ul>
<p>满足以上三个特性的Hash函数被称为<strong>安全保密的Hash函数</strong>,也是我们推荐去使用的Hash函数。这种Hash函数除了枚举破解以外不可能其他的破解方法。</p>
<p>Hash函数是一种很泛用的工具，可用于数字签名、消息的完整性检验。消息的来源认证检测等，现在常用的Hash算法有<strong>MD5</strong>、<strong>SHA－1</strong>等。下面从MD5入手来介绍Hash算法的实现机制</p>
<a id="more"></a>

<h2 id="Part-2：MD和MD5"><a href="#Part-2：MD和MD5" class="headerlink" title="Part 2：MD和MD5"></a>Part 2：MD和MD5</h2><p>MD系列单向Hash函数是由Ron Rivest设计的，MD5算法对任意长度的输入值处理后产生128位的Hash值。MD5算法的实现步骤如下：</p>
<p><img src="https://i.loli.net/2020/08/01/6zxUKLcBDW8Nwif.png" alt="MD1.png"></p>
<p><img src="https://i.loli.net/2020/08/01/pbgCXNrVaKLMklz.png" alt="MD1.1.png"></p>
<p>在MD5算法中，首先需要对信息进行填充，使其字节长度与448模512同余，<strong>需要注意的是这一步是<em>必须的</em>，即便长度刚好是448，也要加上512比特</strong>，即信息的字节长度扩展至488+512n，n为一个正整数。填充的方法如下：在信息的后面填充第一位为1，其余各位均为0，直到满足上面的条件时才停止用0对信息的填充。然后，再在这个结果后面附加一个以64位二进制表示的填充前信息长度。经过这两步的处理，现在的信息字节长度为，即长度恰好是512的整数倍，这样做的目的是为了满足后面处理中对信息长度的要求。</p>
<p>同时，MD5中有A、B、C、D，4个32位被称为链接变量的整数参数，它们的初始值分别为：</p>
<blockquote>
<p> A<sub>0</sub>＝0x01234567，B<sub>0</sub>＝0x89abcdef,    C<sub>0</sub>=0xfedcba98,    D<sub>0</sub>=0x76543210</p>
</blockquote>
<p>当设置好这4个链接变量之后，就可以进入算法的4轮循环。循环的次数是信息中的512位信息分组数目。接下来的算法里面，首先把四个初始值复制到A,B,C,D当中，以备后面进行处理。</p>
<p>之后进入真正的循环(主循环)，主循环共4轮，并且具有相似的结构。第一轮进行16次操作，每次操作对A,B,C,D中的三个进行一次非线性函数运算，并将所得结果加上第四个变量，文本的一个子分组(32位)和一个常数。之后再将所得结果向左循环移动S位，并加上A,B,C,D其中之一，最后用该结果取代A,B,C,D其中之一。四个轮函数如下：</p>
<blockquote>
<p><img src="https://i.loli.net/2020/08/01/dPNwpHQtAieWEBy.png" alt="MD2.png"></p>
<p><img src="https://i.loli.net/2020/08/01/vH6lixVduDYoWCq.png" alt="MD3.png"></p>
<p><img src="https://i.loli.net/2020/08/01/pqX65AfcNntQDOh.png" alt="MD4.png"></p>
<p><img src="https://i.loli.net/2020/08/01/miRfPl4JdSYpUk1.png" alt="MD5.png"></p>
</blockquote>
<p>每轮处理过程还需加上常数表T中四分之的个元素，分别为T[1..16], T[17..32], T[33..48], T[49..64]。常数表T共64个元素，下面是常数表的具体内容</p>
<p><img src="https://i.loli.net/2020/08/01/HykgPMCYa98rJdn.png" alt="MD6.png"></p>
<p>所有这些操作完成之后，将A，B，C，D分别加上 A<sub>0</sub>，B<sub>0</sub>,    C<sub>0</sub>,    D<sub>0</sub>。然后用下一分组数据继续进行运算，最后得到一组A，B，C，D。把这组数据级联起来，即得到128比特的Hash结果。</p>
<h2 id="Part-3：MD5的破解"><a href="#Part-3：MD5的破解" class="headerlink" title="Part 3：MD5的破解"></a>Part 3：MD5的破解</h2><p>虽然MD5是一个很常用的Hash函数，但是我国山东大学的王小云教授在Crypto2004国际密码学大会上发现了一种找到MD5散列函数碰撞的方法，这一发现意味着采用MD5算法的数字签名、完整性检验等信息安全应用系统将不在安全了，这就促使信息安全系统的设计者尽快去寻找和探索新的Hash算法。</p>
<p>好了，以上就是本次我们要讲的内容了。</p>
<p>老规矩，想要我的代码吗？去Star吧！我把它放在<em><a href="https://github.com/TequilaWch/Cipher" target="_blank" rel="noopener">https://github.com/TequilaWch/Cipher</a></em>了</p>
]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学：公钥密码RSA</title>
    <url>/2020/07/29/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9A%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81RSA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="现代密码学：公钥密码RSA"><a href="#现代密码学：公钥密码RSA" class="headerlink" title="现代密码学：公钥密码RSA"></a>现代密码学：公钥密码RSA</h1><h2 id="Part-1：何为公钥密码"><a href="#Part-1：何为公钥密码" class="headerlink" title="Part 1：何为公钥密码"></a>Part 1：何为公钥密码</h2><p>在之前我们学习过的序列密码和分组密码算法都要求通信双方通过交换密钥实现使用同一个密钥，这在密钥的管理、发布和安全性方面存在很多问题，而公钥密码算法解决了这个问题。</p>
<p>公钥密码算法是指一个加密系统的加密密钥和解密密钥是不同的，或者说不能用其中一个推导出另一个。在公钥密码算法的两个密钥中，一个是用于加密的密钥，它是可以公开的，称为公钥；另一个是用于解密的密钥，是保密的，称为私钥。公钥密码算法解决了对称密码体制中密钥管理的难题，并提供了对信息发送人的身份进行验证的手段，是现代密码学最重要的发明。</p>
<p>RSA密码体制是目前为止最成功的公钥密码算法，它是在1977年由Rivest、Shamir和Adleman提出的第一个比较完善的公钥密码算法。它的安全性是建立在“大数分解和素性检测”这个数论难题的基础上，即将两个大素数相乘在计算上容易实现，而将该乘积分解为两个大素数因子的计算量相当大。虽然它的安全性还未能得到理论证明，但经过20多年的密码分析和攻击，迄今仍然被实践证明是安全的。</p>
<a id="more"></a>

<p>虽然看着很厉害，但其实RSA算法很简单，在下面一个Part我将为你详细介绍他的具体算法，相信你看完之后和我会有同样的感受</p>
<h2 id="Part-2：RSA算法描述"><a href="#Part-2：RSA算法描述" class="headerlink" title="Part 2：RSA算法描述"></a>Part 2：RSA算法描述</h2><h3 id="一：公钥与私钥"><a href="#一：公钥与私钥" class="headerlink" title="一：公钥与私钥"></a>一：公钥与私钥</h3><p>既然是公钥密码，那么肯定是得有<strong>公钥</strong>的(<del>废话</del>)，在RSA算法中，我们首先选着俩<strong>大素数</strong>p和q，计算n = pq，φ(n)是n的欧拉函数，因为n是两个素数p和q的乘积，所以φ(n)可以表示为(p-1)(q-1)。再随机选取一个正整数e，这个正整数的唯一要求就是与φ(n)<strong>互素</strong>(当然，越大越安全)。得到这个e之后，就可以把(e,n)作为公钥来使用。</p>
<p>既然有公钥，那么在使用时肯定会有对应的<strong>私钥</strong>，RSA算法中的私钥规定为(d,n)。其中d需要满足条件e*d ≡ 1 mod φ(n)。将公钥发布用于发方的加密，私钥保留用于收方的解密</p>
<h3 id="二：加密和解密"><a href="#二：加密和解密" class="headerlink" title="二：加密和解密"></a>二：加密和解密</h3><p>说实话，这玩意儿的加密和解密比求公钥私钥还简单，就俩同余运算。过程如下</p>
<blockquote>
<p>加密过程：对于明文m，通过 c ≡ m<sup>e</sup> mod n 可以求得密文c</p>
<p>解密过程：对于密文c，通过 m ≡ c<sup>d</sup> mod n 可以求得明文m</p>
</blockquote>
<h3 id="三：安全性依赖"><a href="#三：安全性依赖" class="headerlink" title="三：安全性依赖"></a>三：安全性依赖</h3><p> 为什么说这个东西安全，因为对于不怀好意的攻击者，他能获得的有效信息只有<strong>n</strong>,<strong>e</strong>和<strong>c</strong>,想要破解出明文m必须要计算出私钥<strong>d</strong>。这意味着他需要分解n。然而在目前使用的长度为1024比特及以上的n的RSA算法中，这是计算上不可能的。虽然因式分解的技术在不断的发展，但是目前在商业应用中使用1024比特的足以满足，而在更高级的场合要求使用2048长度n，在平时的普通使用中，512比特也绰绰有余。</p>
]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>《法国民法典》的意义及其借鉴价值</title>
    <url>/2020/07/28/%E3%80%8A%E6%B3%95%E5%9B%BD%E6%B0%91%E6%B3%95%E5%85%B8%E3%80%8B%E7%9A%84%E6%84%8F%E4%B9%89%E5%8F%8A%E5%85%B6%E5%80%9F%E9%89%B4%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="《法国民法典》的意义及其借鉴价值"><a href="#《法国民法典》的意义及其借鉴价值" class="headerlink" title="《法国民法典》的意义及其借鉴价值"></a>《法国民法典》的意义及其借鉴价值</h1><h2 id="零：引言"><a href="#零：引言" class="headerlink" title="零：引言"></a>零：引言</h2><p>​    在我对外国法律的学习中，法国的法律一直如同炬火一般，吸引着我去揭开它的神秘面纱。有人说，18世纪的欧洲是法国的欧洲，这一点我再认同不过。而在启蒙运动中涌现的一批批奇才的影响下，法国的法律也以他自己的独特方式，生长成西方法律中一朵独特的奇葩，成为无论是哪种法律的研究者都无法绕开的重要存在。这其中以其《民法典》最为出众。</p>
<p>​    主持编篡《法国民法典》的拿破仑在自己的最后时刻曾这样说过：“我真正的光荣，并非是一生四十余次的胜仗，这些微不足道的战绩早就被滑铁卢的失利一笔勾销。我真正的光荣是不会被人忘记的，永垂不朽的，它就是我的《民法典》”。这位极具军事谋略才能的天才将领即便遭到了惨重的失败，他却没有丢掉自己超人的洞察力，即便在他的尸体化为尘土后，我们仍然记得他主持编篡的《法国民法典》，不仅承认他崇高的地位，更是会尊敬的将其称之为“拿破仑法典”。</p>
<p>​    “世界上有两种东西最有力量，那便是刀剑和思想。从长远来看，刀剑终是要被思想征服”一生崇尚征服的拿破仑把自己的宝压在了这部《民法典》上，而确实，从《法国民法典》衍生而来的大陆法系，也是这位将军一生最伟大的成就。因此，我想将对《法国民法典》的思考与探讨作为本文的核心，在此基础上构思本文。</p>
<p>​    而说巧也巧，在我构思这篇文章的时候，我国的民法典也正式表决通过。因此本文将从法国民法典的编纂和影响，以及与我国民法典进行比较。考察在相距200年，10000公里的两个国家，拥有如何异同的一部民法典。正如古人曾言：“他山之石，可以攻玉”。相信经此一番对比，我们必能从中获得宝贵的经验与知识。</p>
<a id="more"></a>

<h2 id="一：《法国民法典》的前世今生"><a href="#一：《法国民法典》的前世今生" class="headerlink" title="一：《法国民法典》的前世今生"></a>一：《法国民法典》的前世今生</h2><p>​    19世纪有一场轰动全球法律界的事件，那便是法国的法典编篡运动，而我们现在要谈到的《法国民法典》，便是这场运动中最亮眼的一颗明珠。《法国民法典》的出现，使以资本主义生产为基础的各种财产关系在法律上有了成文的条例，更是以迅雷不及掩耳之势，统一了法国的其余法律，对世界其他地区和国家的法律也有重大的影响力。某位德国法学家曾赞誉到：“德国需要一部《民法典》，一部如同《法国民法典》一般的，属于德国的《民法典》”，《法国民法典》的重要性和影响力，由此可见一斑。</p>
<p>​    《法国民法典》诞生于自由资本主义时期，因此其法律条文无处不体现着当时的时代精神，也即“个人有最大的自由，法律做最小的干预”。同时，在启蒙运动的天赋人权思想的影响下，其中的基本原则也确立下来，即：全体公民民事权利平等，所有权的绝对性，契约自由还有过失责任原则。《法国民法典》当中最重要也最鲜明的一个特点，就是私权至上和所有权绝对。</p>
<p>​    源于罗马法，结合了习惯法和1789年革命以来历届政府颁布的法律法令的《法国民法典》在立法上有一个非常亮眼的进步。它一改以往法典的晦涩难懂与咬文嚼字，使用了更通俗易懂的语言，力图使普通人也能毫不费力的理解。这一举措带来的影响就是让《法国民法典》在基层人民中也能快速的传播，使其影响力扩大到很远的范围，也更好的促进了资本主义社会的生产和发展。</p>
<p>​    要解释《法国民法典》在世界范围内拥有如此大的影响力，光有上面的内容还不够。《法国民法典》能成为典型的，代表资产阶级的法典，是因为它用通俗易懂的语言，以成文条令的形式，充分保障了资本主义的权利，完美契合了资本主义的发展需要。受到启蒙运动思想和理性自然法影响的《法国民法典》的第一任务，便是保障资本主义的发展，因此它首先力图构建一个基于理性的社会生活秩序。通过其对财产继承，生前赠与和身后遗嘱，债务的相关规定，契约的规定，夫妻之间的财产制度，留置与抵押的相应规章和诉讼时效等七个方面的规定，使资产阶级生活中的各个方面有了可考的条文。同时它保护了每个人的财产不受封建势力的侵犯，否定了封建特权。从这个角度来看，这部法典是资本主义国家最早的一部，破除了封建传统及其立法原则的一部民法法典，成为资本主义国家立法的榜样和标杆。</p>
<h2 id="二：《法国民法典》与孟德斯鸠的法律精神"><a href="#二：《法国民法典》与孟德斯鸠的法律精神" class="headerlink" title="二：《法国民法典》与孟德斯鸠的法律精神"></a>二：《法国民法典》与孟德斯鸠的法律精神</h2><p>​    我曾深受孟德斯鸠与其《论法的精神》的影响，因此我内心中始终存有这样一个观念：判断一部法律，当从其法律条文中所内涵的法律精神入手。因此我想在这一条目中，对《法国民法典》之中蕴涵的法律精神进行一定的剖析探讨。</p>
<p>​    孟德斯鸠认为“法的精神存在于法与各种事物可能发生的关系之中”，而对于某一个民族而言，由于“气候，宗教，法律，传统，习俗，礼仪”等因素的影响，会生成这个民族的“一般精神”，他告诫立法者在“不违背政体的限度内”要尊重这种民族精神，因为“当我们依照自然秉性行事时做得最好”。虽然相较于法兰西，英格兰受孟德斯鸠影响更多。然而在民法典的制定时，立法者却不由自主的采取了孟德斯鸠的建议，结合了法兰西民族的“一般精神”，制定了这样一部具有深远历史意义的法典。</p>
<p>​    在经历了多次革命和复辟之后，在共和与帝国之间摇摆不定并深受其害的法国人民尤其是法国的资产阶级无比渴求一个稳定的政体和一部能保护自己权利的法律。在当时的社会与当时的时期，他们民族的精神便是发展，希望用一切资源保证发展。而法兰西的立法者很好的理解了这种精神，并将其融于法律条文之中。使《法国民法典》拥有了如今的超然地位。</p>
<p>​    孟德斯鸠还秉持着一个法律观点，也就是“法的本质是关系”这一论点。《法国民法典》也很巧妙地暗合了孟德斯鸠的这一思想。《法国民法典》中蕴含的法律条文，我们可以对其进行剖析。细细考量之后，我们可以发现它的条文大多聚焦在这么几个关系之上，即继承人和被继承人的关系，赠予人与被赠予人的关系，债权人和欠债人的关系，契约签订双方的关系，夫妻间的关系，抵押人和受押人的关系，诉讼人与被诉讼人的关系。《法国民法典》中所定义的法律，实际上就是对这些关系的阐述和解释，正是孟德斯鸠的“法的本质是关系”论的有力体现。</p>
<p>​    同时，《法国民法典》还开创了一些具有划时代意义的法律原则：法律统一原则，法不溯及既往原则，法官不得拒绝裁判原则，立法司法分离原则，不得破坏公序良俗原则以及公私法相互独立原则。在这里，我想单独列出其中几条原则，加以自己的见解，进行一定的论述。首先是法不溯及既往原则。我认为这个原则是真正的，可以从封建主义中保护资产阶级的法律。在以往，法律可以追溯到过往的行为，那只要封建领主找到一些陈年往事，甚至是找出莫须有的借口，就可以肆意侵占资产阶级的利益与财产，特别是在经历了多次革命之后，大部分的人都会有一些可以追查的陈年往事，这条原则就断了所有人的后顾之忧，让资产阶级能够安心的发展与成长，为法国的资本主义化提供了有力的保障。其次就是法官不得拒绝裁判原则，这个原则在现在的人眼里看起来很莫名其妙，让人摸不着头脑，然而在当时这却是一个非常重要的原则。它通过断绝了法官拖延拒绝裁判的可能性，让人们的权利能得到及时的保障，也增强了法律的权威性，是不可忽视的一条原则。还有一条，至今为止都举足轻重的原则，就是立法司法分离原则。只要稍微了解资本主义世界的法律的人，不会不知道孟德斯鸠最著名的“三权分立”原则。虽然这其中只规定了立法权与司法权的分离，存在一定的局限性。但是瑕不掩瑜，小小的疏忽不影响它保证法律不被滥用的力量。可以说，如果没有这样的一条原则，《法国民法典》就远远达不到如今的极高地位。</p>
<p>​    《法国民法典》还有另外一条意义重大的内容：一切法国人都享有相同的民事权利。正是这一条内容，把所有法国人置于一个平等的地位上。这个条例不仅让法国人能够平等，暗合了“天赋人权”的启蒙思想，更是在世界范围内开创了先例，使平等与自由逐渐出现在其他国家的法典之中，使启蒙运动中的伟大思想随着法律条文传播开来。</p>
<p>​    《法国民法典》更是近代财产法的基础。作为最具代表性的资产阶级的法典，《法国民法典》对资产阶级最关心的财产的规定更是成为了其他资产阶级的标杆。他规定的所有权绝对和契约自由原则到现在也不曾过时，对于普通的个人，更是把个人私有财产放到了和公有国家财产相当的地位，保障每个人的神圣权利。而对于侵害他人权利的人，《法国民法典》中的个人责任原则也有相应的处罚条令，而个人责任原则也随着时间的发展，成为了大陆法系中不可缺少的一环—侵权法的基础。</p>
<p>​    从上面的条文中，我们不难看出来，《法国民法典》之所以能对当时的社会产生如此巨大的影响，是因为《法国民法典》当中所蕴含的法律精神不仅十分契合法兰西民族的“一般精神”，更是与当时社会潮流的“社会精神”和时代背景下的“时代精神”有着紧密不可分的关系。我们中国有句古话“时势造英雄”，也就是说要“顺应时势“而为的人，才能成为”英雄“。对于《法国民法典》而言，它既顺应了时代精神的”天时“，又满足了人民需求的一般精神的”人和“，还有着足够让资本主义发展的”地利“，因此《法国民法典》能成为这样一部在世界法律史上举足轻重的法律法典，是可想而知的，情理之中的事情。</p>
<h2 id="三：《法国民法典》的借鉴意义和中国的《民法典》"><a href="#三：《法国民法典》的借鉴意义和中国的《民法典》" class="headerlink" title="三：《法国民法典》的借鉴意义和中国的《民法典》"></a>三：《法国民法典》的借鉴意义和中国的《民法典》</h2><p>​    《法国民法典》固然是一本具有重大历史意义的法典，但不论怎么说，毕竟是几百年前的法律，也是为资本主义量身打造的法律，可能有人就会问了，那我们劳心费神地学习《法国民法典》到底是为了什么。必须要指出的是，不光是学习《法国民法典》，学习任何一门法律对我们都是有重要意义的，这意义就处于我上一文段中所提及的，孟德斯鸠所倡导的“法的精神”之中。没有任何一部法律能够完全适合任何两个国家，不同的国家也不可能有完全一样的社会因素，因此我们在学习法律的时候从来都不只是单纯的照搬法律条文，也不是单单学一个法而已，我们学习法律的时候，一定要从法律所属的国家的各种因素入手，这些因素包括但不限于“气候，环境，宗教，习俗，时代”等。正是这些因素的差异构成了不同国家的差异，也构成了不同法律的差异。鲁迅先生在《拿来主义》一文中曾描述过这样的拿来主义者：“他占有，挑选。看见鱼翅，并不就抛在路上以显其“平民化”，只要有养料，也和朋友们像萝卜白菜一样的吃掉，只不用它来宴大宾；看见鸦片，也不当众摔在茅厕里，以见其彻底革命，只送到药房里去，以供治病之用，却不弄“出售存膏，售完即止”的玄虚。“，我们在学习外国的法律时，便是要秉持这样的拿来主义，不论好坏，都先拿来，学习一遍，从中挑出那些好的法律精神，当作我们学习的榜样，将那些不好的法律精神，当作我们惊醒的经验，再用我们学来的那些优秀的法律精神引导我们的学习与立法。如果我们想要相对轻松的制定一部良法，他山之石是我们最好的助力。</p>
<p>​    近日出台的中国《民法典》是新中国成立以来，第一部用“法典”二字命名的法律。这个“典”字，是民事法律质量飞跃的标志，是民事法律制度成熟完备的象征。就像《法国民法典》是为了资本主义的利益需要一样，中国《民法典》的编篡也是为了维护最广大人民的根本利益。以人民为中心，不光是《民法典》的法律精神，也是我们党的精神，我们国家的精神。《民法典》的编篡，便是结合了我们中华民族的“一般精神”和中国特色社会主义新阶段的“时代精神”的一次成功的法典编纂。</p>
<p>​    而同时，中国《民法典》还具有鲜明的中国特色，对中国文化中的优点进行了传承与发扬。这说明，中国的《民法典》是包含有中国的传统思想在内的，更便于我们中国人的理解和认同，同时也便于向世界宣传与推广我们的中华文化。《民法典》的编篡是一项中华文明创造性的转化和创新性的发展的活动，我们可以通过《民法典》看到我国优秀的传统文化和法律文明成果之间的相互交融。</p>
<p>​    更者，《民法典》的编篡还有助于更好的推进法治社会的建设，依靠良法来促进善治。这样一部优秀的法典的颁布，能为国家治理体系提供有力的保障，是推行法治社会的重要支撑。其中的种种条例，都是实打实的为老百姓考虑，在避免原来各个民事单行法协调不足等弊端的同时，还建立健全了一系列新型民事权利或制度，大大提升了民法自身的内在品质。就拿前些年非常严重的“碰瓷”现象来说，如果不加以制止，只会让越来越多的热心人被恶人所害，凉了人心。而《民法典》中就有这么一个条令：因自愿实施紧急救助行为造成受助人损害的，救助人不承担民事责任。短短一行字，为无数潜在的英雄做了保证-不用怕，放心救。这只是一个很小的方面，而《民法典》中有无数个小方面，从而涵盖了生活的方方面面。</p>
<p>​    就像《法国民法典》推动了法国资本主义的发展一样，我们完全可以相信这部集民族精神之大成的《民法典》可以推动我们的中国特色社会主义更快更好的发展。当然，我们不否认这部《民法典》中可能存在的问题，然而就像我们从废墟中建立起新中国一样，只要方向对了，就不怕遇到错误和曲折。</p>
<h2 id="四：结语"><a href="#四：结语" class="headerlink" title="四：结语"></a>四：结语</h2><p>​    人治不如法治，劣法不如良法。不论是对《法国民法典》的学习，还是对中国《民法典》的探讨，都是基于我们心中的一个最初始的梦想：建立一个更美好的中国。希望我们在学习的过程中，不忘初心，即使学海无涯，但只要方向对了，就一定能到岸。</p>
]]></content>
      <tags>
        <tag>法师or律师？</tag>
      </tags>
  </entry>
  <entry>
    <title>从《论法的精神》解读孟德斯鸠的法与精神</title>
    <url>/2020/07/28/%E4%BB%8E%E3%80%8A%E8%AE%BA%E6%B3%95%E7%9A%84%E7%B2%BE%E7%A5%9E%E3%80%8B%E8%A7%A3%E8%AF%BB%E5%AD%9F%E5%BE%B7%E6%96%AF%E9%B8%A0%E7%9A%84%E6%B3%95%E4%B8%8E%E7%B2%BE%E7%A5%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="从《论法的精神》解读孟德斯鸠的法与精神"><a href="#从《论法的精神》解读孟德斯鸠的法与精神" class="headerlink" title="从《论法的精神》解读孟德斯鸠的法与精神"></a>从《论法的精神》解读孟德斯鸠的法与精神</h1><h2 id="零：引言"><a href="#零：引言" class="headerlink" title="零：引言"></a>零：引言</h2><p>​    无论是研究西方社会，西方政治或者西方法律都绕不开孟德斯鸠的经典著作《论法的精神》。产生于启蒙运动中的《论法的精神》具有独到的见解和思想，这也使得即使过了漫长的岁月直到如今，对它的研究和评论依然层出不穷。</p>
<p>​    然而当我们读到《论法的精神》和其在不同时期的研究文献时，总会有一种熟悉而又陌生的感觉，这是因为在不同的时期的研究者，往往受到时代的思想所干扰，在其中添加了许多属于所处时代的主观思想。正如英国哲学家科林伍德所说“一切历史都是思想史”，因此从后世从当下的角度来研究孟德斯鸠的《论法的精神》总会有所偏颇。</p>
<p>​    虽然在西方早就有对孟德斯鸠的相关研究与学习，然而东方直到清代维新时期才有进步人士关注并倡导。维新变法中所倡议的三权分立制度，修立宪法，开设议会等改革便是受到孟德斯鸠的思想的影响。在20世纪之初，由梁启超编撰的《法理学大家孟德斯鸠之学说》是中国第一本系统介绍孟德斯鸠的思想的著作，同时期，孟德斯鸠的《论法的精神》也被引入中国。</p>
<p>​    在孟德斯鸠的作品被引入中国后，他的名字便与启蒙的大旗牢牢绑定，与“分权”，“理性”等观念一样深入人心。他在《论法的精神》中所讨论的，关于法律和各种环境因素之间的关系和对中国的传统政治体系的优劣至今仍然不断引发国人的争论和思考。</p>
<p>​    写作本文是由于对孟德斯鸠《论法的精神》的阅读和思考，试图从书为管，一窥孟德斯鸠所代表的一类西方法律思想，且尽量避免带入过多的主观意识，力图通过客观的语境分析，文本分析和历史分析，还原在西方法律思想史上留下浓墨重彩的孟氏思想。</p>
<a id="more"></a>

<h2 id="一：启蒙的曙光—启蒙运动之中的孟德斯鸠"><a href="#一：启蒙的曙光—启蒙运动之中的孟德斯鸠" class="headerlink" title="一：启蒙的曙光—启蒙运动之中的孟德斯鸠"></a>一：启蒙的曙光—启蒙运动之中的孟德斯鸠</h2><p>​    纵观全球历史，18世纪的法国可以说是拥有无限的风光。18世纪又被称作“启蒙时代（Siècle des Lumières）”，是个毋庸置疑的伟大的时代。时势造英雄，而孟德斯鸠就是那个时代最耀眼的英雄。启蒙时代为“理性”和“自然”的探讨提供了一片沃土，而培育出的孟德斯鸠这样的人才也使得这片厚土更加肥沃。在那个时代，思想家们抱有这样一个坚定的信念：人类能够根据自身的理性来建构社会，而这种社会以模仿自然作为基础来建构。这样的世界是一种“自然法”的世界。</p>
<p>​    虽然法兰西是启蒙世纪里的头号主角，但是主流认为启蒙运动开始的主要标志是英格兰的光荣革命（Glorious Revolution）（1688-1689）。在英格兰通过那部具有重大意义的《权利法案》之前的二十多天前，启蒙世纪的男主角孟德斯鸠出生，仿佛冥冥之中昭示着启蒙浪潮之中最耀眼的新星诞生。</p>
<p>​    孟德斯鸠和所有故事的主角一样，拥有传奇的一生。出身贵族的他从小被父母教导要“永远记住对穷苦人民所负有的义务”，这种思想伴随他伟大的一生。他不但撰写大量经典书籍为世人带去启蒙，还在工作中（孟德斯鸠曾任波尔多高等法院庭长）以民为本，多次为民请命，从未辜负他父母的期望。这种思想同样受到其他人的认可，法兰西学术院，伦敦皇家学会和普鲁士皇家科学院先后都曾吸纳他，希望他能成为其成员。</p>
<p>​    在他著成《论法的精神》之前，他的才华就已经得到了一定的显现。著名的作品有《西塞罗赞》，《波斯人信札》，《罗马盛衰原因论》等。此前阅读这些作品，不过觉得是一个有点才华的年轻人的文章，可当《论法的精神》问世以后再看，便会惊讶的发现孟德斯鸠的风格，思想和观念早在先前的文章中得到了鲜明的展现。这意味着《论法的精神》于孟德斯鸠并非是多年闭关得来的惊世之作，而是其早期思想沉淀积蕴而成的香浓陈酒。</p>
<p>​    就如同任何一位先驱者，《论法的精神》这部划时代巨作也给孟德斯鸠带来了大量的麻烦。他既要在学术上与各种各样的反对者论战，又要面对不怀好意的政府和教会的警告和威胁。各种各样的部门借由不同名义对这本书进行审查，翻译这本书的启蒙思想家瓦斯科伯爵和历史学家詹农受到了意大利当局的迫害。更有甚者，连无意中流露出自己“熟悉孟德斯鸠和他的《论法的精神》”都是极度危险的。在此书出版三年后，罗马教廷将其列为禁书，阻止其在欧洲大陆的传播。孟德斯鸠虽然曾匿名为自己的作品辩护，却如同石沉大海，没有作用。</p>
<p>​    但是金子总是会发光，纵使遭到迫害和打压，纵使被部分人批评和指责，《论法的精神》依旧传承着孟德斯鸠不朽的精神直到如今。</p>
<p>​    为了保护自己，孟德斯鸠将那些“非正统的观点”隐藏起来，以防当权者的恶意报复。他将那些与当时社会不一致的重要真理进行了处理，力图使“让会痛恨这些话的人无法理解真实含义，却又能让理解这些话的智者不会莫名其妙”。《论法的精神》是给聪明而正直的人读的，那些隐晦的思想和学说要从细节之处入手才能掌握整体的原则。在《论法的精神》的序言中，孟德斯鸠也有提及“此书是我深思熟虑规划而成的作品，读者不要仅仅翻阅寥寥数页就对这部著作妄下断言。想要探明作者的意图，必须要读完整部著作才能发现”。</p>
<p>​    然而正如伏尔泰的评论，《论法的精神》确实具有很严重的结构上的问题，“犹如迷宫”。这种问题是有多方面的原因的：长达二十余年的写作周期让文章的结构变得不那么有序，而孟德斯鸠的思想却又是非常跳脱，不拘一格的非线性思维，还为了预防可能会招来的报复而做的模糊处理。这些原因都使得这部作品的结构很复杂很混乱，这也正是孟德斯鸠的思想的特点所在：不是系统化的建构，而是理性的思维；不用法学的形而上学推演，而是在贴近生活的地方性因素中寻找法的精神。</p>
<p>​    孟德斯鸠在为自己的著作辩护时反击道：“如果我们要评论鸿篇巨著，不能光凭热情，还要有智慧，如果上天没有赐予你这样的天赋，那你就要用自我怀疑，精确表达，下苦工和反思来将其弥补”。虽然这没有阻止批评的蔓延，因为在那个“把每种公众情感都乔装打扮成哲学”的浮躁时代，在那个被戏称为“文人共和国（Republic of Letters）”的岁月中，孟德斯鸠和他的伟大作品注定无法平静。</p>
<p>​    1755年2月10日，这颗伟大的新星因病离世，在他身后，启蒙的时代依然躁动。</p>
<h2 id="二：成功的范例—兴盛的英格兰和他的宪法"><a href="#二：成功的范例—兴盛的英格兰和他的宪法" class="headerlink" title="二：成功的范例—兴盛的英格兰和他的宪法"></a>二：成功的范例—兴盛的英格兰和他的宪法</h2><h3 id="1：孟德斯鸠的政体类型学建构"><a href="#1：孟德斯鸠的政体类型学建构" class="headerlink" title="1：孟德斯鸠的政体类型学建构"></a>1：孟德斯鸠的政体类型学建构</h3><p>​    法国社会学家埃米尔·杜尔凯姆（Émile Durkheim）提出过这样一个观点：科学不能描述个体，只能描述类型。也就是说如果人类社会不能被准确科学的分类，就必然无法得到科学的描述。而社会科学的先驱孟德斯鸠凭借其在《论法的精神》中提出的独到的政体类型学，将人类社会进行了科学的分类，从而使社会学上升到了社会科学的境地。而这种独特的政体类型学正是他的“法精神”理论的具体展开。</p>
<p>​    孟德斯鸠在研究中采取了与古希腊哲学家亚里士多德的理想型的建构方式不同的经验型建构，将一些表面上“毫无关联”的各种资料进行整合处理，将与政体相关联的多重自然事实进行细致的要素提炼，并且根据这些要素归纳出了不同的，清晰易懂的政体类型。在孟德斯鸠理论中的君主政体，贵族共和政体，民主共和政体和专制政体等，在现实生活中都可以找到相印证的实体：比如共和政体之于雅典，君主政体之于英格兰，专制政体之于波斯。</p>
<p>​    孟德斯鸠甚至观察了一些文明程度较低的社会，如未开化的人（savages）和野蛮人（barbarians）的社会。未开化人的社会是分散的不联合的小民族，以狩猎为生；而野蛮人可以联合，通常以游牧为主业。虽然这些民族的文明程度较低，但其实这些社会本质上是一种低级的民主社会，并且可能是君主制社会的渊源。孟德斯鸠的研究发现，未开化人或者野蛮人一旦离开原先的环境，就有可能演化成其他的政体模式。比如原先是野蛮人的日耳曼民族征服欧洲之后，日耳曼尼亚的日耳曼人和在新土地上定居的日耳曼人就演化出了具有相当差别的政体，虽然这些政体由于地方性因素而具有不同，但是因为其有日耳曼人的本质内核也即“一般精神”，在相当一部分领域中仍然保持着类似的法律。</p>
<p>​    孟德斯鸠和孔德，马克思这样的社会学家不同，他的理论不是以“改变现有社会，创造更进步的社会”为目标，而是建立在对事实的审视之上。从孟德斯鸠的论述中可以找到社会变迁的深层的原因，那就是社会所属的“一般精神”的变迁。每个民族每种社会都有其“一般精神”，也有对这种精神作用“相对较强”的因素，因此在“一般精神”的变迁过程中也会有“线索”和“方向”可寻。所以，深入考察一个民族的“一般精神”非常重要，这也是改善现实中法制与宪制的唯一途径。我们可以通过对不同民族的法和各种环境因素的对比，探寻“法”和法的“一般精神”的内在关联。</p>
<p>​    孟德斯鸠在建构其政体类型学时，为政体类型的存在寻找了一些课比较的环境因素，并称之为政体的性质，原则与目标。在孟德斯鸠笔下，每一类政体类型都拥有独特的性质，原则和目标，并且这些独特的要素与政体所处的“法精神”有紧密的联系。某一类社会采用某一种政体的原因，是因为这个社会中的“一般精神”是培育这种政体的厚土，从中形成了相应的“法”。如同自然界中的有机存在一样，政体也会发生腐化，而预防这种腐化的方法便是保持“一般精神”的性质不发生改变。</p>
<p>​    在《论法的精神》中，孟德斯鸠主张“法精神”的多样性存在，这种多样性存在便是某种意义上的法律多元主义。他尽可能客观而公正的描述各种政体和其存在的合理性，并认为立法者需要尊重与政体相适应的“一般精神”而不能改变其民族的习俗与风尚，否则就会引发巨大的变革和暴动。</p>
<p>​    即使是孟德斯鸠，却也无法保证绝对的公正。在《论法的精神》一书中，孟德斯鸠对他所挚爱的法兰西穷尽赞美之词，并且希望法兰西的政体不发生可怕的腐化。因此他在书中着重笔墨刻画被他理想化的英格兰宪制，竭力通过这种迂回的方式来告诫他所爱的法兰西。见一以明理，我们便对孟德斯鸠理想中的英格兰宪制进行剖析。</p>
<h3 id="2：自由，法律，分权，宪制和英格兰"><a href="#2：自由，法律，分权，宪制和英格兰" class="headerlink" title="2：自由，法律，分权，宪制和英格兰"></a>2：自由，法律，分权，宪制和英格兰</h3><p>​    孟德斯鸠是公认的自由主义代表人物，其理论也被封为自由主义的法哲学代表理论。这里的自由不是无法无天的自由，而是适度的，依据事物的“自然秉性”的自由。因此他在详细论证英格兰宪制和政治自由，论证英格兰的政体和法与英格兰民族的习俗风尚的关系时，又认为英格兰的自由是其他民族无法模仿和移植的。其他国家如果想学习英格兰，只能从自己民族的“一般精神”出发，依据自己民族的“自然秉性”，以自己的道路去向政治的自由靠拢，探寻更适合自己的“适度自由”。为此我们可以这样认为：论述英格兰宪制是孟德斯鸠对于法兰西未来的走向的思考。既然英格兰的宪制是最适合英格兰“一般精神”的宪制，那么对于法兰西的“一般精神”，什么才是最适合的道路呢？孟德斯鸠的字里行间无不充斥着对这个问题的思考。</p>
<p>​    从这个目的出发，孟德斯鸠开始了他对以“政治自由”为目标的英格兰君主政体，他对英格兰宪制的推崇到了一个无与伦比的地步，即便在英格兰也被认为是“无法撼动的权威之论”。孟德斯鸠宣扬了一种“将英格兰的制度作为实现政治自由的标杆”的理念，更在宣传的过程中论证了他“法精神”理论的正确性。这种正确性体现在：英格兰的核心在于“自由”，这种“自由”被英格兰的“法律”所确认，而这种“法律”的保障来源于“分权”的政体，“分权”的思想被“宪制”所约束。</p>
<p>​    孟德斯鸠认为“如果君主政体不向政治自由靠近，就会腐化成专制政体”。这也是对于君主政体和政治自由的基本定位。英格兰的宪制以政治自由作为其根本目标，同时也为其他民族和国家提供了远离专制，建立自由政体树立了标杆。由于自由和专制是两个互不相容的存在，那么一切有害于专制的存在，那就是有利于自由，从这个角度出发，孟德斯鸠对法兰西打击封建领主的司法权和宗教权而建立绝对主义国家提出了直接的批评。</p>
<p>​    孟德斯鸠笔下的自由是在一个“有法可依”的社会之中，人们拥有做“想要做的事”和不被强迫做“不想要做的事”的权利，这种自由是居于法律之下的自由，是不会影响法律的。孟德斯鸠将权力和自由区分开来，只有权力未被滥用时，才有政治自由可言。但由于人类本身的性质，拥有权力的人都倾向于滥用权力，所以这个时候需要设定一种制度，用另外一种权力来制约一种权力，这便是分权思想的由来。</p>
<p>​    英国哲学家约翰·洛克（John Locke）曾将权力分为立法权和执法权，并且说“如果有人拥有全部立法和执法的权力，那就不存在裁判者”。而孟德斯鸠基于洛克的分权思想，将权力划分为三种，即立法权，执法权和司法权。立法权归属于君主或者执政者，是能够制定或着废除法律的权力；执行权又叫行政权，归属于国家对外行政者，是关于对其他国家的政治权力；司法权属于对内行政者，是用于裁决私人争执的权力。如果这三种权力归于同一个人或者同一个利益集团，那么公民的自由和安全将不复存在。</p>
<p>​    即便是三种权力的的其中两种集中在一个人或一个利益集团身上也会是无比可怕的灾难：譬如立法权和行政权在一个人身上时，那么就可能会出现制定荒唐无道的法律被人执行；而如果是立法权和司法权集中时，那么公民的生命和自由全由法官说了算；如果司法权和行政权集中时，那么法官就不再是公正的判决者，而是专断的压迫者。在土耳其，在意大利，三种权力归属于同一个人，因此产生了可怕的专制。即便是表面上分为三权的威尼斯，实质上也被同一个政治集团掌握，这也导致了骇人听闻的专制。</p>
<p>​    更何况，每一种权力的拥有者都倾向于和其他权力的拥有者相联合以谋求更大的利益。为防止这个令人胆寒的可能性，孟德斯鸠认为应当确保“没有一个常设机构拥有司法权，司法权的执行者应该来自民众；法院的构成虽然不固定，但却应该有同样的判决”，这便是英格兰宪制中的陪审团制度，而对于立法权和行政权，则可以赋予一些官员或者常设机构，但要接受人民的监督，不违背人民的利益。而关于权力的制约则体现在“拥有行政权的君主只能通过否决权参与立法，而不能提议创立新的法律；同时君主因受到拥有司法权的法院监督，以确保不做出违背人民利益的事；而法院所参考的法律，法条只能通过拥有立法权的机构来创立和修改”。</p>
<p>​    虽然孟德斯鸠在对英格兰宪制的深入描述中表现出了无比的推崇，但是实际上他推崇的并不是君主制或者民主制。相反，他认为任何一种政体都不比另外一种政体更优越，只有符合在“特定的时空条件”下的人民所追求的政府形式才是好的政体。因此与其说他是推崇英格兰宪制，不如说他是推崇与英格兰的“一般精神”十分契合的英格兰宪制，倘若将英格兰宪制拿给缺乏那种“一般精神”的民族，那边如同给脚带手套一般可笑了。</p>
<p>​    虽然我们知道孟德斯鸠推崇英格兰宪制是为了找寻适合法兰西的道路，然而18世纪的法国却更钟情于卢梭的共和主义，反而是在北美有了深远的影响。美国宪法将孟德斯鸠的分权原则作为新政体的基础，建立了一个现代的混合政体国家。孟德斯鸠的思想在隔洋相望的另一块大陆生根发芽，在另一块大陆更为适宜的地理性因素和那片土地上培养出来的“一般精神”的影响下，构建成了一个自由的美利坚宪制，又一次印证了孟德斯鸠关于“法”和“法精神”的理论。</p>
<h2 id="三：法律的精神—法律所应具有的“法精神”"><a href="#三：法律的精神—法律所应具有的“法精神”" class="headerlink" title="三：法律的精神—法律所应具有的“法精神”"></a>三：法律的精神—法律所应具有的“法精神”</h2><p>​    孟德斯鸠早在《论法的精神》的第一段就借用《变形记》中的一句话为自己的法律观下了一个定义“无母而生的孩子”。他的作品没有先承，也与其他当代作品不同；虽然以法律为主题，核心法律观却隐藏在层层迷雾之下；他的虽然将法律与自然法相连接，然而却自有一派的自然法观念；他讨论看似毫无关联的地理环境因素和社会因素，最后却话锋一转说这其中的关系才是“法”和“法的精神”。我们在此对其思想加以论述。</p>
<h3 id="1：What-is-law（法律或是法则）"><a href="#1：What-is-law（法律或是法则）" class="headerlink" title="1：What is law（法律或是法则）"></a>1：What is law（法律或是法则）</h3><p>​    由于语言和翻译者的原因，往往会造成对文章意思的理解出现错误。比如在书中的loi/droit/law在中文中可能是法，法律或者规律，法规。更让人头疼的是这些含义在《论法的精神》中都有存在，因此要想理解孟德斯鸠的法律观，必须先弄清楚这些含义的区分。</p>
<p>​    广义上的法不是指任何一条单一的法规，而是源于事物天生本性的必然的联系，因此只要有存在就有法，一切存在的东西都有自己的法。这里的法包括了物理学，生物学等一系列自然科学遵守的法则，也包括抽象世界中正义与邪恶的定义规则，是一种形态多元的法。在孟德斯鸠的语意中，法不是主观的精神产物，而是客观的必然规律。在他的定义下，法是由“天生的理性（primitive reason）”所衍生出来的事物相互关系。何为天生的理性？这又值得我们细细思考。</p>
<p>​    孟德斯鸠的法思想的超前性首先体现在反对宗教中上帝的“绝对权威”，他认为这种天生的理性是就连上帝也要遵从的，上帝创造世界看似随心所欲，然而却是遵从着不变的法则。这一点可以用一句话论证：如果没有法则，那么世界便不复存在，所以造物主（即上帝）不能无视法则来治理世界。</p>
<p>​    更妙的是虽然孟德斯鸠在全书中不断提及上帝，但这里的上帝和宗教意义中的上帝已经大相径庭，已经失去了“至高智慧”的内涵，更像是避免可能会找上门的宗教势力的幌子。孟德斯鸠借由普鲁塔克（Plutarchus）的名言“法是人和神共同的主宰”，将神或者人的个体意志从法律之中排除，从而为“法的精神”这一概念奠定基础，把法律的观念进一步世俗化。</p>
<p>​    同样具有超前性的是孟德斯鸠的“法的本质是关系”论，此种论点方一问世便遭到他人批判，然而批判不能改变其正确性。“每一种差异都具有同一性，每一种变化都具有一贯性”，孟德斯鸠的法同样具有二元的特殊性和普遍性。其特殊性体现在“对于不同的民族和不同的‘一般精神’”要“量身定做”，而其普遍性体现在每一种现象因为与不同的“关系”相连而存在不同的“法”，这种“法”与“关系”之间的法则是普遍的。</p>
<p>​    就像数学推理需要由公理推出定理，再由定理作出推论一样，在孟德斯鸠的实在法存在前也需要更古早的法，这种法是由前文所提及的“天生的理性”衍生，可以叫做天生的法律。</p>
<p>​    在孟德斯鸠观念中的法具有“不变之秉性”，而这种不变的秉性，正是“法精神”的体现。</p>
<h3 id="2：孟德斯鸠的自然法"><a href="#2：孟德斯鸠的自然法" class="headerlink" title="2：孟德斯鸠的自然法"></a>2：孟德斯鸠的自然法</h3><p>​    先前我们提及孟德斯鸠的法是基于自然法的，然而孟德斯鸠本身却具有和其他自然法学者不同的自然法学观，这导致了孟德斯鸠思想的特殊性。</p>
<p>​    孟德斯鸠的自然法观受到格劳秀斯（Hugo Grotius）和普芬道夫（Pufendorf）的著作影响，希望能将法律和政治世俗化。其他的典型自然法学家如洛克和卢梭等，希望联系自然和社会的桥梁从神变成人的自由意志。洛克认为人生而平等自由，因此在社会中也要保持平等自由，而卢梭认为人要摆脱自由的动物状态而成为理性的社会人，用社会的自由代替自然的自由，但是孟德斯鸠对自然状态，社会契约或者自然权利都不感兴趣，不认为不同国家的法律可以由普适性的道德作为指引，认为人们对于社会学现象可以“观察之”甚至“嘲讽之”，但不能“评判之”。</p>
<p>​    从孟德斯鸠的书中来看，他确实提及了自然法不错，然而他列举自然法的目的是表达人类社会组成之前支配人类行为的“关系”和“方式”。他的自然法更多是作为人的基本法治的描述。在孟德斯鸠眼中，自然与社会只是物质世界和智能世界组成部分的两面而已。孟德斯鸠只写了自然法，却没有和其他的自然法学家一样论述如何使用这些自然法去引导人民。我们可以说对于自然法的理论，他只写了前半部分，后半部分则是他的思想开陈出新的部分。</p>
<p>​    若要说孟德斯鸠和其他自然法学家有什么共识的话，那就是主张法并非源自神。然而就是这样小小的共识，孟德斯鸠也与其他自然法学家有所不同。孟德斯鸠认为社会性是人与生俱来的，自然状态和社会之间的微小差异并不具备政治上的意义。这种社会性使得人和人之间需要一定的规则，而这些规则便形成了法律。同时其他自然法学家的社会契约论，都假设了自然状态和社会在性质上具有明显区别，具有政治上的意义。孟德斯鸠认为人首先面对的不是作为社会意义的人，而是作为自然意义的人，当人把对方也视作与自己一样的人时才产生了社会，而社会的产生导致了战争。</p>
<p>​    这一点很值得讨论，战争不是产生社会的原因，而是社会产生的后果，为了约束这种后果，社会之间的法律也应运而生。这些产生的法律则是人为法。</p>
<p>​    因此在孟德斯鸠的观念中，自然法和人为法构成了一种包含关系。自然法是具有普适性的一般法，是抽取了社会属性之后支配人行为的法则的集合，是所有人都在遵守的法则，而人为法是具有社会属性的民族和人自己的法则，是狭义的特殊法。</p>
<p>​    孟德斯鸠的法是多元的法，不仅各个民族各个国家的法是特殊的，就连法本身也具有多样性。因为不同的法规定了不同的秩序，因此产生了许多种法律，人在不同情况下受到不同的法律的约束。</p>
<p>​    虽然孟德斯鸠强调基于人自然属性的自然法，但他也承认基于人类理性的自然法，即便是差距如天壤之别的社会之中，也会有共同的法律，这种法律就是源于“天生的理性”的天生法，是不需要人来证明其正确性的法，也是孟德斯鸠理念中的普适之法。从这个角度出发，可以说孟德斯鸠抱有这样的一种主张“自然法优于人为法，自然法的不变本性是一种客观存在，自然法的真理在不同社会中都会得到体现”。</p>
<p>​    孟德斯鸠在对自然法和人文法的论述时延续了古希腊将自然（自然法）与人（习俗）两分的传统，也即“立法者是人，是人就会犯错”。习俗本质具有相对性和易变性，自然法却是固定和不可触犯的。孟德斯鸠的二分法同样基于人为的立法可能会产生的错误，他认为立法者只是颁布法律而非产生法律，即便没有立法者，法律依然会存在。立法者是一个具有智能的存在，却也受限于他的智能，因为被“本性所限”，既不始终遵守天生的规则，也不始终遵守自己制定的法律。各个社会的法律原本应由环境因素的关系而存在其特殊的法则，作为立法者需要了解这些关系和法则，从而更好地了解最适合自身的法与政体。</p>
<h3 id="3：法的精神"><a href="#3：法的精神" class="headerlink" title="3：法的精神"></a>3：法的精神</h3><p>​    在《论法的精神》中，孟德斯鸠区分了法和法精神。他认为“法的精神存在于法与各种事物可能发生的关系之中”，而对于某一个民族而言，由于“气候，宗教，法律，传统，习俗，礼仪”等因素的影响，会生成这个民族的“一般精神”，他告诫立法者在“不违背政体的限度内”要尊重这种民族精神因为“当我们依照自然秉性行事时做得最好”。</p>
<p>​    他还讨论了各种环境因素与法律的关系，包括地理环境因素，民族的习俗与礼仪，社会环境因素，贸易，货币，人口，宗教等以及由此产生的“一般精神”。他还探讨了政体，军事与法的关系。此外，他还讨论了实现政治自由之法与宪制和公民的关系。他的写作方法成为了新型的关于政治法律理论叙事的开端，也就是社会科学的政治法律理论叙事。黑格尔对其有这样的评价“孟德斯鸠以伟大的见解考察各种法制，并认为法制，宗教以及一个国家内的一切构成了一个整体”。</p>
<p>​    在当时这些环境因素看似并没有系统逻辑，但到了如今已然在学者之中达成共识且更加深入，比如对于不同的民族，占据支配地位的环境因素也不一样，且对于越高文明程度的民族而言精神性因素有更大的影响力，比如“野蛮人几乎只受大自然和气候的影响，中国人受到礼仪的支配，日本人被所谓‘大义’控制，斯巴达的信条是他们的习俗，而罗马的基调是他们的施政准则”。</p>
<p>​    因此，孟德斯鸠所说的“一般精神”是一种经验，是一种结果，而非是先验性的前提。立法者所发现的“一般精神”并使得立法符合这种精神，立法本身就是寻找某个民族的“自然秉性”，这种法与法精神之间的关系，正是确定法之正当性的法则。出于这种正当性，孟德斯鸠的法不再依赖于形而上学，而是成为了依赖于经验性环境因素的普适法，由此开始，法学出现社会科学研究的雏形。</p>
<h2 id="四．结语"><a href="#四．结语" class="headerlink" title="四．结语"></a>四．结语</h2><p>​    孟德斯鸠和他独特的法精神观使他成为那个风起云涌时代的顶尖人物，《启蒙运动百科全书》对他有这样的一段评价“他是最博学最重要的启蒙思想家之一，他批判了当时法国社会并促进了英国君主立宪思想在欧洲的普及……他在政治理论，历史学，社会学方面留下的遗产无疑是启蒙运动为现代西方文明留下的最重要的成就之一，也是启蒙运动最广为人知的贡献之一。”</p>
<p>​    孟德斯鸠在《论法的精神》中使用的写作方法使得政治理论的写作方式从形而上学转向社会科学，不可不谓是社会科学的先驱，正如他自己的评价，是“一位对以往千百年有着透彻了解的历史学家，一位善于思考的社会学家”。</p>
<p>​    孟德斯鸠理论中的“法”兼具实在法和普遍法的双重意义，这种双重的意义在《论法的精神》中广泛地存在并连接着各个社会的生活世界，是各个社会的生活方式，也是各个社会背后的“一般精神”。按照孟德斯鸠的话来说，我们观察局部是为了对整体做出判断，我们考察原因是为了看清结果，因此我们作为社会中的主体，不仅要去掌握自然世界中的法则，同样要去创造和完善世界本身的规则。</p>
<p>​    虽然如今已然是一个全球化的时代，然而距离法律的全球化尚有很长的路要走，那是因为全球尚未形成一种统一的“一般精神”。为了应对和迎接即将到来的挑战和转型，我们应当学习孟德斯鸠的思想，并将其演化入中国环境中，成为新时期中国寻找中国法的“一般精神”的强力助手。尤其是在民族复兴的关键时期，寻找“一般精神”更具有无比重大的意义，因此我们在此时此地，在此种历史文化环境之中，依旧要沿着孟德斯鸠为我们找到的具有借鉴意义的道路前行，找寻适合我们复兴中的中华民族的“一般精神”。</p>
]]></content>
      <tags>
        <tag>法师or律师？</tag>
      </tags>
  </entry>
  <entry>
    <title>19-20下学期形势与政策</title>
    <url>/2020/07/28/19-20%E4%B8%8B%E5%AD%A6%E6%9C%9F%E5%BD%A2%E5%8A%BF%E4%B8%8E%E6%94%BF%E7%AD%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="大难之际，方显真章"><a href="#大难之际，方显真章" class="headerlink" title="大难之际，方显真章"></a>大难之际，方显真章</h1><p>​    共产主义和社会主义自诞生以来，便长时间受到资本主义世界的针对和打压，中国的特色社会主义更是如此，直至今日，国内国外都有大量的人在鼓吹资本主义的优越性，贬低中国特色社会主义。然而就像俗话说的那样“光说不练假把式”，没有经历过灾难的考验，说谁比谁优越都是不可取的。因此面对这些言论，中国从未急于证明自己，因为他知道，证明自己的机会自然会来到。</p>
<p>​    列宁这样说过：“实践高于（理论的）认识，因为它不但有普遍性的品格，而且还有直接现实性的品格。”在疫情爆发前，可能人们会存在这样一个疑惑：中国特色社会主义和其他的社会主义，和资本主义有什么区别？中国的优越性又在哪？在我们的日常生活中，可能人们并不能直观感受到差距，甚至会觉得中国远不如资本主义国家。但是，实践是检验真理的唯一标准，这次的新冠疫情，便是一次最好的实践机会，一次绝佳的，证明自己的机会。而我们的国家也没有辜负我们的期望，在这次考验中，交出了一份完美的答卷。再和自认优良的资本主义相互一比较，就更体现出中国特色的制度优势。</p>
<a id="more"></a>

<p>​    在中国，通过政府和媒体的努力宣传，就连小孩也知道对于传染性极强的新冠疫情，防控的最基本要求就是自觉戴口罩，少出门，少接触，多消毒，多隔离。在这一层上中国特色社会主义便展示了无与伦比的优越性，而资本主义是散漫惯了的，毫不在乎的无保护出门，导致了如今严重的疫情形式。当中国决定封城时，政府下令禁止出门，在短短两天之内，14亿中国人便在大街上销声匿迹了。相关人员开始进行健康排查，每家每户积极配合配合，竭尽自己所能提供帮助。这是抑制疫情传播的最好方式！而资本主义的人却宣称这是“反人权”，竭尽所能的诋毁中国对疫情防控做出的努力。现在的结果我们也能看到，中国已然开始复苏，重新踏上发展的道路，而美国到现在还在以一个可怕的速度增加新的病人，更可怕的是，他们甚至没有弄清楚到底有多少人患病。说到对患者的排查，又不得不提一下中国政府的努力。</p>
<p>​    同样是面对如此庞大的人口基数，中国为何能够在如此短的时间内排查完毕？为什么自诩先进的美国做不到？因为我们每一个中国人都是非常相信自己的国家和政府的。正是有着这一股凝聚力，让中国在短短几十年之间发展的如此迅速。在这场战役中，我们既是旁观者，但同时也是参与者，我们有一个英明的领导者，全国上上下下有着共同的信念：我们必赢！中国特色社会主义下，人们有强大的凝聚力，能够团结一心，办成一件大事，这是其他制度不具备的，更是中国特色社会主义在实践中证明的优越性。</p>
<p>​    至于疫情爆发的中心，湖北武汉和美国，政府更是交出了截然不同的两份答卷。短短几天，武汉封城，火神山雷神山相继以令人震撼的“中国速度”建成，全国上下在防控疫情的基础上，源源不断的生产医疗物资和生活物资，一架又一架的飞机满载着医生护士，口罩防护服驰援武汉。这种方式是经过多次实践检验的，攻克难关的方法，团结的中国人在一次次的灾难面前证明了他的有效和优秀。从唐山到汶川，从非典到新冠，一方有难举国支援从来都是唯一解。然而反观资本主义的代表，美国。纵使中国珠玉在前，做了良好示范，然而所谓民主自由的美利坚，却无法做出有效的反应，导致到如今拥有世界最多的感染者。有这么个段子“湖北武汉实现新冠6个0，0新增，0确诊，0输入，0疑似，0隔离，0死亡。美国实现新冠6个0，感染人数1000000”虽然是玩笑话，但是依旧体现了中国特色社会主义不可置疑的优越性。如果说西方媒体所谓的“民主自由”是财产优先，群体免疫，老人放弃治疗的话，那我更喜爱的是他们口中“反人权“的全国上下一心，共克难关，不抛弃每一个人，只算生命账的中国。</p>
<p>​    在中国，人的生命永远摆在第一位。即便长时间的停工会给经济带来很大的危害，但是中国的国家政策是“没有确定安全，绝不复工”。这也导致了中国疫情的快速减弱。然而反观美国，政府永远以经济和选票优先，在疫情防止的关键时期，本来应该更严格的禁止出门，然而政府却为了选票和经济，提前要求复工，这也导致了疫情的持续增强。</p>
<p>​    即便在世界范围内，也可以看到中国特色社会主义和资本主义的明显差距。对于在疫情时帮助过中国的国家，无论多少，中国一概涌泉相报。海纳百川，天下为公一直是中国的气度，中国一直都有着承担责任的思想准备，也难怪很多国家愿意寻求中国的帮助，他们知道，谁才会用心帮他们，谁才是真正的君子。反观资本主义国家，无不是自私自利的丑恶。你拦截我的呼吸机，我截停你的防护服，谁也没想过帮助他人，一心想当世界老大的美国，甚至停止了向WHO的供给。真金不怕火来炼，这一场大火烧过，高下立判。</p>
<p>​    如果说经历过这次席卷全球的新冠疫情，还有人不相信中国的制度优越性，认为中国的特色社会主义道路是落后的，我们不应该与他计较，因为他已经失去了辨识真相的能力，无论什么样的证据放在他面前，他也不会改变自己心中的错误思想。和这种人计较是没有好处的，作为新时代的新青年，我们只应该更加自信，对我们的道路，国家，文化的自信。陈腐者让他陈腐，奋进者自当奋进！</p>
<p>​    为什么中国要坚持中国特色社会主义？这个问题的答案非常简单，因为在无数次的实践中，中国特色社会主义都表现出了他独特的优势，中国特色社会主义制度是经过实践检验的优秀制度。只要我们坚定不移的走在中国特色社会主义的道路上，我们的心中自然会充满勇气和信心，因为我们知道，我们的背后是国家的强力保障，我们的脚下是道路的正确方向，我们的前方是未来的光明希望！</p>
]]></content>
      <tags>
        <tag>形势与政策</tag>
      </tags>
  </entry>
  <entry>
    <title>19-20上学期形势与政策</title>
    <url>/2020/07/28/19-20%E4%B8%8A%E5%AD%A6%E6%9C%9F%E5%BD%A2%E5%8A%BF%E4%B8%8E%E6%94%BF%E7%AD%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="新时代浪潮中的新青年"><a href="#新时代浪潮中的新青年" class="headerlink" title="新时代浪潮中的新青年"></a>新时代浪潮中的新青年</h1><p>​    70年前，在旧中国的废墟上，饱受贫弱的中国青年心中想着同一个问题：之后的路要怎么走？</p>
<p>​    70年后，在新时代的浪潮中，富强中新生的中国青年也想着这一个问题：之后的路要怎么走？</p>
<p>​    比起之前的百废待兴，如今的新时代青年面临的问题是在面对比起当年只乱不稳的世界局势时，要如何用好前人为我们攒下的基础，让中国的实力更上一层楼。而这个问题的答案，或许可以从习近平主席在党的十九大报告中一窥究竟。</p>
<a id="more"></a>

<p>​    首先我们要知道，新时代和过去有什么异同？对内，中国特色社会主义新时代是承前启后，继往开来的时代，是获取中国特色社会主义伟大胜利的新时代，我国发展的历史方位，社会主要矛盾都发生了一定的变化，但是基本国情和党的理论主题没有变化，我们依然高举中国特色社会主义的伟大旗帜。对外，中国成为世界上不可或缺的经济体，中国的科技水平在世界上名列前茅，但是我们是最大的发展中国家这一国际地位并没有改变。改革开放以来的历史经验告诉我们：只有中国特色社会主义能发展中国，中国特色社会主义道路是实现民族复兴的必由之路。因此新时代和过去相比，不同的是我们比以往更富，我们在世界上的地位更重，不变的是我们依然要沿着中国特色社会主义道路继续探索。这便是属于我们新青年的新时代。</p>
<p>​    但是新时代中的我们和过去的那一辈人是不同的，他们的迷茫是该如何从无到有，而我们是要如何用好手上的筹码。中国特色社会主义的新时代，是决胜全面建成小康社会，全面建设社会主义现代化强国的时代，也是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代，既是全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦的时代，又是我国日益走近世界舞台中央、不断为人类作出更大贡献的时代。</p>
<p>​    综合分析国际国内形势和我国发展条件后，共产党做出了“从现在到2020年，决胜全面建成小康社会，从2020年到2035年，基本实现社会主义现代化”的战略安排。为了实现这个战略任务，我们新时代青年必须做好奋斗的准备，不断通过学习和实践充实自己，把自己打磨成一柄所向披靡的利剑，在向前奋斗的路途上披荆斩棘。在科研强国的战场上，如今的中国不缺乏骁勇善战的士兵，缺少的是用兵如神的名将，因此我们要做高精尖的科研人才，而最好的方法就是不断的学习并学以致用，不断的奋斗且夜以继日。</p>
<p>​    而实现全体人民共同富裕则是人民最根本的利益要求，也是中国共产党的最高追求。在新时代中，共享是发展的价值宗旨，因此人民的共同富裕也成了新时代的奋斗目标。而在人民生活水平日渐提升的今天，人民对富裕的定义也在发生变化，比如说更好的教育、更稳定的工作、更满意的收入、更可靠的社会保障、更高水平的医疗卫生服务、更舒适的居住条件、更优美的环境、更丰富的精神文化生活等硬性条件，也包括更好满足人们在民主、法治、公平、正义、安全、环境等方面的美好生活，更好满足人们的参与感、公平感、获得感、幸福感、安全感、尊严感等软性需要。为此我们应当如同校训说的“允公允能”，在提升自身的同时兼顾天下，做到“达则兼济天下”，用自己的所学所得回馈这个社会，让他变得更好。</p>
<p>​    中国自古以来便是一个伟大的国家，鸦片战争虽然揭开了这个国家衰弱的序章，但是如今的我们又迈上了复兴的道路。实现中华民族伟大复兴也成为了这个时代的中国梦。为了让中国梦不再仅仅是“梦”，我们新时代中国青年需要坚定不移的沿着中国特色社会主义道路前进，高举中国特色社会主义旗帜继续奋斗。虽然我们在短短几十年内走完了发达国家几百年走过的路，但我们不应当满足于现状，故步自封，而应该再接再厉，接过前人的接力棒，用更快的姿态向前冲锋。</p>
<p>​    当我们把目光从国内移开，放到世界之上，我们便又有了新的使命。不管是哪个国家的人，总是生活在这个地球之上，要想获得长久的幸福，我们需要为全人类做出更大的贡献。习近平主席指出，“中国共产党是为中国人民谋幸福的政党，也是为人类进步事业而奋斗的政党。”我们党所做的一切，都是为中国人民谋幸福、为中华民族谋复兴、为人类谋和平与发展。为了这个目标，习主席提出“一带一路”倡议，发起创办亚洲基础设施投资银行，推动设立丝路基金，为全球经济发展注入中国动力；为解决世界面临的治理赤字，习近平同志倡导构建人类命运共同体，提出共商共建共享的全球治理观，推动建设相互尊重、公平正义、合作共赢的新型国际关系，为推动国际关系民主化、改革和完善全球治理体系贡献中国方案；为解决世界面临的和平赤字，习近平同志提出对话而不对抗、结伴而不结盟的国家交往观，尊重彼此发展道路和社会制度的制度观，共同、综合、合作、可持续的新安全观，为维护世界和平贡献中国智慧。而我们要做的，就是用我们自己的行动支持这样的政策，为全世界的福祉尽自己的绵薄之力。</p>
<p>​    虽然我们如今的物质生活比过去好了不止一倍，但是我们所面临的挑战却比过去只重不轻。我们新时代的新青年站在时代的风口浪尖，要用自己的力量让中华这条巨龙能够腾飞在世界之东</p>
]]></content>
      <tags>
        <tag>形势与政策</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学：AES加密算法</title>
    <url>/2020/07/28/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9AAES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="现代密码学：AES加密算法"><a href="#现代密码学：AES加密算法" class="headerlink" title="现代密码学：AES加密算法"></a>现代密码学：AES加密算法</h1><h2 id="Part-1：Rijndael和他的数学基础"><a href="#Part-1：Rijndael和他的数学基础" class="headerlink" title="Part 1：Rijndael和他的数学基础"></a>Part 1：Rijndael和他的数学基础</h2><p><strong>AES</strong>本质上是一种加密标准，我们常说的AES加密其实是<strong>Rijndael加密算法</strong>。对于AES的加密标准不过多赘述，我们详细讲讲Rijndael算法。</p>
<p>Rijndael加密算法建立在一种特殊的数学结构上–有限域GF(2<sup>8</sup>)。在多项式表示中，GF(2<sup>8</sup>)上两个元素的和仍然是一个次数不超过7的多项式，其系数等于两个元素对应系数的模2加(比特异或)。</p>
<p>而如果要计算GF(2<sup>8</sup>)上的乘法，必须先确定一个GF(2)上的8次不可约多项式；GF(2<sup>8</sup>)上两个元素的乘积就是这两个多项式的模乘(以这个8次不可约多项式为模)。而在Rijndael密码中，这个8次不可约多项式确定为m(x) = x<sup>8</sup>+x<sup>4</sup>+x<sup>3</sup>+x+1，十六进制表示为“11B”</p>
<a id="more"></a>

<p>具体的数学知识在这里我们不涉及，接下来讲讲怎样在GF(2<sup>8</sup>)上建立我们的Rijndael加密算法。在GF(2<sup>8</sup>)上我们需要做模乘运算和模加运算。多项式的加法就是对应系数相加；换句话说，多项式的加法就是4字节向量的逐比特异或，这个很简单，应该都明白。多项式的乘法必须要取模n(x) = x<sup>4</sup>+1,这样使得次数小于4的多项式的乘积仍然是一个次数小于4的多项式。用下面这个例子来说明</p>
<p>设a(x) = a<sub>3</sub>x<sup>3</sup>+a<sub>2</sub>x<sup>2</sup>+a<sub>1</sub>x<sup>1</sup>+a<sub>0</sub>,b(x) = b<sub>3</sub>x<sup>3</sup>+b<sub>2</sub>x<sup>2</sup>+b<sub>1</sub>x<sup>1</sup>+b<sub>0</sub>, 则a(x) * b(x) = c(x) = c<sub>3</sub>x<sup>3</sup>+c<sub>2</sub>x<sup>2</sup>+c<sub>1</sub>x<sup>1</sup>+c<sub>0</sub></p>
<p>由于x<sup>j</sup> mod (x<sup>4</sup>+1) = x<sup>j mod4</sup>,所以我们可以通过这样的方式计算c(x)。</p>
<p><img src="https://i.loli.net/2020/07/27/p6x8kdAVf9TbjnK.png" alt="AES1.png"></p>
<p>上面的式子还可以用矩阵表示为</p>
<p><img src="https://i.loli.net/2020/07/27/h7HQ3ncYNCltF59.png" alt="AES2.png"></p>
<h2 id="Part-2：Rijndael的设计思想"><a href="#Part-2：Rijndael的设计思想" class="headerlink" title="Part 2：Rijndael的设计思想"></a>Part 2：Rijndael的设计思想</h2><p>以上就是Rijndael加密算法的数学基础，现在我们来看看他的设计思想，作为一个密码算法，Rijndael的设计力求满足以下三条标准</p>
<ul>
<li>抵抗所有已知的攻击</li>
<li>多平台兼容且快速，编码紧凑</li>
<li>设计简单</li>
</ul>
<p>当前的大多数分组密码，其轮函数是Feistel结构，即将中间状态的部分比特不加改变地简单放置到其它位置。Rijndael没有这种结构，其轮函数是由三个不同的可逆均匀变换组成的，称它们为三个“层”。所谓“均匀变换”是指状态的每个比特都是用类似的方法进行处理的。不同层的特定选择大部分是建立在“宽轨迹策略”的应用基础上的；简单地说，“宽轨迹策略”就是提供抗线性密码分析和差分密码分析能力的一种设计。为实现宽轨迹策略，轮函数三个层中的每一层都有它自己的功能：</p>
<ul>
<li><strong>线性混合</strong>层：确保多轮之上的高度扩散</li>
<li><strong>非线性</strong>层：将具有最优的“最坏情况非线性特性”的S盒并行使用</li>
<li><strong>密钥加</strong>层：单轮子密钥简单地异或到中间状态上，实现一次性掩盖</li>
</ul>
<p>在第一轮之前，用了一个初始密钥加层，其目的是在不知道密钥的情况下，对最后一个密钥加层以后的任一层（或者是当进行已知明文攻击时，对第一个密钥加层以前的任一层）可简单地剥去，因此初始密钥加层对密码的安全性无任何意义。许多密码的设计中都在轮变换之前和之后用了密钥加层，如IDEA、SAFER和Blowfish。</p>
<p>同时，为了使加密算法和解密算法在结构上更加接近，最后一轮的线性混合层与前面各轮的线性混合层不同，这类似于DES的最后一轮不做左右交换一样。可以证明这种设计不以任何方式提高或降低该密码的安全性。</p>
<p>类似于明文分组和密文分组，算法的中间结果也须分组，称算法中间结果的分组为状态，所有的操作都在状态上进行。状态可以用以字节为元素的矩阵阵列表示，该阵列有4行，列数记为N<sub>b</sub>，N<sub>b</sub>等于分组长度除以32。</p>
<p>种子密钥类似地用一个以字节为元素的矩阵阵列表示，该阵列有4行，列数记为N<sub>k</sub>，N<sub>k</sub>等于分组长度除以32。下表是N<sub>b</sub>=6的状态和N<sub>k</sub>=4的种子密钥的矩阵阵列表示。</p>
<p><img src="https://i.loli.net/2020/07/27/TlifR3OpdkFutEG.png" alt="AES3.png"></p>
<p>算法的输入和输出被看成是由8比特字节构成的一维数组，其元素下标的范围是0到4N<sub>b</sub> -1，因此输入和输出以字节为单位的分组长度分别是16、24和32，其元素下标的范围分别是0到15，0到23和0到31。输入的种子密钥也看成是由8比特字节构成的一维数组，其元素下标的范围是0到4N<sub>k</sub> -1，因此种子密钥以字节为单位的分组长度也分别是16、24和32，其元素下标的范围分别是0到15，0到23和0到31。</p>
<p>Rijndael的轮函数以下的四个不同的计算部件组成：<strong>字节代换</strong>（ByteSub），<strong>行移位</strong>（ShiftRow），<strong>列混淆（MixColumn）</strong>和<strong>密钥加</strong>（AddRoundKey）。接下来我们将对其进行分别介绍。</p>
<h3 id="字节代换ByteSub"><a href="#字节代换ByteSub" class="headerlink" title="字节代换ByteSub"></a>字节代换ByteSub</h3><p>字节代换是非线形变换，独立地对状态的每个字节进行。代换表（即S-盒）是可逆的，由以下两个变换的合成得到：</p>
<ol>
<li>将字节看作<em>GF</em>(2<sup>8</sup>)上的元素，映射到自己的乘法逆元，把<strong>00</strong>映射到自己。</li>
<li>对字节做如下的（GF(2)上的，可逆的）仿射变换：</li>
</ol>
<p><img src="https://i.loli.net/2020/07/27/fvAh8QdHXZe4r5m.png" alt="AES4.png"></p>
<p>这个变换过程难以理解的话可以看如下的示意图</p>
<p><img src="https://i.loli.net/2020/07/27/buQdWsyFtamH4M5.png" alt="AES5.png"></p>
<p>ByteSub的逆变换由代换表的逆表做字节代换，可通过如下两步实现，首先进行仿射变换的逆变换，再求每一字节在<em>GF</em>(2<sup>8</sup>)上逆元。</p>
<h3 id="行移位ShiftRow"><a href="#行移位ShiftRow" class="headerlink" title="行移位ShiftRow"></a>行移位ShiftRow</h3><p>行移位是将状态阵列的各行进行循环移位，不同状态行的位移量不同。第0行不移动，第一行循环左移C<sub>1</sub>个字节，第二行循环左移C<sub>2</sub>个字节，第三行循环左移C<sub>3</sub>个字节。位移量C<sub>1</sub>、C<sub>2</sub>、C<sub>3</sub>的取值与N<sub>b</sub>有关，由下表给出。</p>
<p><img src="https://i.loli.net/2020/07/27/TM2kslfnK4owyPI.png" alt="AES6.png"></p>
<p>同样的，我也极其贴心的准备了相应的示意图</p>
<p><img src="https://i.loli.net/2020/07/27/6uCTEdWHNGheZ5V.png" alt="AES7.png"></p>
<p>这个的逆运算不用讲了把，再左移N<sub>b</sub>-偏移量位就ok了</p>
<h3 id="列混淆MixColumn"><a href="#列混淆MixColumn" class="headerlink" title="列混淆MixColumn"></a>列混淆MixColumn</h3><p>在列混合变换中，将状态阵列的每个列视为GF(2<sup>8</sup>)上的多项式，再与一个固定的多项式c(x)进行模<em>x</em><sup>4</sup>+1乘法。当然要求c(x)是模<em>x</em><sup>4</sup>+1可逆的多项式，否则列混合变换就是不可逆的，因而会使不同的输入分组对应的输出分组可能相同。设计者给出的从c(x)为 <strong>03x<sup>3</sup>+01x<sup>2</sup>+01x<sup>1</sup>+02</strong>(系数为16进制)。同样的，列混淆可以写为矩阵乘法如下：</p>
<p><img src="https://i.loli.net/2020/07/27/EaJpm2sxPAOF1r3.png" alt="AES8.png"></p>
<p>示意图如下</p>
<p><img src="https://i.loli.net/2020/07/27/el9pbaNJjk3dimw.png" alt="AES9.png"></p>
<p>这个逆运算是将每一列用一个特定的多项式d(x)来乘，d(x)同样已经给出：<strong>0Bx<sup>3</sup>+0Dx<sup>2</sup>+09x<sup>1</sup>+0E</strong></p>
<h3 id="密钥加AddRoundKey"><a href="#密钥加AddRoundKey" class="headerlink" title="密钥加AddRoundKey"></a>密钥加AddRoundKey</h3><p>密钥加是将轮密钥简单地与状态进行逐比特异或。轮密钥由种子密钥通过密钥编排算法得到，轮密钥长度等于分组长度N<sub>b</sub></p>
<p><img src="https://i.loli.net/2020/07/27/8wTnDvbSk1IAGMX.png" alt="AES10.png"></p>
<p>这里我们注意到一个关键词：<strong>密钥编排</strong>，密钥编排是指从种子密钥得到轮密钥的过程，它由密钥扩展和轮密钥选取两部分组成。其基本原则如下：</p>
<ul>
<li>轮密钥的比特数等于分组长度乘以轮数加1</li>
<li>种子密钥被扩展成为扩展密钥</li>
<li>轮密钥从扩展密钥中取，其中第1轮轮密钥取扩展密钥的前N<sub>b</sub>个字，第2轮轮密钥取接下来N<sub>b</sub>个字，如此下去不断地取</li>
</ul>
<p>其中，扩展密钥是以4字节字为元素的一维阵列，表示为W[N<sub>b </sub>* (N<sub>r</sub>+1)],其中前N<sub>k</sub>个字取为种子密钥，以后每个字按递归方式定义。而其扩展算法在N<sub>k</sub>≤6和N<sub>k</sub>＞6是是不同的</p>
<h4 id="Nk≤6-时的扩展算法"><a href="#Nk≤6-时的扩展算法" class="headerlink" title="Nk≤6 时的扩展算法"></a>N<sub>k</sub>≤6 时的扩展算法</h4><p>其代码如下</p>
<p><img src="https://i.loli.net/2020/07/27/NUa8GVfdkYtEMsC.png" alt="AES11.png"></p>
<p>其中</p>
<p><img src="https://i.loli.net/2020/07/27/gc7bAJ3pGB1SOUu.png" alt="AES12.png"></p>
<p>其流程图如下</p>
<p><img src="https://i.loli.net/2020/07/27/6kujKd5QPTAVmXG.png" alt="AES13.png"></p>
<h4 id="Nk＞6-时的扩展算法"><a href="#Nk＞6-时的扩展算法" class="headerlink" title="Nk＞6 时的扩展算法"></a>N<sub>k</sub>＞6 时的扩展算法</h4><p>其代码如下</p>
<p><img src="https://i.loli.net/2020/07/27/SHpwartezZcNdXJ.png" alt="AES14.png"></p>
<p>其中</p>
<p><img src="https://i.loli.net/2020/07/27/TsFHGOZr7oqD3vV.png" alt="AES15.png"></p>
<p>其流程图为</p>
<p><img src="https://i.loli.net/2020/07/27/qkVHLSYnR52eQ6v.png" alt="AES16.png"></p>
<p>N<sub>k</sub>＞6与N<sub>k</sub>≤6的密钥扩展算法的区别在于：当i为N<sub>k</sub>的4的倍数时，须先将前一个字W[i-1]经过ByteSub变换。</p>
<p>以上两个算法中，Rcon[i/N<sub>k</sub>] 为轮常数，其值与N<sub>k</sub>无关，定义为（字节用16进制表示，同时理解为GF(2<sup>8</sup>)上的元素）： Rcon[i]=(RC[i], ‘00’, ‘00’, ‘00’)</p>
<p>其中RC[<em>i</em>] 是GF(2<sup>8</sup>)中值为<em>x**i</em>-1的元素，因此RC[1] =1(即‘01’),  RC[i]= <em>x</em>(即‘02’),  RC[i-1]= x<sup>i-1</sup></p>
<h4 id="轮密钥选取"><a href="#轮密钥选取" class="headerlink" title="轮密钥选取"></a>轮密钥选取</h4><p>轮密钥 i (即第 i 个轮密钥)由轮密钥缓冲字W[N<sub>b</sub>× i]到 W[N<sub>b</sub>× (i+1)-1]给出，如图所示</p>
<p><img src="https://i.loli.net/2020/07/27/gyMouTONH5X7P2E.png" alt="AES17.png"></p>
<h2 id="Part-3：加解密算法"><a href="#Part-3：加解密算法" class="headerlink" title="Part 3：加解密算法"></a>Part 3：加解密算法</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>加密算法为顺序完成以下操作：初始的密钥加，N<sub>r</sub> -1轮迭代，一个结尾轮，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RijndaelEncode(State,ExpandedKey)</span><br><span class="line">&#123;</span><br><span class="line">	AddRoundKey(State,ExpandedKey);&#x2F;&#x2F;初始密钥加</span><br><span class="line">	For(i&#x3D;1;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Round(State,ExpandedKey+Nb*i);&#x2F;&#x2F;迭代</span><br><span class="line">	&#125;</span><br><span class="line">	FinalRound(State,ExpandedKey+Nb*Nr);&#x2F;&#x2F;结尾轮</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Round函数和FinalRound函数的定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Round(State,RoundKey)</span><br><span class="line">&#123;</span><br><span class="line">	ByteSub(State);					&#x2F;&#x2F;字节代换</span><br><span class="line">	ShiftRow(State);				&#x2F;&#x2F;行移位</span><br><span class="line">	MixColumn(State);				&#x2F;&#x2F;列混淆</span><br><span class="line">	AddRoundKey(State,RoundKey);	&#x2F;&#x2F;密钥加</span><br><span class="line">&#125;</span><br><span class="line">FinalRound(State,RoundKey)</span><br><span class="line">&#123;</span><br><span class="line">	ByteSub(State);					&#x2F;&#x2F;字节代换</span><br><span class="line">	ShiftRow(State);				&#x2F;&#x2F;行移位</span><br><span class="line">	AddRoundKey(State,RoundKey);	&#x2F;&#x2F;密钥加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解密算法"><a href="#解密算法" class="headerlink" title="解密算法"></a>解密算法</h3><p>在上面对ByteSub，ShiftRow和MixColumn的介绍中我们也提及了这三个部分的逆过程。不妨称之为InvBS，InvSR，InvMC。和DES算法相同，Rijndael的解密过程和加密过程也极其相似，同样包括初始的密钥加，N<sub>r</sub> -1轮迭代和一个结尾轮，有所区别的只有两个轮函数不同，总解密过程和轮函数的定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RijndaelDecode(State,ExpandedKey)</span><br><span class="line">&#123;</span><br><span class="line">	AddRoundKey(State,ExpandedKey);&#x2F;&#x2F;初始密钥加</span><br><span class="line">	For(i&#x3D;1;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		InvRound(State,ExpandedKey+Nb*i);&#x2F;&#x2F;迭代</span><br><span class="line">	&#125;</span><br><span class="line">	InvFinalRound(State,ExpandedKey+Nb*Nr);&#x2F;&#x2F;结尾轮</span><br><span class="line">&#125;</span><br><span class="line">InvRound(State,RoundKey)</span><br><span class="line">&#123;</span><br><span class="line">	InvBS(State);					&#x2F;&#x2F;逆字节代换</span><br><span class="line">	InvSR(State);					&#x2F;&#x2F;逆行移位</span><br><span class="line">	InvMC(State);					&#x2F;&#x2F;逆列混淆</span><br><span class="line">	AddRoundKey(State,RoundKey);	&#x2F;&#x2F;密钥加</span><br><span class="line">&#125;</span><br><span class="line">InvFinalRound(State,RoundKey)</span><br><span class="line">&#123;</span><br><span class="line">	InvBS(State);					&#x2F;&#x2F;逆字节代换</span><br><span class="line">	InvSR(State);					&#x2F;&#x2F;逆行移位</span><br><span class="line">	AddRoundKey(State,RoundKey);	&#x2F;&#x2F;逆密钥加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这就是AES算法我们要介绍的所有内容了，老样子，你可以<em><a href="https://github.com/TequilaWch/Cipher" target="_blank" rel="noopener">https://github.com/TequilaWch/Cipher</a></em>找到相关的Cpp代码，喜欢的话点个Star吧(卑微)。</p>
]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学：DES加密算法</title>
    <url>/2020/07/28/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9ADES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="现代密码学：DES加密算法"><a href="#现代密码学：DES加密算法" class="headerlink" title="现代密码学：DES加密算法"></a>现代密码学：DES加密算法</h1><h2 id="Part-1：DES的基本概念"><a href="#Part-1：DES的基本概念" class="headerlink" title="Part 1：DES的基本概念"></a>Part 1：DES的基本概念</h2><p>随着时代的不断变化，之前所提到的凯撒密码和单表置换密码逐渐难以满足人们对于密文安全性的需求，于是一种新的密码体制应运而生——<em>对称密码体制</em> ，而我们本文中要介绍的<strong>DES加密算法</strong>是对称密码体制中，分组密码的一个子类。</p>
<p>在分组密码的发展历史中，出现了许多种优秀的算法，包括IDEA，AES，Safer＋＋和本文的主角<strong>DES</strong>算法。他们都拥有一个共同的特点：在其明文加密和密文解密的过程中，信息按照固定长度分组进行处理。以<strong>DES算法</strong>为例，<strong>DES算法</strong>将明文分成64位大小的众多数据块，即分组长度为64位。同时用56位密钥对64位明文信息加密，最终形成64位的密文。如果明文长度不足64位，即将其用补零的方式扩展为64位。</p>
<a id="more"></a>

<p><strong>DES算法</strong>的具体加密过程为：首先将输入的数据进行初始置换（IP），即将明文M中数据的排列顺序按一定的规则重新排列，生成新的数据序列，以打乱原来的次序。然后将变换后的数据平分成左右两部分，将左边记为L<sub>0</sub>,右边记为R<SUB>0</SUB>。之后对R<SUB>0</SUB>和子密钥K<SUB>1</SUB>输入变换函数f进行一次变换，将得到的结果f(R<SUB>0</SUB>,K<SUB>1</SUB>)与L<sub>0</sub>按位进行异或运算，将结果记为R<sub>1</sub>,把R<sub>0</sub>作为L<sub>1</sub>进行下一轮操作，共进行16轮运算以得到L<sub>16</sub>和R<sub>16</sub>，最后将L<sub>16</sub>和R<sub>16</sub>进行逆初始置换IP<sup>-1</sup>就得到了加密数据。需要注意的是每一轮中的子密钥K<SUB>n</SUB>都是由56位密钥K生成的子密钥。</p>
<p><strong>DES算法</strong>的解密过程与加密过程类似，只不过是子密钥的使用顺序与加密时刚好相反，其加密过程的流程图如下所示：</p>
<p><img src="/images/DES1.jpg" alt="流程图"></p>
<h2 id="Part-2：基本函数介绍"><a href="#Part-2：基本函数介绍" class="headerlink" title="Part 2：基本函数介绍"></a>Part 2：基本函数介绍</h2><p>上一部分中，我们可以得到这样三个关键函数<strong>初始置换IP</strong>，<strong>变换f</strong> 和<strong>逆初始置换IP<sup>－1</sup></strong>。在这一部分，我将对这三个基本函数进行详细介绍。看在我如此辛苦的进行介绍的份上，真的不来<em><a href="https://github.com/TequilaWch/Cipher" target="_blank" rel="noopener">https://github.com/TequilaWch/Cipher</a></em>点一个<strong>star</strong>么？</p>
<h3 id="初始置换IP"><a href="#初始置换IP" class="headerlink" title="初始置换IP"></a>初始置换IP</h3><p>它的作用是把输入的64位数据块的排列顺序打乱，每位数据按照下面的置换规则重新排列，即将第58位换到第一位，第50位换打第2位，…，依次类推。置换后的64位输出分为L0 、R0（左、右）两部分，每部分分别为32位。以下是置换表：</p>
<table>
<thead>
<tr>
<th align="center"><strong>58</strong></th>
<th><strong>50</strong></th>
<th><strong>42</strong></th>
<th><strong>34</strong></th>
<th><strong>26</strong></th>
<th><strong>18</strong></th>
<th><strong>10</strong></th>
<th><strong>2</strong></th>
<th><strong>60</strong></th>
<th><strong>52</strong></th>
<th><strong>44</strong></th>
<th><strong>36</strong></th>
<th><strong>28</strong></th>
<th><strong>20</strong></th>
<th><strong>12</strong></th>
<th><strong>4</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>62</strong></td>
<td><strong>54</strong></td>
<td><strong>46</strong></td>
<td><strong>38</strong></td>
<td><strong>30</strong></td>
<td><strong>22</strong></td>
<td><strong>14</strong></td>
<td><strong>6</strong></td>
<td><strong>64</strong></td>
<td><strong>56</strong></td>
<td><strong>48</strong></td>
<td><strong>40</strong></td>
<td><strong>32</strong></td>
<td><strong>24</strong></td>
<td><strong>16</strong></td>
<td><strong>8</strong></td>
</tr>
<tr>
<td align="center"><strong>57</strong></td>
<td><strong>49</strong></td>
<td><strong>41</strong></td>
<td><strong>33</strong></td>
<td><strong>25</strong></td>
<td><strong>17</strong></td>
<td><strong>9</strong></td>
<td><strong>1</strong></td>
<td><strong>59</strong></td>
<td><strong>51</strong></td>
<td><strong>43</strong></td>
<td><strong>35</strong></td>
<td><strong>27</strong></td>
<td><strong>19</strong></td>
<td><strong>11</strong></td>
<td><strong>3</strong></td>
</tr>
<tr>
<td align="center"><strong>61</strong></td>
<td><strong>53</strong></td>
<td><strong>45</strong></td>
<td><strong>37</strong></td>
<td><strong>29</strong></td>
<td><strong>21</strong></td>
<td><strong>13</strong></td>
<td><strong>5</strong></td>
<td><strong>63</strong></td>
<td><strong>55</strong></td>
<td><strong>47</strong></td>
<td><strong>39</strong></td>
<td><strong>31</strong></td>
<td><strong>23</strong></td>
<td><strong>15</strong></td>
<td><strong>7</strong></td>
</tr>
</tbody></table>
<h3 id="变换函数f"><a href="#变换函数f" class="headerlink" title="变换函数f"></a>变换函数f</h3><p>在讲变换函数f之前，我们要先讲讲子密钥K<SUB>n</SUB>的生成,他的生成过程如下流程图所示。这里的PC-1为选择置换，可以去掉奇偶校验位。PC-2也是选择置换，它是用于从C<sub>i</sub>和D<sub>i</sub>中选取48位作为密钥K<sub>i</sub>。C<sub>0</sub>和D<sub>0</sub>是把密钥中实际的56位分成左右28位，LS<sub>i</sub>是表示对C<sub>i-1</sub>和D<sub>i-1</sub>进行循环左移变换，其中LS<sub>1</sub>,LS<sub>2</sub>,LS<sub>9</sub>,LS<sub>16</sub>是循环左移1位，其余为2位。</p>
<p><img src="/images/DES2.png" alt="子密钥生成"></p>
<p>有没有发现一个问题，我们得到的每个子密钥都是48比特，然而我们输入的R<sub>i</sub>仅仅只有32位,因此我们还需要一个扩展过程将R<sub>i</sub>扩展为48为，这个扩展的基本思想是重复使用其中的16位，具体扩展置换表如下(<em>斜体</em>为重复部分)：</p>
<table>
<thead>
<tr>
<th align="center"><strong><em>32</em></strong></th>
<th align="center"><strong>1</strong></th>
<th align="center"><strong>2</strong></th>
<th align="center"><strong>3</strong></th>
<th align="center"><strong>4</strong></th>
<th align="center"><strong><em>5</em></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong><em>4</em></strong></td>
<td align="center"><strong>5</strong></td>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>7</strong></td>
<td align="center"><strong>8</strong></td>
<td align="center"><strong><em>9</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>8</em></strong></td>
<td align="center"><strong>9</strong></td>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>11</strong></td>
<td align="center"><strong>12</strong></td>
<td align="center"><strong><em>13</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>12</em></strong></td>
<td align="center"><strong>13</strong></td>
<td align="center"><strong>14</strong></td>
<td align="center"><strong>15</strong></td>
<td align="center"><strong>16</strong></td>
<td align="center"><strong><em>17</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>16</em></strong></td>
<td align="center"><strong>17</strong></td>
<td align="center"><strong>18</strong></td>
<td align="center"><strong>19</strong></td>
<td align="center"><strong>20</strong></td>
<td align="center"><strong><em>21</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>20</em></strong></td>
<td align="center"><strong>21</strong></td>
<td align="center"><strong>22</strong></td>
<td align="center"><strong>23</strong></td>
<td align="center"><strong>24</strong></td>
<td align="center"><strong><em>25</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>24</em></strong></td>
<td align="center"><strong>25</strong></td>
<td align="center"><strong>26</strong></td>
<td align="center"><strong>27</strong></td>
<td align="center"><strong>28</strong></td>
<td align="center"><strong><em>29</em></strong></td>
</tr>
<tr>
<td align="center"><strong><em>28</em></strong></td>
<td align="center"><strong>29</strong></td>
<td align="center"><strong>30</strong></td>
<td align="center"><strong>31</strong></td>
<td align="center"><strong>32</strong></td>
<td align="center"><strong><em>1</em></strong></td>
</tr>
</tbody></table>
<p>这样，我们就有了一个48位的子密钥和一个扩展后的输入（不妨叫做x），我们把这个x和子密钥进行按位异或，得到一个总的48位结果（就叫y吧），但是我们需要一个32位的输出，直接输出y显然不可行，我们需要将其6位一组分成8组，输入8个s盒之中，每个s盒的输出是4位，这样就得到了32位的输出。具体流程图如下：</p>
<p><img src="/images/DES3.png" alt="变换函数f"></p>
<p>你的下一句话是：这个s盒是什么东西呢？我们用S<sub>1</sub>来举例，相信你一下就懂了。比如前6位是110101，把他输入S<sub>1</sub>后，取出他的第一位和最后一位(先前的重复位)构成行(这里是11即3)，剩下四位构成列(1010即10)，对照S<sub>1</sub>，我们的结果就是3，也就是0011。</p>
<p><img src="/images/DES5.png" alt="S盒1，2"></p>
<p>全部s盒的定义我们也放在下面(虽然不是很清楚)</p>
<p><img src="/images/DES4.png" alt="S盒"></p>
<h3 id="逆初始置换IP－1"><a href="#逆初始置换IP－1" class="headerlink" title="逆初始置换IP－1"></a><strong>逆初始置换IP<sup>－1</sup></strong></h3><p>逆初始置换其实就是初始置换的逆，话不多说，直接上表。</p>
<table>
<thead>
<tr>
<th align="center"><strong>40</strong></th>
<th align="center"><strong>8</strong></th>
<th align="center"><strong>48</strong></th>
<th align="center"><strong>16</strong></th>
<th align="center"><strong>56</strong></th>
<th align="center"><strong>24</strong></th>
<th align="center"><strong>64</strong></th>
<th align="center"><strong>32</strong></th>
<th align="center"><strong>39</strong></th>
<th align="center"><strong>7</strong></th>
<th align="center"><strong>47</strong></th>
<th align="center"><strong>15</strong></th>
<th align="center"><strong>55</strong></th>
<th align="center"><strong>23</strong></th>
<th align="center"><strong>63</strong></th>
<th align="center"><strong>31</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>38</strong></td>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>46</strong></td>
<td align="center"><strong>14</strong></td>
<td align="center"><strong>54</strong></td>
<td align="center"><strong>22</strong></td>
<td align="center"><strong>62</strong></td>
<td align="center"><strong>30</strong></td>
<td align="center"><strong>37</strong></td>
<td align="center"><strong>5</strong></td>
<td align="center"><strong>45</strong></td>
<td align="center"><strong>13</strong></td>
<td align="center"><strong>53</strong></td>
<td align="center"><strong>21</strong></td>
<td align="center"><strong>61</strong></td>
<td align="center"><strong>29</strong></td>
</tr>
<tr>
<td align="center"><strong>36</strong></td>
<td align="center"><strong>4</strong></td>
<td align="center"><strong>44</strong></td>
<td align="center"><strong>12</strong></td>
<td align="center"><strong>52</strong></td>
<td align="center"><strong>20</strong></td>
<td align="center"><strong>60</strong></td>
<td align="center"><strong>28</strong></td>
<td align="center"><strong>35</strong></td>
<td align="center"><strong>3</strong></td>
<td align="center"><strong>43</strong></td>
<td align="center"><strong>11</strong></td>
<td align="center"><strong>51</strong></td>
<td align="center"><strong>19</strong></td>
<td align="center"><strong>59</strong></td>
<td align="center"><strong>27</strong></td>
</tr>
<tr>
<td align="center"><strong>34</strong></td>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>42</strong></td>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>50</strong></td>
<td align="center"><strong>18</strong></td>
<td align="center"><strong>58</strong></td>
<td align="center"><strong>26</strong></td>
<td align="center"><strong>33</strong></td>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>41</strong></td>
<td align="center"><strong>9</strong></td>
<td align="center"><strong>49</strong></td>
<td align="center"><strong>17</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>25</strong></td>
</tr>
</tbody></table>
<h2 id="Part-3：DES的一些其他用法"><a href="#Part-3：DES的一些其他用法" class="headerlink" title="Part 3：DES的一些其他用法"></a>Part 3：DES的一些其他用法</h2><p>自DES算法问世以来，就一直是一种重要的加密方式，为了防止一重DES加密被破解，又衍生出了许多种DES算法的特殊用法，在这里简要提一些。</p>
<h3 id="双重DES"><a href="#双重DES" class="headerlink" title="双重DES"></a>双重DES</h3><p>顾名思义，两个密钥，两次DES，流程图如下</p>
<p><img src="/images/DES6.png" alt="双重DES"></p>
<h3 id="双密钥三重DES"><a href="#双密钥三重DES" class="headerlink" title="双密钥三重DES"></a>双密钥三重DES</h3><p>因为DES的加密算法和解密算法其实过程相同，某些时候也可以把解密算法当作加密算法使用，双密钥三重DES应运而生</p>
<p><img src="/images/DES7.png" alt="双密钥三重DES"></p>
]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学：移位密码和单表置换密码</title>
    <url>/2020/07/28/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9A%E7%A7%BB%E4%BD%8D%E5%AF%86%E7%A0%81%E5%92%8C%E5%8D%95%E8%A1%A8%E7%BD%AE%E6%8D%A2%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="现代密码学：移位密码和单表置换密码"><a href="#现代密码学：移位密码和单表置换密码" class="headerlink" title="现代密码学：移位密码和单表置换密码"></a>现代密码学：移位密码和单表置换密码</h1><h2 id="Part-1：移位密码（以凯撒密码为例）"><a href="#Part-1：移位密码（以凯撒密码为例）" class="headerlink" title="Part 1：移位密码（以凯撒密码为例）"></a>Part 1：移位密码（以凯撒密码为例）</h2><p>古时候，战事频繁，为了在军队之间传递军情而不被敌手破解，密码学应运而生。其中最著名的一种密码便是由尤利乌斯凯撒发明的<em>凯撒密码</em>。</p>
<p>这种密码是一种<em>移位密码</em>，其基本思路就是将英文字母向前或向后移动一个固定位置，只有信息的接收方和发送方知道偏移量，从而起到加密的效果。我们例子中的凯撒密码就是一种偏移量为+3的移位密码（向后偏移三位），其字母对照表如下：</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>原信息</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
<th>J</th>
<th>K</th>
<th>L</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td><strong>密文</strong></td>
<td><strong>D</strong></td>
<td><strong>E</strong></td>
<td><strong>F</strong></td>
<td><strong>G</strong></td>
<td><strong>H</strong></td>
<td><strong>I</strong></td>
<td><strong>J</strong></td>
<td><strong>K</strong></td>
<td><strong>L</strong></td>
<td><strong>M</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>P</strong></td>
</tr>
<tr>
<td><strong>原信息</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>P</strong></td>
<td><strong>Q</strong></td>
<td><strong>R</strong></td>
<td><strong>S</strong></td>
<td><strong>T</strong></td>
<td><strong>U</strong></td>
<td><strong>V</strong></td>
<td><strong>W</strong></td>
<td><strong>X</strong></td>
<td><strong>Y</strong></td>
<td><strong>Z</strong></td>
</tr>
<tr>
<td><strong>密文</strong></td>
<td><strong>Q</strong></td>
<td><strong>R</strong></td>
<td><strong>S</strong></td>
<td><strong>T</strong></td>
<td><strong>U</strong></td>
<td><strong>V</strong></td>
<td><strong>W</strong></td>
<td><strong>X</strong></td>
<td><strong>Y</strong></td>
<td><strong>Z</strong></td>
<td><strong>A</strong></td>
<td><strong>B</strong></td>
<td><strong>C</strong></td>
</tr>
</tbody></table>
<p>例如 明文 <strong>WCH IS HANDSOME</strong> 就会被加密为 <strong>ZFK LV KDQGVRPH</strong></p>
<p>如果把A-Z用0-25编码，明文M = m<sub>0</sub>m<sub>1</sub>……m<sub>n</sub>,  密文C = c<sub>0</sub>c<sub>1</sub>……c<sub>n</sub>,偏移量(密钥)key = +3 ，则上述加密可以表示为 c<sub>i</sub> ≡ m<sub>i</sub>+key mod(26)</p>
<p>在算力尚不发达的古代，这种密码具有很高的安全性，然而在现在一个小孩子依靠电脑也可以轻而易举的破解这种密码，根本原因在于其有效密钥空间太小（仅为25），一台计算机轻轻松松的就可以将其计算出来。有兴趣的读者可以尝试破解以下密文来证明我所言不虚2333</p>
<blockquote>
<p>WKDQNV IRU UHDGLQJ PB EORJ, L GR UHDOOB KRSH BRX KDYH D QLFH GDB! ORYH BRX PB GHDU IULHQG.</p>
<p>LI BRX KDYH EHHQ KHUH , BRX FDQ ILQG PB F SOXV SOXV FRGH DERXW FDHVDU FLSKHU DW WKH DGGUHVV EHORZ,SOHDVH JLYH PH D VWDU DQG IRUN:</p>
<blockquote>
<p>kwwsv://jlwkxe.frp/WhtxlodZfk/Flskhu</p>
</blockquote>
</blockquote>
<h2 id="PART-2：单表置换密码"><a href="#PART-2：单表置换密码" class="headerlink" title="PART 2：单表置换密码"></a>PART 2：单表置换密码</h2><p>单表置换密码是移位密码的一个升级，顾名思义，他不再是简单的将字母前移或者后移，而是建立一些无规律的一一对应关系，例如如下置换：</p>
<table>
<thead>
<tr>
<th>原信息</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
<th>J</th>
<th>K</th>
<th>L</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td><strong>密文</strong></td>
<td><strong>H</strong></td>
<td><strong>K</strong></td>
<td><strong>W</strong></td>
<td><strong>T</strong></td>
<td><strong>X</strong></td>
<td><strong>Y</strong></td>
<td><strong>S</strong></td>
<td><strong>G</strong></td>
<td><strong>B</strong></td>
<td><strong>P</strong></td>
<td><strong>Q</strong></td>
<td><strong>E</strong></td>
<td><strong>J</strong></td>
</tr>
<tr>
<td><strong>原信息</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>P</strong></td>
<td><strong>Q</strong></td>
<td><strong>R</strong></td>
<td><strong>S</strong></td>
<td><strong>T</strong></td>
<td><strong>U</strong></td>
<td><strong>V</strong></td>
<td><strong>W</strong></td>
<td><strong>X</strong></td>
<td><strong>Y</strong></td>
<td><strong>Z</strong></td>
</tr>
<tr>
<td><strong>密文</strong></td>
<td><strong>A</strong></td>
<td><strong>Z</strong></td>
<td><strong>M</strong></td>
<td><strong>L</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>F</strong></td>
<td><strong>C</strong></td>
<td><strong>I</strong></td>
<td><strong>D</strong></td>
<td><strong>V</strong></td>
<td><strong>U</strong></td>
<td><strong>R</strong></td>
</tr>
</tbody></table>
<p>就会把明文<strong>WCH IS HANDSOME</strong> 加密为<strong>DWG BO GHATOZJX</strong>。单表置换密码实现的关键问题是置换表的构造，虽然有很多种途径可以实现，但是考虑到记忆和使用的方便，我们可以选择一个短语或者句子，删除掉其重复的字母，依次填入置换表前面的部分，再把没有用上的字母依次填入置换表的后面部分，还是用<strong>WCH IS HANDSOME</strong>来举例（别骂我<del>我本来就帅</del>）,去掉重复字母后，得到密钥<strong>WCHISANDOME</strong>,剩余的字母为<strong>BFGJKLPQRTUVXYZ</strong>，我们就可以把A-Z的字母依次替换为：</p>
<blockquote>
<blockquote>
<blockquote>
<p><strong>WCHISANDOMEBFGJKLPQRTUVXYZ</strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>单表置换密码相比于移位密码，其强度体现在更大的有效密钥空间，其置换表的字母组合高达26！种，如果再采用穷举密钥的方式来破解实在憨憨，因此对于单表置换密码最有效的攻击方法是利用自然语言的使用频率和语义分析相结合的方法，仅以英文为例。英文具有以下显著特征：</p>
<ol>
<li><p><strong>短单词(small words)</strong>：在英文中只有很少几个非常短的单词。因此，如果在一个加密的文本中可以确定单词的范围，那么就能得出明显的结果。一个字母的单词只有a和I。如果不计单词的缩写，在从电子邮件中选取500k字节的样本中，只有两个字母的单词仅出现35次，而两个字母的所有组合为26×26＝676种。而且，还是在那个样本中，只有三个字母的单词出现196次，而三个字母的所有组合为26×26×26＝17576种。</p>
</li>
<li><p><strong>常用单词(common words)</strong>：再次分析500k字节的样本，总共有5000多个不同的单词出现。在这里，9个最常用的单词出现的总次数占总单词数的21％，20个最常用的单词出现的总次数占总单词数的30％，104个最常用的单词占50％，247个最常用的单词占60％。样本中最常用的9个单词占总词数的百分比为：</p>
<table>
<thead>
<tr>
<th>单词</th>
<th>the</th>
<th>to</th>
<th>of</th>
<th>I</th>
<th>a</th>
<th>and</th>
<th>is</th>
<th>that</th>
<th>in</th>
</tr>
</thead>
<tbody><tr>
<td>频率%</td>
<td>4.65</td>
<td>3.02</td>
<td>2.61</td>
<td>2.2</td>
<td>1.95</td>
<td>1.82</td>
<td>1.68</td>
<td>1.62</td>
<td>1.57</td>
</tr>
</tbody></table>
</li>
<li><p><strong>字母频率(character frequency):</strong>在1M字节旧的电子文本中，对字母”A”到“Z”（忽略大小写）分别进行统计。发现近似频率从高往低排列（以百分比表示）:</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>e</th>
<th>t</th>
<th>o</th>
<th>i</th>
<th>a</th>
<th>n</th>
<th>s</th>
<th>r</th>
<th>h</th>
<th>l</th>
<th>d</th>
<th>u</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>频率</td>
<td>11.67</td>
<td>9.53</td>
<td>8.22</td>
<td>7.81</td>
<td>7.73</td>
<td>6.71</td>
<td>6.55</td>
<td>5.97</td>
<td>4.52</td>
<td>4.3</td>
<td>3.24</td>
<td>3.21</td>
<td>3.06</td>
</tr>
<tr>
<td><strong>字母</strong></td>
<td><strong>m</strong></td>
<td><strong>p</strong></td>
<td><strong>y</strong></td>
<td><strong>f</strong></td>
<td><strong>g</strong></td>
<td><strong>w</strong></td>
<td><strong>b</strong></td>
<td><strong>v</strong></td>
<td><strong>k</strong></td>
<td><strong>x</strong></td>
<td><strong>j</strong></td>
<td><strong>q</strong></td>
<td><strong>z</strong></td>
</tr>
<tr>
<td>频率</td>
<td>2.8</td>
<td>2.34</td>
<td>2.22</td>
<td>2.14</td>
<td>2.00</td>
<td>1.69</td>
<td>1.58</td>
<td>1.03</td>
<td>0.79</td>
<td>0.30</td>
<td>0.23</td>
<td>0.12</td>
<td>0.09</td>
</tr>
</tbody></table>
</li>
</ol>
<p>从该表中可以看出，最常用的单字母英文是e和t，其他字母使用频率相对来说就小得多。这样，攻击一个单表置换密码，首先统计密文中最常出现的字母，并据此猜出两个最常用的字母，并根据英文统计的其他特征（如字母组合等）进行试译。</p>
]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
</search>
